"use strict";

var util = require('util');

var path = require( 'path' );

var python = require('python-shell');

var pythonMain = "Main.py";

/** 
 * We wrap the module in an argument environment
 * inherited from the commandline invocation. This
 * sets up the python subprocess configuration and
 * returns the PythonFile constructor.
 * 
 * @param  {Object} args commandline arguments
 * @return {(string, Log) -> PythonFile}     PythonFile Construtor
 */
module.exports = function ( args ) {

	var configuration = {

		mode: 'text',

		pythonPath: path.join( path.resolve( args.parse_tool ), '.env', 'bin', 'python' ),

		pythonOptions: ['-u'],

		scriptPath: path.resolve( args.parse_tool )

	};

	return function PythonFile( filename, log ) {
		if ( !(this instanceof PythonFile) ) { return new PythonFile( filename, log ); }
		var self = this;

		/**
		 * Given the filepath to a python source file,
		 * We pass the handle to a python subprocess for
		 * parsing, and retreive the resultant AST, or else
		 * handle errors. Errors / results are passed to 
		 * to the supplied continuation, after the results of the
		 * dispatch and log routines.
		 * 
		 * @param {(filepath, AST) -> {prefix: [String], value: JSON }} transform a function describing how to reduce a successful map of this file.
		 * @param {(result) -> ()} done a continuation describing how to continue processing.
		 */
		self.parse = function( transform, done ) {

			configuration.args = [ '-p', path.resolve( filename ) ];

			python.run(
				pythonMain,
				configuration,
				function( pythonError, result ) {

					if ( pythonError ) { dispatch( transform, done, pythonError ); }

					else {

						try {

							dispatch( transform, done, null, JSON.parse( result ) );

						} catch ( parseError ) {

							dispatch( transform, done, parseError );

						}

					}

				}
			);
		};

		var dispatch = function( transform, done, error, result ) {

			if ( error !== null ) {
				/* 
				 *  We've encountered a low-level python error, or system error.
				 *  We should log the file that threw this error, the class of error,
				 *  and as much debugging information as possible. This could also
				 *  be a JSON parse error, produced by the `JSON` output from the 
				 *  python parse process. This indicates a problem with the decodes
				 *  parse script, and should also be logged in its entirety.
				 */

				log.lock( function( methods ) {

				});


			} else if ( result.success === false ) {
				/* 
				 *  We've encountered an error the was generated by the python parse
				 *  process. This could be a low-level python IOError, or a SyntaxError
				 *  in the specified source file. We should log this error for future resolution.
				 */
				
				console.log( result );

				log.lock( function( methods ) {


					if ( result.errno === -1 ) {

						methods.record( Date.now(), filename, result.context, "Syntax" );

					} else {

						methods.record( Date.now(), filename, result.message, "PY IO" );

					}

					done( result );

				});

			} else {
				/*
				 *  We've fallen through to the success case. If we've reached this point,
				 *  we've recieved the valid JSON representation of an AST parse from the
				 *  python child process, and we're free to fold it in whatever way we see fit.
				 *  We want to construct two pieces of data.
				 *
				 *  A) we want to build a log entry recording the source, status, and sink of the parse.
				 *
				 *  B) we want to collapse the parsed AST into an appropriate folded version of the file,
				 *     and stash it in the correct place in the JSON hierarchy being constructed. We can also
				 *     stash the AST we've recovered for subsequent processing.
				 */
				
				/**
				 * truncated should hold an object [{ prefixes: [String], value: JSON }];
				 */
				try {

					var quotients = transform( path.resolve( filename ), result.ast );
					console.log( util.inspect( quotients, false, null, true ) );

				} catch ( e ) {

					console.error( e );

				}

				
				
				log.lock( function( methods ) {

				 	methods.record( Date.now(), filename, undefined, "OK" );

				 	// quotients.forEach( function( quotient ) {
				 	// 	methods.write( quotient.prefixes, quotient.value );
				 	// });

				});

				done( result );

			}

		};

	};
};

