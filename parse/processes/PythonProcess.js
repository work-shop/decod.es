"use strict";

var util = require('util');

var path = require( 'path' );

var python = require('python-shell');

var pythonMain = "Main.py";

var maxParseAttempts = 5;

/** 
 * We wrap the module in an argument environment
 * inherited from the commandline invocation. This
 * sets up the python subprocess configuration and
 * returns the PythonFile constructor.
 * 
 * @param  {Object} args commandline arguments
 * @return {(string, Log) -> PythonFile}     PythonFile Construtor
 */
module.exports = function ( args ) {

	var configuration = {

		mode: 'text',

		pythonPath: path.join( path.resolve( args.parse_tool ), '.env', 'bin', 'python' ),

		pythonOptions: ['-u'],

		scriptPath: path.resolve( args.parse_tool )

	};

	return function PythonFile( filename, log ) {
		if ( !(this instanceof PythonFile) ) { return new PythonFile( filename, log ); }
		var self = this;

		/**
		 * Given the filepath to a python source file,
		 * We pass the handle to a python subprocess for
		 * parsing, and retreive the resultant AST, or else
		 * handle errors. Errors / results are passed to 
		 * to the supplied continuation, after the results of the
		 * dispatch and log routines.
		 * 
		 * @param {(filepath, AST) -> {prefix: [String], value: JSON }} transform a function describing how to reduce a successful map of this file.
		 * @param {(result) -> ()} done a continuation describing how to continue processing.
		 */
		self.run = function( transform, done, attempt ) {

			attempt = attempt || 1;

			configuration.args = [ '-p', path.resolve( filename ) ];

			python.run(
				pythonMain,
				configuration,
				function( pythonError, result ) {

					if ( pythonError ) { 

						dispatch( transform, done, pythonError ); 

					} else {

						try {
							if ( result === null ) {

								 if ( attempt === maxParseAttempts ) {

								 	throw new Error( util.format( 'NullOutputError: recieved \"null\" back from subprocess after %d attempts.', maxParseAttempts  ) )

								 } else {

								 	self.run( transform, done, attempt + 1 );

								 }

							} else {

								dispatch( transform, done, null, JSON.parse( result ), attempt );

							}

						} catch ( parseError ) {

							dispatch( transform, done, parseError );

						}

					}

				}
			);
		};

		var dispatch = function( transform, done, error, result, attempts ) {

			if ( error !== null ) {
				/* 
				 *  We've encountered a low-level python error, or system error.
				 *  We should log the file that threw this error, the class of error,
				 *  and as much debugging information as possible. This could also
				 *  be a JSON parse error, produced by the `JSON` output from the 
				 *  python parse process. This indicates a problem with the decodes
				 *  parse script, and should also be logged in its entirety.
				 */
				
				//console.log( error );

				log.lock( function( methods ) {

					if ( error.errno === -1 ) {

						methods.record( Date.now(), filename, error.toString(), "Parse" );

					} else {

						methods.record( Date.now(), filename, error.toString(), "PY IO" );

					}

				});

				done( error );

			} else if ( result.success === false ) {
				/* 
				 *  We've encountered an error the was generated by the python parse
				 *  process. This could be a low-level python IOError, or a SyntaxError
				 *  in the specified source file. We should log this error for future resolution.
				 */
				
				//console.log( result );

				log.lock( function( methods ) {


					if ( result.errno === -1 ) {

						methods.record( Date.now(), filename, result.context, "Syntax" );

					} else {

						methods.record( Date.now(), filename, result.message, "PY IO" );

					}
					
				});

				done( result );

			} else {
				/*
				 *  We've fallen through to the success case. If we've reached this point,
				 *  we've recieved the valid JSON representation of an AST parse from the
				 *  python child process, and we're free to fold it in whatever way we see fit.
				 *  We want to construct two pieces of data.
				 *
				 *  A) we want to build a log entry recording the source, status, and sink of the parse.
				 *
				 *  B) we want to collapse the parsed AST into an appropriate folded version of the file,
				 *     and stash it in the correct place in the JSON hierarchy being constructed. We can also
				 *     stash the AST we've recovered for subsequent processing.
				 */
				
				/**
				 * truncated should hold an object [{ prefixes: [String], value: JSON }];
				 */
				var quotients;

				try {

					quotients = { success: true, result: transform( path.resolve( filename ), result.ast ) };

				} catch ( e ) {

					quotients = { success: false, message: e.toString(), result: [ false ]};

				} finally {

					log.lock( function( methods ) {

						var successes = quotients.result.reduce( function( b, a ) { return ( a !== false ) ? b + 1 : b; }, 0);

						if ( quotients.success ) {

							methods.expect( function( n ) { return n + successes; } );

						 	quotients.result.forEach( function( quotient, index ) {

						 		if ( quotient ) {

						 			methods.record( 
						 				Date.now(), 
						 				( index === 0 ) ? filename : undefined, 
						 				( index === 0 ) ? util.format('%d Out, %d Attempt(s)', successes, attempts ) : undefined, 
						 				"OK" 
						 			);

						 			methods.write( quotient.schema, quotient.content, quotient.names, quotient.value );

						 		} else {

						 			methods.record( Date.now(), filename, "An irrecoverable object was skipped during parsing.", "Skipped" );

						 		}

						 	});

					 	} else {

					 		methods.record( Date.now(), filename, quotients.message, "Parse" );

					 	}

					});

					done( result );

				}

			}

		};

	};
};