{
  "content" : {
    "0041d2fb-bb87-4bc8-b9c8-85d54d47f418" : {
      "code" : [ "        \"\"\"Sorts polygons into Bins.", "            :param sort_type: how to sort polygons:", "            :               'width' or 'w'  sort based on width", "            :               'height' or 'h' sort based on height", "            :               'area' or 'a'   sort based on area", "            :               'ratio' or 'r'  sort based on aspect ratio", "            :type sort_type: string   ", "        \"\"\"", "", "        # first, rotate into minimum bounds", "        shapes = [s.rotated_to_min_bounds() for s in shapes_in]", "", "        # create value field", "        for i,s in enumerate(shapes):", "", "            # now perform sort", "            if sort_type == 'w' : s.val = s.bounds.dim_x", "            if sort_type == 'h' : s.val = s.bounds.dim_y", "            if sort_type == 'a' : s.val = s.bounds.dim_x * s.bounds.dim_y", "            if sort_type == 'r' :", "                if s.bounds.dim_y != 0 : s.val = s.bounds.dim_x / s.bounds.dim_y", "                else: s.val = 0", "", "        # sort list", "        shapes.sort(key=lambda s: (s.val), reverse=reverse_list)", "", "        return shapes", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "Sorts polygons into Bins." ],
        "parameters" : {
          "sort_type" : "how to sort polygons"
        },
        "types" : {
          "sort_type" : "string   "
        }
      },
      "end" : 254,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "sort_polygons",
      "start" : 227
    },
    "01a7dd08-7efb-4205-8e75-1e2ce4429d1f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# method to sort edged based on length", "def sort_edges(edges, rev = False):", "    # create a range with the number of edges", "    result = range(len(edges))", "    # sort the range by the length of the edges", "    result.sort(key=lambda s: edges[s].length, reverse=rev)", "    # return the shortest edge", "    return result[0]", "    " ],
          "end" : 28,
          "start" : 18
        },
        "description" : "\nSubdivision with Length Rules\nSubdivide a panel with rules concerning edge length\n",
        "end" : 18,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "", "# create an empty panel list", "panels = []", "# set a starting value", "group = [True,True,True]", "# start with the selected side", "side_num = edg_num", "", "# while there are edges remaining:", "while group[2] == True:", "    # with a PGon, width and edge number, cut the panel", "    group = panel_cut(p_gon, mat_width, side_num) ", "    # if panel_cut returns a new panel:", "    if group[0] != False:", "        # append the new panel to the list", "        panels.append(group[0])", "        # define the p_gon as the remaining part of the PGon", "        p_gon = group[1]", "        # choose the next edge", "        side_num -= 1", "  " ],
          "end" : 53,
          "start" : 32
        },
        "description" : "\nHerringbone Subdivision\nSubdivide a panel with a Herringbone pattern.\n",
        "end" : 32,
        "start" : 29
      }, {
        "code" : {
          "content" : [ "", "# create an empty panel list", "panels = []", "# set a starting value", "group = [True,p_gon,True]", "", "# while there are edges remaining:", "while group[2] == True:", "    # get the shortest edge", "    ei = sort_edges(p_gon.edges, rev = long)", "    # with a PGon, width and edge, cut the panel", "    group = panel_cut(p_gon, mat_width, ei)", "    # define the p_gon as the remaining part of the PGon", "    p_gon = group[1]", "    # if there is no PGon left: break", "    if not p_gon : break", "    # append the new panel to the list", "    panels.append(group[0])", "" ],
          "end" : 75,
          "start" : 56
        },
        "description" : "\nSimple Subdivision\n",
        "end" : 56,
        "start" : 54
      }, {
        "code" : {
          "content" : [ "", "# create an empty panel list", "panels = []", "# set a starting value", "group = [True,p_gon,True]", "cnt = edg_num", "# set the counter to 0", "cnti = 0", "", "# while there are edges remaining:", "while group[2] == True:", "    # with a PGon, width and edge number, cut the panel", "    group = panel_cut(p_gon, mat_width, cnt) ", "    # if panel_cut returns a new panel:", "    if group[0] != False:", "        # append the new panel to the list", "        panels.append(group[0])", "        # define the p_gon as the remaining part of the PGon", "        p_gon = group[1]", "        # if there is no PGon left: break", "        if not p_gon : break", "        # if the side is even: rotate the PGon clockwise", "        if cnti % 2 == 0 : p_gon.rotate(-1)", "        # if the side is odd: rotate the PGon counter clockwise", "        if cnti % 2 == 1 : p_gon.rotate(1)", "        # add a number to the counter", "        cnti += 1", "", "        " ],
          "end" : 108,
          "start" : 79
        },
        "description" : "\nSingle Spiral Subdivision\nSubdivide a panel with single spiral rules\n",
        "end" : 79,
        "start" : 76
      }, {
        "code" : {
          "content" : [ "            ", "# create an empty panel list", "panels = []", "# set a starting value", "group = [True,p_gon,True]", "cnt = edg_num", "# set the counter to 1", "cnti = 1", "", "# while there are edges remaining:", "while group[2] == True:", "    # with a PGon, width and edge number, cut the panel", "    group = panel_cut(p_gon, mat_width, cnt) ", "    # if panel_cut returns a new panel:", "    if group[0] != False:", "        # append the new panel to the list", "        panels.append(group[0])", "        # define the p_gon as the remaining part of the PGon", "        p_gon = group[1]", "        # if there is no PGon left: break", "        if not p_gon : break", "        # subtract a number to the edge counter", "        cnt -= 1", "        # add a number to the counter", "        cnti += 1", "        # if the counter is even: add a number to the edge count", "        if cnti % 2 == 0 : cnt += 1", "" ],
          "end" : 140,
          "start" : 112
        },
        "description" : "\nDouble Spiral Subdivision\nSubdivide a panel with double spiral rules\n",
        "end" : 112,
        "start" : 109
      }, {
        "code" : {
          "content" : [ "", "# create an empty panel list", "panels = []", "# set a starting value", "group = [True,p_gon,True]", "cnt = edg_num", "", "# while there are edges remaining:", "while group[2] == True:", "    # with a PGon, width and edge number, cut the panel", "    group = panel_cut(p_gon, mat_width, cnt) ", "    # if panel_cut returns a new panel:", "    if group[0] != False:", "        # append the new panel to the list", "        panels.append(group[0])", "        # define the p_gon as the remaining part of the PGon", "        p_gon = group[1]", "        # if there is no PGon left: break", "        if not p_gon : break", "        # if the edge number counter is even: rotate the PGon", "        if cnt %2 == 0 : p_gon.rotate(1)", "        # add a number to the edge counter", "        cnt += 1", "", "" ],
          "end" : 168,
          "start" : 144
        },
        "description" : "\nWeave Subdivision\nSubdivide a panel with weave rules\n",
        "end" : 144,
        "start" : 141
      } ],
      "documentation" : {
        "description" : [ "4.03.F02c", "Given a subdivision method, a material width, and an initial edge, subdivide a panel based on Herringbone, weave, spiral, and length based rules." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Dennis Shelden/4.03.F02c.py",
      "name" : "4.03.F02c.py",
      "required" : [ "p_gon (PGon) Panel to subdivide.", "mat_width (float) Material width.", "edg_num (int) Initial edge of the PGon.", "panel_cut (func) Function to subdivide panels." ],
      "result" : [ "ret [PGons] Sub panels." ]
    },
    "03afcdb9-82ab-40b4-871f-58bab72680a7" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_tri.py",
      "definitions" : [ {
        "code" : [ "        self.pa = pt_a", "        self.pb = pt_b", "        self.pc = pt_c", "        if Vec(self.pa, self.pb).is_parallel(Vec(self.pa, self.pc)):", "            raise GeometricError(\"points are colinear\")" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 11,
        "name" : "__init__",
        "start" : 7
      }, {
        "code" : [ "    def edges(self): return [self.edge(0),self.edge(1),self.edge(2)]", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 15,
        "name" : "edges",
        "start" : 14
      }, {
        "code" : [ "    def pts(self): return [self.pa,self.pb,self.pc]", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 18,
        "name" : "pts",
        "start" : 17
      }, {
        "code" : [ "    def centroid(self): return Point.centroid(self.pts)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 21,
        "name" : "centroid",
        "start" : 20
      }, {
        "code" : [ "    def plane(self): ", "        vec = self.edges[0].vec.cross(Vec(self.pa,self.pc))", "        return Plane(self.centroid,vec)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 26,
        "name" : "plane",
        "start" : 23
      }, {
        "code" : [ "    def perimeter(self): return sum([e.length for e in self.edges])", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 29,
        "name" : "perimeter",
        "start" : 28
      }, {
        "code" : [ "    def area(self):", "        #http://www.mathopenref.com/heronsformula.html", "        p = self.perimeter/2.0", "        a = self.edge(0).length", "        b = self.edge(1).length", "        c = self.edge(2).length", "        return (p*(p-a)*(p-b)*(p-c))**0.5", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 38,
        "name" : "area",
        "start" : 31
      }, {
        "code" : [ "    def circumcenter(self):", "        #http://www.mathopenref.com/trianglecircumcenter.html", "        from .dc_intersection import *", "        xsec = Intersector()", "        bsec_ab = self.edge_bisector(0)", "        bsec_bc = self.edge_bisector(1)", "        if xsec.of(bsec_ab,bsec_bc):", "            return xsec[0]", "        return False", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 50,
        "name" : "circumcenter",
        "start" : 41
      }, {
        "code" : [ "    def circumcircle(self):", "        #http://www.mathopenref.com/trianglecircumcircle.html", "        pt = self.circumcenter", "        vec = self.edges[0].vec.cross(Vec(self.pa,self.pc))", "        pln = Plane(pt,vec)", "        return Circle(pln,pt.distance(self.pa))", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 58,
        "name" : "circumcircle",
        "start" : 52
      }, {
        "code" : [ "    def incenter(self):", "        #http://www.mathopenref.com/triangleincenter.html", "        from .dc_intersection import *", "        xsec = Intersector()", "        bsec_ab = self.angle_bisector(0)", "        bsec_bc = self.angle_bisector(1)", "        if xsec.of(bsec_ab,bsec_bc):", "            return xsec[0]", "        return False", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 69,
        "name" : "incenter",
        "start" : 60
      }, {
        "code" : [ "    def incircle(self):", "        #http://www.mathopenref.com/triangleincircle.html", "        pt = self.incenter", "        vec = self.edges[0].vec.cross(Vec(self.pa,self.pc))", "        pln = Plane(pt,vec)", "        rad = 2.0*self.area/self.perimeter", "        return Circle(pln,rad)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 78,
        "name" : "incircle",
        "start" : 71
      }, {
        "code" : [ "        self.pa, self.pb, self.pc = self.pb, self.pc, self.pa", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 81,
        "name" : "rotate",
        "start" : 80
      }, {
        "code" : [ "        if keep_a: self.pb, self.pc = self.pc, self.pb", "        elif keep_b: self.pa, self.pc = self.pc, self.pa" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 84,
        "name" : "flip",
        "start" : 83
      }, {
        "code" : [ "        if index == 0 : return Segment(self.pa,self.pb)", "        elif index == 1 : return Segment(self.pb,self.pc)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 89,
        "name" : "edge",
        "start" : 88
      }, {
        "code" : [ "        #http://www.mathopenref.com/altitude.html", "        edge = self.edges[base_index]", "        if base_index == 0 : pt = self.pc", "        elif base_index == 1 : pt = self.pa", "        elif base_index == 2 : pt = self.pb", "        else: return False", "        ", "        npt,t,dist = Line(edge.spt,edge.ept).near(pt) #returns a near point, its t-val, and the dist", "        return dist, Segment(npt,pt)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 103,
        "name" : "altitude",
        "start" : 94
      }, {
        "code" : [ "        edge = self.edge(index)", "        pt = edge.midpoint", "        vec = edge.vec.cross(self.plane.normal)", "        return Line(pt,vec.inverted())", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 109,
        "name" : "edge_bisector",
        "start" : 105
      }, {
        "code" : [ "        if index == 0 : ", "            va,vb = Vec(self.pa,self.pb),Vec(self.pa,self.pc)", "        elif index == 1 : ", "            va,vb = Vec(self.pb,self.pc),Vec(self.pb,self.pa)", "        elif index == 2 : ", "            va,vb = Vec(self.pc,self.pa),Vec(self.pc,self.pb)", "        else: return False", "        ", "        vec = Vec.bisector(va,vb)", "        return Line(self.pts[index],vec)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 121,
        "name" : "angle_bisector",
        "start" : 111
      }, {
        "code" : [ "        pts = [e.near_pt(pt) for e in self.edges]", "        return Tri(pts[0],pts[1],pts[2])", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 125,
        "name" : "pedal_tri",
        "start" : 123
      }, {
        "code" : [ "        from .dc_pgon import PGon", "        return PGon(self.pts)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 129,
        "name" : "to_pgon",
        "start" : 127
      }, {
        "code" : [ "        from .dc_mesh import Mesh", "        msh = Mesh(self.pts)", "        msh.add_face(0,1,2)", "        return msh", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 135,
        "name" : "to_msh",
        "start" : 131
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 135,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_tri.py",
      "name" : "Tri",
      "references" : {
        "classes" : {
          "Circle" : 2,
          "Geometry" : 1,
          "Intersector" : 2,
          "Line" : 3,
          "Mesh" : 1,
          "PGon" : 1,
          "Plane" : 3,
          "Point" : 1,
          "Segment" : 4,
          "Tri" : 2,
          "Vec" : 12
        },
        "functions" : {
          "__init__" : 1,
          "altitude" : 1,
          "angle_bisector" : 1,
          "area" : 1,
          "centroid" : 1,
          "circumcenter" : 1,
          "circumcircle" : 1,
          "edge" : 1,
          "edge_bisector" : 1,
          "edges" : 1,
          "flip" : 1,
          "incenter" : 1,
          "incircle" : 1,
          "pedal_tri" : 1,
          "perimeter" : 1,
          "plane" : 1,
          "pts" : 1,
          "rotate" : 1,
          "to_msh" : 1,
          "to_pgon" : 1
        }
      },
      "start" : 5
    },
    "03b63141-6eb1-4578-84c5-f7f35b080695" : {
      "blocks" : [ {
        "code" : {
          "end" : 17,
          "start" : 17
        },
        "description" : "\nSource:\nhttp://forrst.com/posts/Dijkstras_algorithm_in_Python-B4U\n[noprint]\n",
        "end" : 17,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "def dijkstra(graph, initial_node):", "    # set the current visited nodes and the distance travelled", "    visited = {initial_node: 0}", "    # set the current node as the initial node", "    current_node = initial_node", "    # create an empty dictionary for the path", "    path = {}", "    ", "    # create a set of all the nodes in the graph", "    nodes = set(graph.nodes)", "    # while there are still nodes in the set", "    while nodes:", "        # calculate the minimum node", "        min_node = None", "        for node in nodes:", "            if node in visited:", "                # initialize min_node ", "                if min_node is None: min_node = node", "                # if this node is less than current min_node", "                elif visited[node] < visited[min_node]: min_node = node", "                ", "        if min_node is None: break", "        # remove the current node from nodes", "        nodes.remove(min_node)", "        # get the distance to the current node", "        cur_wt = visited[min_node]", "        # for every edge connected to the current node:", "        for edge in graph.edges[min_node]:", "            # record this edge to visited and path dicts", "            wt = cur_wt + graph.distances[(min_node, edge)]", "            if edge not in visited or wt < visited[edge]:", "                visited[edge] = wt", "                path[edge] = min_node", "    ", "    return visited, path", "" ],
          "end" : 57,
          "start" : 21
        },
        "description" : "\nDijkstra Shortest Path\nA method that solves for the shortest possible path between nodes in a graph\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "def shortest_path(graph, initial_node, goal_node):", "    # set distances and paths to the result of dijkstra", "    distances, paths = dijkstra(graph, initial_node)", "    ", "    # initialize the route to contain only the goal node", "    route = [goal_node]", "    # walk backwards along path until we reach the inital node", "    while goal_node != initial_node:", "        # add the current goal node to the route", "        route.append(paths[goal_node])", "        goal_node = paths[goal_node]", "    ", "    # reverse the route list to start from the initial node", "    route.reverse()", "    return route", "" ],
          "end" : 76,
          "start" : 61
        },
        "description" : "\nDijkstra Wrapper Function\nGiven a graph, an initial node and an end node, this function returns the shortest path between them\n",
        "end" : 61,
        "start" : 58
      } ],
      "documentation" : {
        "description" : [ "4.03.F03a", "Two functions that allow for the calculation of the shortest path between two nodes of a graph" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Martin Zahner/4.03.F03a.py",
      "name" : "4.03.F03a.py",
      "required" : [ "A graph (Graph)" ],
      "result" : [ "dijkstra (func) A function to store the shortest distances between graph connections", "shortest_path (func) A function that calculates the shortest path between two nodes using the dijkstra function" ]
    },
    "0497db93-8bc3-4430-88ac-c23eff7e550f" : {
      "code" : [ "    xform = Xform.translation(Point(3,1)) ", "    xform *= Xform.rotation(center=Point(),angle=math.pi/3, axis=Vec(0,1,1))", "    tc = DzTileC(xf=xform,rlvl=0)", "    out_0.put(tc.draw())", "", "    inflt1 = tc.inflate()", "    for tile in inflt1 : ", "        out_1.put(tile.draw())", "        inflt2 = tile.inflate()", "        for tile in inflt2 : out_2.put(tile.draw())", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 366,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "inflationC",
      "start" : 356
    },
    "04d11804-0821-48cf-8186-8b39ed435aea" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# initialize and Intersector", "xsec = Intersector()", "graph_pts = []", "# for each segment in curves:", "for n in range(len(curves)): ", "    # turn the given Segments into Lines", "    curves[n] = Line(curves[n].spt,curves[n].vec)", "    # initialize an empty list to store intersections", "    curves[n].xsecs = []", "", "# for each segment in curves:", "for cind, crv in enumerate (curves) :", "    # store the start point of this segment", "    graph_pts.append(crv.spt)", "    # store the start point as if it were an intersection", "    crv.xsecs.append( [0 , len(graph_pts)-1] )", "    ", "    # store the end point of this segment", "    graph_pts.append(crv.ept)", "    # store the end point as if it were an intersection", "    crv.xsecs.append( [1 , len(graph_pts)-1] )", "    ", "    # for every other segment in curves:", "    for oi, other in enumerate(curves[cind+1:]):", "        # if there is an intersection:", "        if xsec.of(crv,other):", "            # if the intersection is within the interval of the crv:", "            if 0 < xsec.ta < 1 and 0 < xsec.tb < 1 :", "                # get the index of the nearest Point", "                nearest_index = Point.near_index(xsec[0],graph_pts)", "                # determine if this intersection has already been stored", "                dist = xsec[0].distance2( graph_pts[nearest_index] )", "                # if so:", "                if dist < 0.0000001 :", "                    # record as an intersection for this segment", "                    crv.xsecs.append( [xsec.ta , nearest_index] )", "                # if not:", "                else:", "                    # store this intersection point", "                    graph_pts.append(xsec[0])", "                    # record as an intersection for this and the other segment", "                    crv.xsecs.append( [xsec.ta , len(graph_pts)-1] )", "                    other.xsecs.append( [xsec.tb , len(graph_pts)-1] )", "", "                    " ],
          "end" : 61,
          "start" : 16
        },
        "description" : "\nMass Intersection\nFind the intersection between each of a collection of Segments, stores the resulting points, and records intersection information within the Segments themselves.\n[pseudo]\n",
        "end" : 16,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "", "all_lns = []", "for crv in curves :", "    # get the crv intersections", "    ints = crv.xsecs", "    ints.sort(key=lambda x:x[0])", "    # get the first intersection ", "    i0 = ints[0][1]", "    # start a counter", "    n=1", "    # while counter is smaller than the number of ints:", "    while n < len(ints):", "        # set a second intersection", "        i1 = ints[n][1]", "        # if the intersections are different:", "        if i0 != i1 : ", "            # create a Segment with the Points and intersection index", "            lns = Segment(graph_pts[i0],graph_pts[i1] )", "            all_lns.append(lns)", "            # set the current index to the starting Point index", "            i0 = i1", "        # increase the counter", "        n=n+1", "        ", "" ],
          "end" : 89,
          "start" : 65
        },
        "description" : "\nRebuild Intersected Segments\nCreates new Segments using the intersection Points and connectivity information created above \n",
        "end" : 65,
        "start" : 62
      } ],
      "documentation" : {
        "description" : [ "4.07.F02d", "Given a number of random Curves, split the curves at their intersections." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Williams Biot-Savart/4.07.F02d.py",
      "name" : "4.07.F02d.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "Line" : 1,
          "Point" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "curves ([Segment]) Curves to be split." ],
      "result" : [ "all_lns ([Segment]) Split Segmants." ]
    },
    "057b6a73-d5d4-4cce-a1f3-bb7d40650e81" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class CA (object):", "", "    def __init__(self,pixel_res=Interval(20,20),corners=False,wrap=False):", "        self.width = int(pixel_res.a) # sets the x-dimension of this CA", "        self.height = int(pixel_res.b) # sets the y-dimension of this CA", "        # initializes the boolean field, step count, and history", "        self.clear(corners,wrap)", "", "    \"\"\"", "    Setting Cell Values", "    Methods for setting cells in the boolean field individually (at a given set of x,y coordinates) or all at once.", "    \"\"\" ", "    def set_cell(self,x,y,val):", "        #ensures that cells fall within legal bounds of CA", "        x,y = self._reframe(x,y) ", "        self.cells.set(x,y,val)", "     ", "    def set_cells(self, vals):", "        for n, val in enumerate(vals): self.cells._pixels[n] = val", "", "    \"\"\"", "    [noprint]", "    \"\"\"", "    # returns the value of the u pixel at coordinates x,y        ", "    def get_cell(self,x,y): ", "        return self.cells.get(x,y)", "", "    def get_cells(self) : ", "        # return all the pixels in the model", "        return self.cells ", "", "    def _reframe(self,x,y):", "        while x > self.width -1 : x = x - self.width", "        while y > self.height -1: y = y - self.height", "        while x < 0 : x = self.width + x", "        while y < 0 : y = self.height + y", "        return x,y", "        ", "    \"\"\"", "    Set CA Rule", "    Sets the rule for the CA object to a given function. Assumes that function takes two arguments - the status of a given home cell and a list of the statuses of the neighbors - and returns the new value to assign to the home cell.", "    \"\"\"", "    def set_rule(self,func):", "        self.rule = func        ", "", "    \"\"\"", "    Clear Method", "    Initializes the boolean field contained within this CA that represents cell values, and clears the history", "    \"\"\"", "    def clear(self,corners = False,wrap = False):", "        self.cells = BoolField(Interval(self.width,self.height),wrap,corners)", "        self.step_count = 0 # reset the step counter", "        self.hist = []  # reset the history to an empty list", "        ", "    \"\"\"", "    Record and Step Methods", "    Record saves the current state of the model to the hist array, and Step creates a new generation of cells by applying the rule funciton of this CA", "    \"\"\"", "    def record(self):", "        self.hist.append(self.cells)", "", "    def step(self):", "        # create a new boolean field for next generation", "        ival = Interval(self.width,self.height)", "        nxt_cells = BoolField(ival,self.cells.wrap,self.cells.include_corners)", "        ", "        for x in range(0,self.width):", "            for y in range(0,self.height):", "                # get the value of the 'home' cell", "                cur_cell = self.cells.get(x,y) ", "                # get a list of thi cell's neighbors", "                neighbor_cells = self.cells.neighbors_of(x,y) ", "                # call the CA's rule function", "                nxt_cell = self.rule(cur_cell, neighbor_cells) ", "                # set the new cell's value to the result", "                nxt_cells.set(x,y,nxt_cell) ", "                ", "        # set the current boolean field to the new boolean field", "        self.cells = nxt_cells", "        self.step_count += 1 # Increment the step count", "", "    \"\"\"", "    Points Method", "    Creates two sets of points representing the state of the model at a given time", "    [noprint]", "    \"\"\"", "    def to_pts(self, g=0):               ", "        # make sure not to select beyond the length the history", "        select = g % len(self.hist)", "        ", "        # initialize point lists for true cells and false cells", "        pts_true, pts_false = [],[]", "        ", "        # for each x-location in the boolean field:", "        for x in range(0,self.width):", "            # for each y-location in the boolean field:", "            for y in range(self.height):", "                # if the pixel value at x,y is true:", "                if self.hist[select].get(x,y): ", "                    # add it to the list of true points", "                    pts_true.append(Point(x,y)) ", "                else: ", "                    # else add it to the list of false points", "                    pts_false.append(Point(x,y)) ", "    ", "        return pts_true, pts_false # return both lists of points", "", "", "", "        ", "" ],
          "end" : 136,
          "start" : 25
        },
        "description" : "\nCellular Automata Class\nDefine a two-state cellular automata that records its history and provides methods for reading, writing, and clearing values\n",
        "end" : 25,
        "start" : 22
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Cellular Automata/4.02.L02a.py",
      "name" : "4.02.L02a.py",
      "references" : {
        "classes" : {
          "BoolField" : 2,
          "CA" : 1,
          "Interval" : 3,
          "Point" : 2
        }
      }
    },
    "05e8fbaf-0823-4f7c-bdce-9e0b7769647f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# sets up an L System Generator and a set of rules", "leng = LEngine(\"X\")# axiom 'X'", "leng.add_rule(['X', 'F-[[X]^XB]+F[&FXA]-X>'])# rule as a tuple", "leng.add_rule(\"F -> F&FC<<\")# rule as a string", "leng.add_rule(\"A -> FX\")", "leng.add_rule(\"B -> CA\")", "leng.add_rule(\"C -> X\")", "for n in range(3): leng.step()# generations to compute", "", "# sets up an L system Interpreter", "turt = LTurtle(leng.cur_gen)", "geom = turt.go()# tells the turtle to move", "" ],
          "end" : 31,
          "start" : 18
        },
        "description" : "\nLSystem Routine\nTakes an axiom and a set of rules and creates an LEngine and LTurtle to apply the rules, then interprets the resulting instruction string and moves a turtle\n",
        "end" : 18,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "4.02.L06c", "Given a string to transform (axiom) and a set of production rules, set up and run an L system generator and a turtle interpreter" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/LSystem/4.02.L06c.py",
      "name" : "4.02.L06c.py",
      "references" : {
        "classes" : {
          "LEngine" : 1,
          "LTurtle" : 1
        }
      },
      "required" : [ "axiom (string) An initializing string to transform.", "rules ([[str,str]]) or ([str]) A set of production rules specifying how the string is to be transformed.", "LEngine (class) An LEngine class to apply the production rules to transform the axiom.", "LTurtle (class) An LTurtle class to interpret the resulting instruction string and move a turtle." ],
      "result" : [ "lines ([Segment]) A list of branching line segments created by the axiom, production rules, and number of generations." ]
    },
    "067b7da5-b53c-4757-bc19-5ca00fdc3867" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def leastSquaresArc(pts_in):", "    cnt = len(pts_in)", "    # if there is less than two points given", "    if len(pts_in) < 2 :", "        # raise an error", "        raise GeometricError(\"Please provide more points\") ", "    # set all variables to 0", "    x, y, x, xsq, ysq, xy, xysq, xsqy, xcube, ycube = [0]*10", "    # for every Point in pts_in:", "    for pt in pts_in :", "        x += pt.x ", "        y += pt.y", "        xsq += pt.x**2", "        ysq += pt.y**2", "        xy += pt.x*pt.y", "        xysq += pt.x*pt.y**2", "        xsqy += pt.x**2*pt.y", "        xcube += pt.x**3", "        ycube += pt.y**3", "    A = cnt*xsq - x**2", "    B = cnt*xy - x*y", "    C = cnt*ysq - y**2", "    D = 0.5*(cnt*xysq - x*ysq + cnt*xcube - x*xsq)", "    E = 0.5*(cnt*xsqy - y*xsq + cnt*ycube - y*ysq)", "    # set the denominator", "    denom = A*C - B*B", "    # if the denominator is not 0:", "    if (denom != 0):", "        # find the center Point of all points in pts_in", "        center = Point((D*C - B*E)/denom, (A*E - B*D)/denom)", "    # else if the dominator is 0:", "    else: ", "        # raise an error", "        raise GeometricError(\"A*C == B*B ... I Cannot find center of this Arc\") ", "    # set the radius of the arc ", "    rad = sum([pt.distance(center) for pt in pts_in])/cnt", "    ", "    segs = [] # a list to store segments", "    # for each point in the list:", "    for pt in pts_in:", "        #create a Segment from the center to that Point", "        segs.append(Segment(center, pt))", "    # make the first Vec a reference for the rest", "    ref_vec = segs[0].vec", "    # for each Segment in the list of segments:", "    for seg in segs:", "        # get the angle with the reference Segment", "        seg.angle = ref_vec.angle(seg.vec)", "        # if the cross product of the two Vecs is negative:", "        if ref_vec.cross(seg.vec).z < 0:", "            # store it as a positive angle", "            seg.angle = - seg.angle", "    # sort all Segments by the calculated angles", "    segs = sorted(segs, key=lambda seg: seg.angle)", "    # set the sweep angle ", "    sweep = segs[-1].angle - segs[0].angle", "    # set the CS of the Arc", "    cs = CS(center,segs[0].vec,segs[1].vec)", "    return Arc(cs,rad,sweep)", "" ],
          "end" : 75,
          "start" : 16
        },
        "description" : "\nBest Fit by Modified Least Squares\nReturns a best fit Arc using the modified least squares method.\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L06c", "Method that returns a best fit Arc using the modified least squares method." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Best Fit/4.07.L06c.py",
      "name" : "4.07.L06c.py",
      "references" : {
        "classes" : {
          "A" : 3,
          "Arc" : 1,
          "B" : 5,
          "C" : 3,
          "CS" : 1,
          "D" : 3,
          "E" : 3,
          "Point" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "pts_in ([Point]) A list of Points." ],
      "result" : [ "(Arc) An arc" ]
    },
    "08820db3-070f-4a3e-b21b-55602763bb28" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pts = [Point(0,0),Point(1,0),Point(0,1)]", "str = \"dancing about\"", "", "" ],
          "end" : 18,
          "start" : 14
        },
        "description" : "\n",
        "end" : 14,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "stuff = [Point(),Vec(0,0,1),\"applesauce\"]", "", "" ],
          "end" : 23,
          "start" : 20
        },
        "description" : "\n",
        "end" : 20,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "print 'this collection is ', len(pts), ' items long'", "print 'this collection is ', len(str), ' items long'", "" ],
          "end" : 28,
          "start" : 25
        },
        "description" : "\n",
        "end" : 25,
        "start" : 24
      }, {
        "code" : {
          "content" : [ "msg = \"i've got 99 problems\"", "print msg[3]", "" ],
          "end" : 33,
          "start" : 30
        },
        "description" : "\n",
        "end" : 30,
        "start" : 29
      }, {
        "code" : {
          "content" : [ "print msg[-2]", "", "" ],
          "end" : 38,
          "start" : 35
        },
        "description" : "\n",
        "end" : 35,
        "start" : 34
      }, {
        "code" : {
          "content" : [ "print msg[5:8]", "", "" ],
          "end" : 43,
          "start" : 40
        },
        "description" : "\n",
        "end" : 40,
        "start" : 39
      }, {
        "code" : {
          "content" : [ "print msg[:8] + ' a ' + msg[12:-1]", "" ],
          "end" : 46,
          "start" : 45
        },
        "description" : "\n",
        "end" : 45,
        "start" : 44
      } ],
      "documentation" : {
        "description" : [ "2.03.E00a", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/03-Collections/2.03.E00 - NOGHX/2.03.E00a.py",
      "name" : "2.03.E00a.py",
      "references" : {
        "classes" : {
          "Point" : 4,
          "Vec" : 1
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "0c2aa30d-5b0b-4014-91e4-1a8214757391" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def node(edge,vconfig):", "    rgons = []", "    #create a set of regular polygons around each vertex node in order of vertex configuration", "    for n in vconfig:", "        rgons.append(RGon.from_edge(edge,n))", "        edge = rgons[-1].edges[0]", "    # create a list of half segments from these regular polygons", "    segs = [Segment(rgon.pts[0],Vec(rgon.pts[0],rgon.pts[1])/2.0) for rgon in rgons]", "    return segs", "" ],
          "end" : 27,
          "start" : 17
        },
        "description" : "\nNode Function\nDefines a lattice of half line segments emanating from a vertex node\n[noprint]\n",
        "end" : 17,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "# define a 'seed' segment that will be copied across the plane", "seed = Segment(Point(1,1),Vec(0,1))", "# define parameters specific to Truncated square tiling", "v_config = (4,8,8) ", "nodes_per_clst = 4", "# define the extent of the grid to tile", "clst_per_row = u_cnt", "sqrt2 = 2**0.5 # the width of an octogon is 1+sqrt(2)*side_length", "nodes = []", "", "# for each translation of the seed segment:", "for n in range(u_cnt*v_cnt*nodes_per_clst):", "    #if we're moving between two clusters in a row", "    if n>0 and n%nodes_per_clst==0:", "        # translate the seed segment between two clusters", "        seed._pt += Vec(1+sqrt2*seed.length+seed.length,0)", "    #if we're moving between rows", "    if n>0 and n%(nodes_per_clst*clst_per_row)==0:", "        # translate the seed segment up one row", "        dy = 1+sqrt2*seed.length+seed.length", "        if n%(nodes_per_clst*clst_per_row*2)==0 : dx = -dy*(clst_per_row+0.5)", "        else : dx = -dy*(clst_per_row-0.5)", "        seed *= Xform.translation(Vec(dx,dy/2.0))", "    # if we're moving within a single cluster", "    if n>0:", "        # translate the seed segment within a cluster", "        seed = Segment(seed.ept,seed._vec.cross(Vec(0,0,1)))", "    # record this node", "    nodes.append(node(seed,v_config))" ],
          "end" : 60,
          "start" : 32
        },
        "description" : "\nCreate Grid Routine\nCreates a grid of lattice units by translating the seed edge from vertex node to node\n[pseudo]\n",
        "end" : 32,
        "start" : 28
      } ],
      "documentation" : {
        "description" : [ "4.01.L01b", "Given a \"seed edge\", create a semi-regular, truncated square tiling by lattice." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Regular Tiling/4.01.L01b.py",
      "name" : "4.01.L01b.py",
      "references" : {
        "classes" : {
          "Point" : 1,
          "RGon" : 1,
          "Segment" : 3,
          "Vec" : 5,
          "Xform" : 1
        }
      },
      "required" : [ "u_cnt (Int) Number of clusters in U direction.", "v_cnt (Int) Number of clusters in V direction." ],
      "result" : [ "nodes ([[Segment]]) List of segments." ]
    },
    "0d036d4a-464c-49c9-ba4a-0ce8332b35eb" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_xform.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"XForm Constructor", "            ", "            :param matrix: Matrix", "            :type matrix: list", "            :result: XForm object.", "            :rtype: XForm", "        \"\"\"", "        if matrix is not None :", "            self._m = matrix" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "XForm Constructor" ],
          "parameters" : {
            "matrix" : "Matrix\n"
          },
          "rtype" : "XForm",
          "rvalue" : "XForm object.\n",
          "types" : {
            "matrix" : "list\n"
          }
        },
        "end" : 19,
        "name" : "__init__",
        "start" : 11
      }, {
        "code" : [ "        return ( \"xform\\t[{},{},{},{}]\".format(self.c11,self.c12,self.c13,self.c14) +", "        \"\\n\\t\\t[{},{},{},{}]\".format(self.c21,self.c22,self.c23,self.c24) +" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 29,
        "name" : "__repr__",
        "start" : 28
      }, {
        "code" : [ "        m = list(self._m)", "        xf = Xform(matrix = m)", "        xf.c14 = 0", "        xf.c24 = 0", "        xf.c34 = 0", "        return xf", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 40,
        "name" : "strip_translation",
        "start" : 34
      }, {
        "code" : [ "    def translation(vec):", "        \"\"\"Translates an object by a given Vector.", "", "            :param vec: Vector to apply a translation.", "            :type vec: Vec", "            :result: Translates an object.", "            :rtype: Geometry", "        \"\"\"", "        xf = Xform()", "        xf.c14 = vec.x", "        xf.c24 = vec.y", "        xf.c34 = vec.z", "        return xf", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Translates an object by a given Vector." ],
          "parameters" : {
            "vec" : "Vector to apply a translation.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "Translates an object.\n",
          "types" : {
            "vec" : "Vec\n"
          }
        },
        "end" : 55,
        "name" : "translation",
        "start" : 42
      }, {
        "code" : [ "    def scale(factor, origin=None):", "        \"\"\"Scales an object by a given factor.", "", "            :param factor: Factor to scale by.", "            :type factor: float", "            :result: Scaled object.", "            :rtype: Geometry", "        \"\"\"", "        if not origin:", "            xf = Xform()" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Scales an object by a given factor." ],
          "parameters" : {
            "factor" : "Factor to scale by.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "Scaled object.\n",
          "types" : {
            "factor" : "float\n"
          }
        },
        "end" : 66,
        "name" : "scale",
        "start" : 57
      }, {
        "code" : [ "    def mirror(plane=\"world_xy\"):", "        \"\"\"Produces mirror transform. Can pass in \"world_xy\", \"world_yz\", or \"world_xz\". Or, pass in an arbitrary cs (produces mirror about XYplane of CS).", "        ", "            :param plane: Plane to mirror the object with. Defaults to world XY plane.", "            :type plane: Plane", "            :result: Mirrored object.", "            :rtype: Geometry", "            ", "            .. warning:: When mirroring about an arbitrary plane, this method currently relies on access to the Rhinocommon Kernel.  It will not work in other contexts.", "            .. todo:: Re-implement this method without using the Rhinocommon Kernel.", "            ", "        \"\"\"", "        #TODO: Re-implement this method without using the Rhinocommon Kernel", "        ", "        xf = Xform()", "        ", "        if isinstance(plane, basestring):", "            if plane==\"world_xy\" : xf.c33 *= -1", "            elif plane==\"world_xz\" : xf.c22 *= -1", "            elif plane==\"world_yz\" : xf.c11 *= -1", "            else: ", "                raise NotImplementedError(\"Xform.mirror accepts only the following string values for 'plane':/n'world_xy','world_xz','world_yz'\")", "            return xf", "        ", "        nx,ny,nz = plane._vec.x, plane._vec.y, plane._vec.z", "        origin = plane.origin", "        xf_plane = Xform()", "        xf_plane.m00 = 1-2*nx*nx", "        xf_plane.m01 = -2*nx*ny", "        xf_plane.m02 = -2*nx*nz", "        xf_plane.m10 = -2*nx*ny", "        xf_plane.m11 = 1-2*ny*ny", "        xf_plane.m12 = -2*ny*nz", "        xf_plane.m20 = -2*nx*nz", "        xf_plane.m21 = -2*ny*nz", "        xf_plane.m22 = 1-2*nz*nz", "        xf_o = Xform.translation(Vec(origin))", "        xf_minuso = Xform.translation(-Vec(origin))", "        return xf_o*xf_plane*xf_minuso           ", "        ", "        \"\"\"", "            if isinstance(plane, CS) : ", "                #TODO: do this ourselves instead", "                import Rhino", "                from ..io.rhino_out import to_rgvec, to_rgpt", "                from ..io.rhino_in import from_rgtransform", "                rh_xform = Rhino.Geometry.Transform.Mirror(to_rgpt(plane.origin),to_rgvec(plane.zAxis))       ", "                return from_rgtransform(rh_xform)", "        ", "        raise NotImplementedError(\"Xform.mirror currently accepts the following values for 'plane':/n'world_xy','world_xz','world_yz'\")", "        \"\"\"", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Produces mirror transform. Can pass in \"world_xy\", \"world_yz\", or \"world_xz\". Or, pass in an arbitrary cs (produces mirror about XYplane of CS)." ],
          "parameters" : {
            "plane" : "Plane to mirror the object with. Defaults to world XY plane.\n"
          },
          "rtype" : "Geometry\n\n.. warning",
          "rvalue" : "Mirrored object.\n",
          "types" : {
            "plane" : "Plane\n"
          }
        },
        "end" : 134,
        "name" : "mirror",
        "start" : 83
      }, {
        "code" : [ "    def rotation(**kargs):", "        \"\"\" Rotates an object around by a center and a rotation angle OR by a center, an axis and a rotation angle. ", "            ", "            :param \\**kargs: Function that accepts multiple parameters to be passed. Parameters include center and axis of rotation and a rotation angle. ", "            :type \\**kargs: Point, Vec, float", "            :result: Rotated object.", "            :rtype: Geometry", "", "            .. warning:: This method currently relies on access to the Rhinocommon Kernel. It will not work in other contexts.            ", "            ", "        \"\"\"", "       # TODO:: Re-implement this method without using the Rhinocommon Kernel.", "", "       # TODO:: Rotation about an axis ought to take in a linear entity, not a vector.", "        ", "        try:", "            try:", "                axis = kargs[\"axis\"].normalized()", "            except:", "                axis = Vec(0,0,1)", "", "            if \"angle\" in kargs and not \"center\" in kargs :", "                xf = Xform()" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Rotates an object around by a center and a rotation angle OR by a center, an axis and a rotation angle." ],
          "parameters" : {
            "\\**kargs" : "Function that accepts multiple parameters to be passed. Parameters include center and axis of rotation and a rotation angle. \n"
          },
          "rtype" : "Geometry\n\n.. warning",
          "rvalue" : "Rotated object.\n",
          "types" : {
            "\\**kargs" : "Point, Vec, float\n"
          }
        },
        "end" : 158,
        "name" : "rotation",
        "start" : 136
      }, {
        "code" : [ "    def change_basis(cs_src,cs_tar):", "        \"\"\" Changes the plane basis of an object.            ", "            ", "            :param cs_src: CS source of the object.", "            :type cs_src: CS", "            :param cs_tar: CS plane of the object.", "            :type cs_tar: CS", "            :result: Transformation Matrix.", "            :rtype: Xform", "            ", "        \"\"\"", "        xg, yg, zg = Vec(1,0,0), Vec(0,1,0), Vec(0,0,1) # global coordinate basis vectors", "        xs, ys, zs = cs_src.x_axis, cs_src.y_axis, cs_src.z_axis", "        xt, yt, zt = cs_tar.x_axis, cs_tar.y_axis, cs_tar.z_axis", "        xf_gs = Xform(matrix=[xs.dot(xg),xs.dot(yg),xs.dot(zg),0,ys.dot(xg),ys.dot(yg),ys.dot(zg),0,zs.dot(xg),zs.dot(yg),zs.dot(zg),0,0,0,0,1])", "        xf_gs *= Xform.translation(-cs_src.origin) ", "        xf_st = Xform(matrix=[xg.dot(xt),xg.dot(yt),xg.dot(zt),0,yg.dot(xt),yg.dot(yt),yg.dot(zt),0,zg.dot(xt),zg.dot(yt),zg.dot(zt),0,0,0,0,1])", "        return Xform.translation(cs_tar.origin)* (xf_st * xf_gs )", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Changes the plane basis of an object." ],
          "parameters" : {
            "cs_src" : "CS source of the object.\n",
            "cs_tar" : "CS plane of the object.\n"
          },
          "rtype" : "Xform",
          "rvalue" : "Transformation Matrix.\n",
          "types" : {
            "cs_src" : "CS\n",
            "cs_tar" : "CS\n"
          }
        },
        "end" : 216,
        "name" : "change_basis",
        "start" : 198
      }, {
        "code" : [ "        \"\"\"| Multiplies this Geometry by another Matrix, or by any piece of geometry.", "           | This function must be kept up to date with every new class of DC geom.", "            ", "           :param other: Matrix to multiply or Geometry to transform.", "           :type other: object", "           :result: multiplied object", "           :rtype: object", "        \"\"\"", "        if isinstance(other, Xform) : ", "            xf = Xform()", "            xf._m = [", "                self.c11 * other.c11 + self.c12 * other.c21 + self.c13 * other.c31 + self.c14 * other.c41,", "                self.c11 * other.c12 + self.c12 * other.c22 + self.c13 * other.c32 + self.c14 * other.c42,", "                self.c11 * other.c13 + self.c12 * other.c23 + self.c13 * other.c33 + self.c14 * other.c43,", "                self.c11 * other.c14 + self.c12 * other.c24 + self.c13 * other.c34 + self.c14 * other.c44,", "                self.c21 * other.c11 + self.c22 * other.c21 + self.c23 * other.c31 + self.c24 * other.c41,", "                self.c21 * other.c12 + self.c22 * other.c22 + self.c23 * other.c32 + self.c24 * other.c42,", "                self.c21 * other.c13 + self.c22 * other.c23 + self.c23 * other.c33 + self.c24 * other.c43,", "                self.c21 * other.c14 + self.c22 * other.c24 + self.c23 * other.c34 + self.c24 * other.c44,", "                self.c31 * other.c11 + self.c32 * other.c21 + self.c33 * other.c31 + self.c34 * other.c41,", "                self.c31 * other.c12 + self.c32 * other.c22 + self.c33 * other.c32 + self.c34 * other.c42,", "                self.c31 * other.c13 + self.c32 * other.c23 + self.c33 * other.c33 + self.c34 * other.c43,", "                self.c31 * other.c14 + self.c32 * other.c24 + self.c33 * other.c34 + self.c34 * other.c44,", "                self.c41 * other.c11 + self.c42 * other.c21 + self.c43 * other.c31 + self.c44 * other.c41,", "                self.c41 * other.c12 + self.c42 * other.c22 + self.c43 * other.c32 + self.c44 * other.c42,", "                self.c41 * other.c13 + self.c42 * other.c23 + self.c43 * other.c33 + self.c44 * other.c43,", "                self.c41 * other.c14 + self.c42 * other.c24 + self.c43 * other.c34 + self.c44 * other.c44,", "            ]", "            return xf", "        ", "        return self.transform(other)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Multiplies this Geometry by another Matrix, or by any piece of geometry.", "| This function must be kept up to date with every new class of DC geom." ],
          "parameters" : {
            "other" : "Matrix to multiply or Geometry to transform.\n"
          },
          "rtype" : "object",
          "rvalue" : "multiplied object\n",
          "types" : {
            "other" : "object\n"
          }
        },
        "end" : 249,
        "name" : "__mul__",
        "start" : 218
      }, {
        "code" : [ "        \"\"\"| Multiplies any appropriate piece of geometry by this XForm", "           | This function must be kept up to date with every new class of DC geom.", "            ", "           :param other: geometry to transform.", "           :type other: Geometry", "           :result: multiplied object", "           :rtype: Geometry", "        \"\"\"", "        # HASPTS GEOMETRY", "        # applies transformation to the verts, leaving the basis intact", "        if isinstance(other, HasPts) : ", "            #raise NotImplementedError(\"can't xform a haspts\")", "            other._verts = [v*self for v in other._verts]", "            return other", "            # TODO: deal with applying transformations to haspts geometry", "            ", "", "        # BASED GEOMETRY", "        # all objects that are not HASPTS but are HASBASIS and have a basis defined and are capable of applying their basis... must do so before transforming points", "        # this condition only applies to Based Points at the moment, may apply to Tetrahedron class", "        # TODO: move this functionality down to Based Points", "        if isinstance(other, HasBasis) and (not other.is_baseless): ", "            try:", "                o = other.basis_applied()", "                o.copy_props(other)", "                other = o", "            except:", "                pass", "        ", "        if isinstance(other, LinearEntity) : ", "            pt = other._pt*self", "            xf = self.strip_translation()", "            vec = other._vec*xf", "            if isinstance(other, Line) : return Line(pt,vec)", "            if isinstance(other, Ray) : return Ray(pt,vec)", "            if isinstance(other, Segment) : return Segment(pt,vec)", "            ", "        if isinstance(other, CS) : ", "            cs = other", "            tup = self._xform_tuple(cs.origin.to_tuple())", "            origin = Point(tup[0],tup[1],tup[2])", "            ", "            xf = self.strip_translation()", "            tup = xf._xform_tuple(cs.x_axis.to_tuple())", "            x_axis = Vec(tup[0],tup[1],tup[2])", "            tup = xf._xform_tuple(cs.y_axis.to_tuple())", "            y_axis = Vec(tup[0],tup[1],tup[2])", "            ", "            ", "            ret = CS(origin, x_axis, y_axis)", "            ret.copy_props(other)", "            return ret", "        ", "        if isinstance(other, Arc) : ", "        ", "            cs = other._basis", "            tup = self._xform_tuple(cs.origin.to_tuple())", "            origin = Point(tup[0],tup[1],tup[2])", "            xf = self.strip_translation()", "            tup = xf._xform_tuple(cs.x_axis.to_tuple())", "            x_axis = Vec(tup[0],tup[1],tup[2])", "            tup = xf._xform_tuple(cs.y_axis.to_tuple())", "            y_axis = Vec(tup[0],tup[1],tup[2])", "            ", "            ", "            ret = Arc(CS(origin, x_axis, y_axis),other.rad,other.angle)", "            ret.copy_props(other)", "            return ret", "        ", "        if isinstance(other, Point) : ", "            tup = self._xform_tuple(other.to_tuple())", "            pt = Point(tup[0],tup[1],tup[2])", "            pt.copy_props(other)", "            return pt", "        ", "        if isinstance(other, Vec) : ", "            tup = self._xform_tuple(other.to_tuple())", "            vec = Vec(tup[0],tup[1],tup[2])", "            vec.copy_props(other)", "            return vec", "        ", "        if isinstance(other, Circle) :", "            pln = other.plane * self", "            cir = Circle(pln,other.rad)", "            cir.copy_props(other)", "            return cir ", "        ", "        if isinstance(other, Plane) : ", "            pln = other", "            tup = self._xform_tuple(pln.origin.to_tuple())", "            origin = Point(tup[0],tup[1],tup[2])", "            ", "            xf = self.strip_translation()", "            tup = xf._xform_tuple(pln.normal.to_tuple())", "            normal = Vec(tup[0],tup[1],tup[2]).normalized()", "            ", "            pln = Plane(origin, normal)", "            pln.copy_props(other)", "            return pln", "", "        ", "        raise NotImplementedError(\"can't xform an object of type {}\".format(type(other)))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Multiplies any appropriate piece of geometry by this XForm", "| This function must be kept up to date with every new class of DC geom." ],
          "parameters" : {
            "other" : "geometry to transform.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "multiplied object\n",
          "types" : {
            "other" : "Geometry\n"
          }
        },
        "end" : 354,
        "name" : "transform",
        "start" : 252
      }, {
        "code" : [ "", "        return (", "            tup[0] * self._m[0] + tup[1] * self._m[1] + tup[2] * self._m[2]     + self._m[3]," ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 360,
        "name" : "_xform_tuple",
        "start" : 358
      }, {
        "code" : [ "    def c11(self): return self._m[0]", "    @c11.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 367,
        "name" : "c11",
        "start" : 366
      }, {
        "code" : [ "    def c11(self,value): self._m[0] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 369,
        "name" : "c11",
        "start" : 368
      }, {
        "code" : [ "    def c12(self): return self._m[1]", "    @c12.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 371,
        "name" : "c12",
        "start" : 370
      }, {
        "code" : [ "    def c12(self,value): self._m[1] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 373,
        "name" : "c12",
        "start" : 372
      }, {
        "code" : [ "    def c13(self): return self._m[2]", "    @c13.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 375,
        "name" : "c13",
        "start" : 374
      }, {
        "code" : [ "    def c13(self,value): self._m[2] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 377,
        "name" : "c13",
        "start" : 376
      }, {
        "code" : [ "    def c14(self):  return self._m[3]", "    @c14.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 379,
        "name" : "c14",
        "start" : 378
      }, {
        "code" : [ "    def c14(self,value): self._m[3] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 381,
        "name" : "c14",
        "start" : 380
      }, {
        "code" : [ "    def c21(self):  return self._m[4]", "    @c21.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 384,
        "name" : "c21",
        "start" : 383
      }, {
        "code" : [ "    def c21(self,value): self._m[4] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 386,
        "name" : "c21",
        "start" : 385
      }, {
        "code" : [ "    def c22(self): return self._m[5]", "    @c22.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 388,
        "name" : "c22",
        "start" : 387
      }, {
        "code" : [ "    def c22(self,value): self._m[5] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 390,
        "name" : "c22",
        "start" : 389
      }, {
        "code" : [ "    def c23(self): return self._m[6]", "    @c23.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 392,
        "name" : "c23",
        "start" : 391
      }, {
        "code" : [ "    def c23(self,value): self._m[6] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 394,
        "name" : "c23",
        "start" : 393
      }, {
        "code" : [ "    def c24(self): return self._m[7]", "    @c24.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 396,
        "name" : "c24",
        "start" : 395
      }, {
        "code" : [ "    def c24(self,value): self._m[7] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 398,
        "name" : "c24",
        "start" : 397
      }, {
        "code" : [ "    def c31(self): return self._m[8]", "    @c31.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 401,
        "name" : "c31",
        "start" : 400
      }, {
        "code" : [ "    def c31(self,value): self._m[8] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 403,
        "name" : "c31",
        "start" : 402
      }, {
        "code" : [ "    def c32(self): return self._m[9]", "    @c32.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 405,
        "name" : "c32",
        "start" : 404
      }, {
        "code" : [ "    def c32(self,value):  self._m[9] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 407,
        "name" : "c32",
        "start" : 406
      }, {
        "code" : [ "    def c33(self):  return self._m[10]", "    @c33.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 409,
        "name" : "c33",
        "start" : 408
      }, {
        "code" : [ "    def c33(self,value): self._m[10] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 411,
        "name" : "c33",
        "start" : 410
      }, {
        "code" : [ "    def c34(self): return self._m[11]", "    @c34.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 413,
        "name" : "c34",
        "start" : 412
      }, {
        "code" : [ "    def c34(self,value):  self._m[11] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 415,
        "name" : "c34",
        "start" : 414
      }, {
        "code" : [ "    def c41(self): return self._m[12]", "    @c41.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 418,
        "name" : "c41",
        "start" : 417
      }, {
        "code" : [ "    def c41(self,value): self._m[12] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 420,
        "name" : "c41",
        "start" : 419
      }, {
        "code" : [ "    def c42(self): return self._m[13]", "    @c42.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 422,
        "name" : "c42",
        "start" : 421
      }, {
        "code" : [ "    def c42(self,value): self._m[13] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 424,
        "name" : "c42",
        "start" : 423
      }, {
        "code" : [ "    def c43(self): return self._m[14]", "    @c43.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 426,
        "name" : "c43",
        "start" : 425
      }, {
        "code" : [ "    def c43(self,value): self._m[14] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 428,
        "name" : "c43",
        "start" : 427
      }, {
        "code" : [ "    def c44(self): return self._m[15]", "    @c44.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 430,
        "name" : "c44",
        "start" : 429
      }, {
        "code" : [ "    def c44(self,value): self._m[15] = value        ", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 432,
        "name" : "c44",
        "start" : 431
      }, {
        "code" : [ "    def m00(self): return self._m[0]", "    @m00.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 439,
        "name" : "m00",
        "start" : 438
      }, {
        "code" : [ "    def m00(self,value): self._m[0] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 441,
        "name" : "m00",
        "start" : 440
      }, {
        "code" : [ "    def m01(self): return self._m[1]", "    @m01.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 443,
        "name" : "m01",
        "start" : 442
      }, {
        "code" : [ "    def m01(self,value): self._m[1] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 445,
        "name" : "m01",
        "start" : 444
      }, {
        "code" : [ "    def m02(self): return self._m[2]", "    @m02.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 447,
        "name" : "m02",
        "start" : 446
      }, {
        "code" : [ "    def m02(self,value): self._m[2] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 449,
        "name" : "m02",
        "start" : 448
      }, {
        "code" : [ "    def m03(self):  return self._m[3]", "    @m03.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 451,
        "name" : "m03",
        "start" : 450
      }, {
        "code" : [ "    def m03(self,value): self._m[3] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 453,
        "name" : "m03",
        "start" : 452
      }, {
        "code" : [ "    def m10(self):  return self._m[4]", "    @m10.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 456,
        "name" : "m10",
        "start" : 455
      }, {
        "code" : [ "    def m10(self,value): self._m[4] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 458,
        "name" : "m10",
        "start" : 457
      }, {
        "code" : [ "    def m11(self): return self._m[5]", "    @m11.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 460,
        "name" : "m11",
        "start" : 459
      }, {
        "code" : [ "    def m11(self,value): self._m[5] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 462,
        "name" : "m11",
        "start" : 461
      }, {
        "code" : [ "    def m12(self): return self._m[6]", "    @m12.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 464,
        "name" : "m12",
        "start" : 463
      }, {
        "code" : [ "    def m12(self,value): self._m[6] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 466,
        "name" : "m12",
        "start" : 465
      }, {
        "code" : [ "    def m13(self): return self._m[7]", "    @m13.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 468,
        "name" : "m13",
        "start" : 467
      }, {
        "code" : [ "    def m13(self,value): self._m[7] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 470,
        "name" : "m13",
        "start" : 469
      }, {
        "code" : [ "    def m20(self): return self._m[8]", "    @m20.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 473,
        "name" : "m20",
        "start" : 472
      }, {
        "code" : [ "    def m20(self,value): self._m[8] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 475,
        "name" : "m20",
        "start" : 474
      }, {
        "code" : [ "    def m21(self): return self._m[9]", "    @m21.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 477,
        "name" : "m21",
        "start" : 476
      }, {
        "code" : [ "    def m21(self,value):  self._m[9] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 479,
        "name" : "m21",
        "start" : 478
      }, {
        "code" : [ "    def m22(self):  return self._m[10]", "    @m22.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 481,
        "name" : "m22",
        "start" : 480
      }, {
        "code" : [ "    def m22(self,value): self._m[10] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 483,
        "name" : "m22",
        "start" : 482
      }, {
        "code" : [ "    def m23(self): return self._m[11]", "    @m23.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 485,
        "name" : "m23",
        "start" : 484
      }, {
        "code" : [ "    def m23(self,value):  self._m[11] = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 487,
        "name" : "m23",
        "start" : 486
      }, {
        "code" : [ "    def m30(self): return self._m[12]", "    @m30.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 490,
        "name" : "m30",
        "start" : 489
      }, {
        "code" : [ "    def m30(self,value): self._m[12] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 492,
        "name" : "m30",
        "start" : 491
      }, {
        "code" : [ "    def m31(self): return self._m[13]", "    @m31.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 494,
        "name" : "m31",
        "start" : 493
      }, {
        "code" : [ "    def m31(self,value): self._m[13] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 496,
        "name" : "m31",
        "start" : 495
      }, {
        "code" : [ "    def m32(self): return self._m[14]", "    @m32.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 498,
        "name" : "m32",
        "start" : 497
      }, {
        "code" : [ "    def m32(self,value): self._m[14] = value", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 500,
        "name" : "m32",
        "start" : 499
      }, {
        "code" : [ "    def m33(self): return self._m[15]", "    @m33.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 502,
        "name" : "m33",
        "start" : 501
      }, {
        "code" : [ "    def m33(self,value): self._m[15] = value    ", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 504,
        "name" : "m33",
        "start" : 503
      } ],
      "documentation" : {
        "description" : [ "A transformation matrix class." ]
      },
      "end" : 504,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_xform.py",
      "name" : "Xform",
      "references" : {
        "classes" : {
          "Arc" : 2,
          "CS" : 3,
          "Circle" : 2,
          "HasBasis" : 1,
          "HasPts" : 1,
          "Line" : 2,
          "LinearEntity" : 1,
          "Plane" : 2,
          "Point" : 6,
          "Ray" : 2,
          "Rhino" : 2,
          "Segment" : 2,
          "Vec" : 13,
          "Xform" : 16
        },
        "functions" : {
          "__init__" : 1,
          "__mul__" : 1,
          "__repr__" : 1,
          "_xform_tuple" : 1,
          "c11" : 2,
          "c12" : 2,
          "c13" : 2,
          "c14" : 2,
          "c21" : 2,
          "c22" : 2,
          "c23" : 2,
          "c24" : 2,
          "c31" : 2,
          "c32" : 2,
          "c33" : 2,
          "c34" : 2,
          "c41" : 2,
          "c42" : 2,
          "c43" : 2,
          "c44" : 2,
          "change_basis" : 1,
          "m00" : 2,
          "m01" : 2,
          "m02" : 2,
          "m03" : 2,
          "m10" : 2,
          "m11" : 2,
          "m12" : 2,
          "m13" : 2,
          "m20" : 2,
          "m21" : 2,
          "m22" : 2,
          "m23" : 2,
          "m30" : 2,
          "m31" : 2,
          "m32" : 2,
          "m33" : 2,
          "mirror" : 1,
          "rotation" : 1,
          "scale" : 1,
          "strip_translation" : 1,
          "transform" : 1,
          "translation" : 1
        }
      },
      "start" : 7
    },
    "0f739107-63aa-47bb-aa20-628ac1124384" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Bird():", "    ", "    def __init__(self, pos_start = None, vel_start = None):", "        if pos_start is None :  pos_start = Point.random(constrain2d=True)", "        if vel_start is None :  ", "            vel_start = Vec.random(constrain2d=True).normalized()", "        ", "        # this Bird's position and velocity", "        self.pos, self.vel = pos_start, vel_start ", "        # an upper limit to this Bird's velocity", "        self.max_vel = 3.0", "        # this Bird's acceleration", "        self.acl = Vec() ", "        # a limit on how much external forces influence this Bird", "        self.max_frc = 0.3", "        ", "        # a range to which this bird can see other birds", "        self.rov = 40.0", "        # a range of comfort with nearby birds", "        self.roc = 15.00", "        ", "        self.clear_history()", "        self.record()", "        ", "        ", "    \"\"\"", "    Misc", "    Overload the '==' operator so that two birds will be considered equal if their x and y coordinates are equal. Needed in order for the Point.cull_duplicates method to work.", "    [noprint]", "    \"\"\"", "    # define property functions to return x- and y-position", "    @property", "    def x(self): ", "        return self.pos.x", "    ", "    @property", "    def y(self): ", "        return self.pos.y", "    ", "    def __eq__(self, other): ", "        try:", "            return all([self.x==other.x,self.y==other.y])", "        except:", "            return False", "", "    # so that a bird may be treated like a point", "    def distance2(self,other):", "        return self.pos.distance2(other.pos)", "            ", "    \"\"\"", "    Step Method", "    Causes the Bird to move. The position is updated using the current velocity, and the velocity is updated using the current acceleration", "    [noprint]", "    \"\"\"        ", "    def step(self):  ", "        # add the acceleration to the velocity", "        self.vel += self.acl", "        # limit to the maximum velocity", "        self.vel = self.vel.limited(self.max_vel) ", "        # move bird", "        self.pos += self.vel ", "        # record the step after move", "        self.record()       ", "        # reset acceleration back to zero for next step", "        self.acl = Vec() ", "", "    \"\"\"", "    Steer Method", "     Provides an interface for influencing the trajectory of this Bird by implementing Craig Reynolds' formula. Steers the Bird toward, or away from, a desired vector", "    \"\"\"  ", "    def steer(self, desired = Vec(), weight = 1.0):", "        # scale the desire vector to the max velocity", "        if desired <> Vec(): desired = desired.normalized(self.max_vel)", "        # Steer = Desired - Velocity", "        steer =  desired  - self.vel", "        # limit the steer vector and weight it", "        steer = steer.limited(self.max_frc) * weight", "        # add the steer vector to acceleration", "        self.acl += steer         ", "", "    \"\"\"", "    Scanning Behaviors", "    The scan() and in_range() methods allow the Bird to be aware of the presence of nearby Birds", "    \"\"\"   ", "    # scans a region of space and returns birds within it ", "    def scan(self, quadtree) :", "        # create the boundary to scan", "        b_scan = Bounds(center = self.pos, dim_x = self.rov, dim_y = self.rov)", "        # get a list of birds within this boundary", "        close_birds = quadtree.pts_in_bounds(b_scan)", "        # return close birds that are not this bird", "        return [bird for bird in close_birds if bird is not self]    ", "        ", "    # determines if another bird lies within a given distance", "    def is_near(self,other,dist):", "        d2 = self.pos.distance2(other.pos)", "        return d2 !=0 and d2 <= dist**2", "        ", "    # returns birds that lie within a given distance", "    def in_range(self, others, dist):", "        return [ bird for bird in others if self.is_near(bird,dist) ]", "", "    \"\"\"", "    Seek Behavior", "    Allows this bird to steer toward the perceived center of a group of nearby Birds", "    \"\"\"", "    def seek(self, others, weight = 1.0):", "        if len(others) > 0 : ", "            # set a goal point at the centroid of nearby birds", "            goal = Point.centroid([other_bird.pos for other_bird in others])", "            self.steer(Vec(self.pos, goal), weight)", "", "    \"\"\"", "    Flee Behavior", "    Allows this bird to steer away from a group of nearby Birds that are too close", "    \"\"\" ", "    def flee(self, others, weight = 1.0):", "        # a list of 'flee' vectors that point away from nearby birds", "        vecs = [Vec(other.pos,self.pos) for other in others]", "        # 'flee' vectors resized to the inverse of the distance to bird", "        vecs = [v.normalized(1/v.length) for v in vecs if v.length2 > 0]", "        # steer this bird toward the average of the 'flee' vectors", "        if len(vecs) > 0 : self.steer(Vec.average(vecs), weight)        ", "", "    \"\"\"", "    Align Behavior", "    Allows this bird to align its direction of movement with the average direction of movement of a group of nearby Birds.", "    \"\"\"", "    def align(self,others, weight = 1.0):", "        if len(others) > 0 :     ", "            # align with the average velocity vector of nearby birds", "            align_vec=Vec.average([other_bird.vel for other_bird in others])", "            self.steer(align_vec, weight)", "", "    \"\"\"", "    Reset the Bird to its initial position and values", "    [noprint]", "    \"\"\"    ", "    def reset(self):", "        \"\"\"", "        resets this bird back to his initialized condition.", "        replaces existing history lists with single inital values", "        \"\"\"", "        self.is_alive = True", "        if len(self.hist_pos) > 0:", "            self.pos = self.hist_pos[0]", "            self.vel = self.hist_vel[0]", "            self.acl = self.hist_acl[0]", "        self.clear_history()", "        self.record()", "        ", "    \"\"\"", "    Functions to clear the history and record a step", "    [noprint]", "    \"\"\"    ", "    # clear the position, velocity and acceleration histories", "    def clear_history(self):", "        self.hist_pos = []", "        self.hist_vel = []", "        self.hist_acl = []", "", "    # record this step", "    def record(self):", "        # add position, velocity and acceleration to history", "        self.hist_pos.append(self.pos)", "        self.hist_vel.append(self.vel)", "        self.hist_acl.append(self.acl)", "        ", "", "" ],
          "end" : 201,
          "start" : 32
        },
        "description" : "\nFlocking Bird Class\nDefines an agent with flocking behaviors\n",
        "end" : 32,
        "start" : 29
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Birds/4.02.L05c.py",
      "name" : "4.02.L05c.py",
      "references" : {
        "classes" : {
          "Bird" : 1,
          "Bounds" : 1,
          "Point" : 2,
          "Vec" : 9
        }
      }
    },
    "0faaa90f-90c9-4ebd-8d38-af6cc17b0b00" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "definitions" : [ {
        "code" : [ "    def basis(self):", "        \"\"\" Identifies the defined basis. If no basis is defined, returns None.", "        \"\"\"    ", "        if self.is_baseless: return None", "        return self._basis", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Identifies the defined basis. If no basis is defined, returns None." ]
        },
        "end" : 161,
        "name" : "basis",
        "start" : 156
      }, {
        "code" : [ "    def basis(self, basis): ", "        \"\"\" Sets basis.", "        ", "            :param basis: Defined basis", "            :result: Defined basis", "            :rtype: Basis", "        \"\"\"", "        self._basis = basis", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets basis." ],
          "parameters" : {
            "basis" : "Defined basis\n"
          },
          "rtype" : "Basis",
          "rvalue" : "Defined basis\n"
        },
        "end" : 171,
        "name" : "basis",
        "start" : 163
      }, {
        "code" : [ "    def is_baseless(self):", "        \"\"\" Tells us if a basis has been defined.", "        \"\"\"", "        return (not hasattr(self, '_basis')) or self._basis is None", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Tells us if a basis has been defined." ]
        },
        "end" : 177,
        "name" : "is_baseless",
        "start" : 173
      }, {
        "code" : [ "        \"\"\" Returns a new object with basis applied. Copies are created of any child objects by default. Take care to copy over props if appropriate.", "            ", "            :result: Object with basis applied.", "            :rtype: Basis", "        \"\"\"", "        raise NotImplementedError(\"basis_applied not implemented.    I am a BAD HasBasis!\")", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new object with basis applied. Copies are created of any child objects by default. Take care to copy over props if appropriate." ],
          "rtype" : "Basis",
          "rvalue" : "Object with basis applied.\n"
        },
        "end" : 186,
        "name" : "basis_applied",
        "start" : 180
      }, {
        "code" : [ "        \"\"\" Returns a new object stripped of any basis. Copies are created of any child objects by default. Take care to copy over props if appropriate.", "            ", "            :result: Object with basis applied.", "            :rtype: Basis", "        \"\"\" ", "        raise NotImplementedError(\"basis_stripped not implemented.    I am a BAD HasBasis!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new object stripped of any basis. Copies are created of any child objects by default. Take care to copy over props if appropriate." ],
          "rtype" : "Basis",
          "rvalue" : "Object with basis applied.\n"
        },
        "end" : 194,
        "name" : "basis_stripped",
        "start" : 188
      } ],
      "documentation" : {
        "description" : [ "A base class for anything that wants to define a basis for itself. Bases must implement the following methods:" ]
      },
      "end" : 194,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "HasBasis",
      "references" : {
        "classes" : {
          "Geometry" : 1,
          "HasBasis" : 1
        },
        "functions" : {
          "basis" : 2,
          "basis_applied" : 1,
          "basis_stripped" : 1,
          "is_baseless" : 1
        }
      },
      "start" : 152
    },
    "0fffb31f-73c5-4bd8-8b18-2f6d4fd03798" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "problem_count = 99 ", "", "" ],
          "end" : 17,
          "start" : 14
        },
        "description" : "\n",
        "end" : 14,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "print \"I've got\" , problem_count , \"problems.\"", "", "" ],
          "end" : 22,
          "start" : 19
        },
        "description" : "\n",
        "end" : 19,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "count = 10", "pts=[]", "for n in range(count):", "    theta=((math.pi*2)/(count-1))*n", "    pt = Point(theta,math.sin(theta))", "    pts.append(pt)", "pl = PLine(pts)", "out.put(pl)" ],
          "end" : 31,
          "start" : 24
        },
        "description" : "\n",
        "end" : 24,
        "start" : 23
      } ],
      "documentation" : {
        "description" : [ "2.01.E00a", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E00 - NOGHX/2.01.E00a.py",
      "name" : "2.01.E00a.py",
      "references" : {
        "classes" : {
          "PLine" : 1,
          "Point" : 1
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "15a90654-5abb-44e9-a82c-beaf9111e8a1" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "verts = [Vec(0,0),Vec(1,0),Vec(2,0)]", "hpts = HasPts(verts)", "", "print hpts[2]", "", "" ],
          "end" : 21,
          "start" : 15
        },
        "description" : "\nThe basic construction of a HasPts\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "#we may append new verts to a HasPts as if it were a list", "hpts.append(Vec(3,0))", "", "#collection syntax allows direct access to these verts", "print hpts[3]", "#and allows us to redefine verts at particular indices", "hpts[3] = Vec(3,1)", "print hpts[3]", "", "#we may manipulate this collection of verts en masse", "hpts * Xform.rotation(angle=math.pi/2)", "print [v for v in hpts]", "", "" ],
          "end" : 38,
          "start" : 24
        },
        "description" : "\nSome basic operations of a HasPts\n",
        "end" : 24,
        "start" : 22
      }, {
        "code" : {
          "content" : [ "verts = [Vec(0,0),Vec(1,0),Vec(2,0)]", "basis = CS(0,0,1)", "hpts = HasPts(verts,basis)", "", "# world space points are accessed through the pts property", "print hpts[2], hpts.pts[2]", "", "# appended Vecs are assumed to be in local space", "hpts.append(Vec(3,0))", "# appended Points are assumed to be in world space", "hps.append(Point(4,0,1))", "print [pt for pt in hpts.pts]" ],
          "end" : 52,
          "start" : 41
        },
        "description" : "\nThe construction of a HasPts with a basis allow us to distinguish between the 'local space' of the vertices of the HasPs from the 'world space' in which the points are drawn.\n",
        "end" : 41,
        "start" : 39
      } ],
      "documentation" : {
        "description" : [ "3.08.E00a", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/NOGHX/3.08.E00a.py",
      "name" : "3.08.E00a.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "HasPts" : 2,
          "Point" : 1,
          "Vec" : 9,
          "Xform" : 1
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "16706193-3546-42fb-a5e0-5cbe5309990b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def connect_arcs(crv, t_vals):", "    arcs = []", "    #set the first breakpoint", "    t0 = t_vals[0]", "\t# compute the inputs needed at the first breakpoint to make first arc ", "    this_pt = crv.deval(t0)", "    tangent_arc = crv.tangent(t0)", "    # for each subsequent breakpoint along the curve", "    for t in t_vals[1:]:", "        #set the second breakpoint", "        next_pt = crv.deval(t)", "        # create an arc using the inputs from two adjacent breakpoints", "        arc = Arc.from_tan(this_pt,next_pt,tangent_arc)", "        arcs.append(arc)", "        #compute the inputs needed at the second breakpoint to make the next arc", "        tangent_arc = crv.tangent(t)", "        #reset the first breakpoint", "        this_pt = next_pt", "    return arcs", "" ],
          "end" : 38,
          "start" : 18
        },
        "description" : "\nConnecting Arcs\nCompute arcs that connect points along a curve\n[pseudo]\n",
        "end" : 18,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "def curve_to_arcs(crv, ival, n):", "    #define the subcurve determined by ival", "    subcrv = curve.subcurve(ival, crv.tol)", "    #approximate the subcurve by an arc", "    arc = Arc.from_tan(crv.deval(ival.a), crv.deval(ival.b), crv.tangent(ival.a))", "    #compute the distance (and the t-value) from the subcurve to the arc", "    dist, t_max = distance_to_arc(subcrv,arc)", "    # while distance remains greater than ideal_distance:", "    while (dist > ideal_distance) and (n < max_recursion):", "        #record the t-value as a breakpt", "        divs_t.append(t_max)", "        #increment the recursive level", "        n += 1", "        #recursively call function with subintervals on both sides of breakpt", "        curve_to_arcs(crv, Interval(ival.a, t_max), n)", "        curve_to_arcs(crv, Interval(t_max, ival.b), n)", "    return divs_t", "    ", "#define a list of t-vals that holds the segment approximation of the curve", "divs_t = [curve.domain.a, curve.domain.b]", "#call function with initial ival being the curve domain", "curve_to_arcs(curve, curve.domain, 0)", "# remove duplicates from t-values list and sort in increasing value of t ", "divs_t = list(set(divs_t))", "divs_t = sorted(divs_t)", "# evaluate the breakpoints along Curve", "div_pts = [curve.deval(t) for t in divs_t]", "decomp = connect_arcs(curve, divs_t)" ],
          "end" : 70,
          "start" : 43
        },
        "description" : "\nCurve to Arcs\nDecompose a curve by recursively splitting curve at point of maximum distance\n[pseudo]\n",
        "end" : 43,
        "start" : 39
      } ],
      "documentation" : {
        "description" : [ "4.03.L02d", "Given a curve, returns a set of arcs that approximates the curve." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Curve Decomposition/4.03.L02d.py",
      "name" : "4.03.L02d.py",
      "references" : {
        "classes" : {
          "Arc" : 2,
          "Interval" : 2
        }
      },
      "required" : [ "curve (Curve) The Curve to decompose.", "max_recursion (int) the maximum number of recursive steps", "ideal_distance (float)  ideal maximum distance between the approximation and the original Curve" ],
      "result" : [ "ret (Arc]) A decomposition of the curve into Arcs." ]
    },
    "179f31a0-4bbf-465d-a378-78d5357b9d5a" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "plines = []", "for theta in Interval(0,math.pi*2)/count:", "    basis = CS().on_xy(rot=theta)", "    plines.append(PLine(pl.pts,basis))", "", "a.put(plines)", "", "" ],
          "end" : 23,
          "start" : 15
        },
        "description" : "\nBy assigning alternative bases to existing Polylines, we may perform basic translations and rotations.\n",
        "end" : 15,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "3.08.E01b", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/ Manipulating Bases/3.08.E01b.py",
      "name" : "3.08.E01b.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 1,
          "PLine" : 1
        }
      },
      "required" : [ "todo" ],
      "result" : [ "todo" ]
    },
    "190c2ceb-9163-4984-a92f-6d273df55bf0" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_2d.py",
      "definitions" : [ {
        "code" : [ "    def _base_pts(self):", "        return [ ", "            Point(0.0, 0.0)," ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 182,
        "name" : "_base_pts",
        "start" : 180
      }, {
        "code" : [ "        # TileA0 has its origin CS on _base_pts[10], the XAxis points towards _base_pts[0], and the YAxis points towards _base_pts[9]", "        cs = self._cs_from_base_pts(10,0,9)", "        # Create a TileA0 on the new CS and scale it down", "        a0 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a0\")", "        ", "        # TileA1 has its origin CS on _base_pts[2], the XAxis points towards _base_pts[3], and the YAxis points towards _base_pts[8]", "        cs = self._cs_from_base_pts(2,3,8)", "        # Create a Tile1A on the new CS and scale it down", "        a1 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a1\")", "        ", "        # TileA2 has its origin CS on _base_pts[5], the XAxis points towards _base_pts[6], and the YAxis points towards _base_pts[11]", "        cs = self._cs_from_base_pts(5,6,11)", "        # Create a TileA2 on the new CS and scale it down", "        a2 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a2\")", "        ", "        # TileC0 has its origin CS on _base_pts[12], the XAxis points towards _base_pts[10], and the YAxis points towards _base_pts[1]", "        cs = self._cs_from_base_pts(12,10,1)", "        # Create a TileC0 on the new CS and scale it down", "        c0 = AmmannA3TileC(self.xf * cs.xform * self._xf_scale,self.lineage+\",c0\")", "        return [a0,a1,a2,c0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 219,
        "name" : "inflate",
        "start" : 199
      }, {
        "code" : [ "        pg = PGon(self.base_pts[:11])", "        pg.name = self.lineage", "        return pg", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 225,
        "name" : "to_pgon",
        "start" : 222
      }, {
        "code" : [ "        pg = [Segment(self.base_pts[0],self.base_pts[6]),Segment(self.base_pts[3],self.base_pts[8])]", "        return pg", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 229,
        "name" : "to_lines",
        "start" : 227
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 229,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_2d.py",
      "name" : "AmmannA3TileB",
      "references" : {
        "classes" : {
          "AmmannA3Tile" : 1,
          "AmmannA3TileA" : 3,
          "AmmannA3TileB" : 1,
          "AmmannA3TileC" : 1,
          "PGon" : 1,
          "Point" : 13,
          "Segment" : 2
        },
        "functions" : {
          "_base_pts" : 1,
          "inflate" : 1,
          "to_lines" : 1,
          "to_pgon" : 1
        }
      },
      "start" : 178
    },
    "1ab6abcd-cd3d-417e-9daa-2fbcc28645fa" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def morph(pl_0,pl_1,seg):", "    # get an attractor factor ", "    factor = att_ival.deval(seg.midpoint.distance(attractor))", "    if factor < 0 : factor = 0.0", "    if factor > 1 : factor = 1.0", "    r_pl = range(len(pl_0))", "    # interpolate the two PLines with the factor", "    pts = [Point.interpolate(pl_0.pts[n],pl_1.pts[n],factor) for n in r_pl]", "    # create a new PLine with the interpolated Points", "    return PLine(pts)", "    " ],
          "end" : 29,
          "start" : 17
        },
        "description" : "\nMorph Function\nMorphs a given PLine by a factor of a distance to an attractor point\n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "", "def reorient(pl_0,pl_1,seg,do_flip=False):", "    # morph the PLine between the two PLines", "    pl = morph(pl_0,pl_1,seg)", "    # Ray from the PLine's start point to its end point", "    src = Ray(pl.pts[0],Vec(pl.pts[0],pl.pts[-1])) ", "    # Ray from the hexagon's start point to its end point", "    tar = Ray(seg.spt,seg.vec)", "    # if the Segment will be flipped: flip the Ray", "    if do_flip: tar = Ray(seg.ept,seg.vec.inverted())", "    cs1 = CS(src.spt,src._vec,Vec(0,0,1))", "    # change the basis of a CS from the PLine to the edge", "    xf = Xform.change_basis(cs1,CS(tar.spt,tar._vec,Vec(0,0,1)))", "    # create a new PLine with the transformed Points", "    if do_flip:", "        pts = [pt for pt in pl.pts]", "        pts.reverse()", "        return PLine(pts) * xf", "    return PLine(pl.pts) * xf" ],
          "end" : 52,
          "start" : 33
        },
        "description" : "\nReorient Function\nReorients the morphed PLine according to a given segment\n",
        "end" : 33,
        "start" : 30
      }, {
        "code" : {
          "content" : [ "# scale each PLine to edge length", "edge_length = tiles[0].edges[0].length", "# set and attractor point", "attractor = Point(1,1)", "# set an attractor value interval", "att_ival = Interval(1000,0)", "", "# get an attractor value with a distance", "for tile in tiles:", "    dst = tile.centroid.distance(attractor)", "    if dst < att_ival.a : att_ival.a = dst", "    if dst > att_ival.b : att_ival.b = dst", "    ", "# scale the given PLine", "pl_a = rescale(pl_a,edge_length)", "pl_b = rescale(pl_b,edge_length)", "pl_c = rescale(pl_c,edge_length)", "pl_aa = rescale(pl_aa,edge_length)", "pl_bb = rescale(pl_bb,edge_length)", "pl_cc = rescale(pl_cc,edge_length)", "", "# for every tile in tiles: ", "for tile in tiles:", "    sides = []", "    # tile the PLines into the hexagonal grid ", "    sides.append(reorient(pl_a,pl_aa,tile.edges[0]))", "    # every other PLine is flipped", "    sides.append(reorient(pl_a,pl_aa,tile.edges[1],True))", "    sides.append(reorient(pl_b,pl_bb,tile.edges[2]))", "    sides.append(reorient(pl_b,pl_bb,tile.edges[3],True))", "    sides.append(reorient(pl_c,pl_cc,tile.edges[4]))", "    sides.append(reorient(pl_c,pl_cc,tile.edges[5],True))", "    ", "    new_sides = join(sides)" ],
          "end" : 89,
          "start" : 56
        },
        "description" : "\nEscher Tiling Routine\nCreate an Escher tiling and interpolate between different PLines based on an attractor value\n",
        "end" : 56,
        "start" : 53
      } ],
      "documentation" : {
        "description" : [ "4.01.L03b", "With a given hexagonal tiling, create an Escher tiling. The tiling will be created with three PLines. According to an attractor force the PLines will be interpolated between an original and a target PLine." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Escher Tessellation/4.01.L03b.py",
      "name" : "4.01.L03b.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Interval" : 1,
          "PLine" : 3,
          "Point" : 2,
          "Ray" : 3,
          "Vec" : 3,
          "Xform" : 1
        }
      },
      "required" : [ "tiles ([PLine]) Hexagonal grid", "pl_a, pl_b, pl_c (PLine) Original PLines", "pl_aa, pl_bb, pl_cc (PLine) Target PLines" ],
      "result" : [ "ret ([Pline]) Morphed Escher tiling." ]
    },
    "1c04c298-e12c-4fd2-9f89-3c0ea672f135" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "interv = Interval()/int(1/surf.tol_u)", "colorA = Color(.97,.97,.97)", "colorB = Color(1,0,0)", "meshes = Mesh.explode(surf.surrogate) # explode the mesh", "", "curv = []", "# Evaluate the surface curvature at every UV", "for u in interv:", "    for v in interv:", "        # and append the curvature to a list", "        curv.append(surf.eval_curv(u,v,True)[3])", "", "# remap the curvature to an Interval", "curv =  [Interval.remap(i, Interval(min(curv), max(curv))) for i in curv]", "", "# for every face in the exploded mesh", "for i in range(len(meshes)):", "    mesh = meshes[i]", "    # set its color to the appropriate remapped curvature value", "    mesh.set_color(Color.interpolate(colorA,colorB,curvature[i]))" ],
          "end" : 32,
          "start" : 13
        },
        "description" : "\nProduce a map of Surface Curvature\n",
        "end" : 13,
        "start" : 11
      } ],
      "documentation" : {
        "description" : [ "4.03.L03b", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Surface Decomposition based on Curvature/4.03.L03b.py",
      "name" : "4.03.L03b.py",
      "references" : {
        "classes" : {
          "Color" : 3,
          "Interval" : 3,
          "Mesh" : 1
        }
      }
    },
    "1c6aec26-e7ad-4151-b4cf-003924d9b256" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_pgon.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" RGon Constructor.", "            ", "            :param num_of_sides: Number of sides of polygon.", "            :type num_of_sides: int", "            :param radius: Distance from center to vertices.", "            :type radius: float", "            :param basis: Basis.", "            :type basis: Basis.", "            :param edge_length: Length of polygon edge.", "            :type edge_length: float", "            :param apothem: Distance from center to midpoint of sides.", "            :type apothem: float", "            :result: Polygon.", "            :rtype: RGon", "            ", "            ::", "            ", "                my_rgon=RGon(num_of_sides=5, radius=2.0, edge_length=3.5)", "                ", "                OR", "                ", "                my_rgon2=RGon(num_of_sides=4, radius=3, apothem=4.5)", "        ", "        \"\"\" ", "        self._in_init = True", "        if num_of_sides < 3 : raise GeometricError(\"Cannot create a regular polygon with fewer than three sides.\")", "        if radius is None and edge_length is None and apothem is None : raise GeometricError(\"You must specify one and only one of the following: radius, edge length, apothem\")", "        if radius is not None and edge_length is not None  and apothem is not None : raise GeometricError(\"You must specify one and only one of the following: radius, edge length, apothem\")", "        #TOOD: test that one and only one have been set", "        self._nos = num_of_sides", "        ", "        if basis is None : basis = CS()", "        ", "        if edge_length is not None: ", "            if edge_length <= 0 : raise GeometricError(\"edge_length must be greater than zero\")", "            self._edge_length = edge_length", "            self._radius = edge_length / (2.0 * math.sin(math.pi/self._nos))", "        elif apothem is not None: ", "            if apothem <= 0 : raise GeometricError(\"apothem must be greater than zero\")", "            self._apothem = apothem", "            self._radius = apothem / math.cos(math.pi/self._nos)", "        elif radius is not None: ", "            if radius <= 0 : raise GeometricError(\"radius must be greater than zero\")", "            self._radius = radius", "        else:", "            raise GeometricError(\"You must specify one and only one of the following: radius, edge length, apothem\")", "", "        step = math.pi*2.0/num_of_sides", "        verts = [Point( self.radius * math.cos(step*n), self.radius * math.sin(step*n))  for n in range(num_of_sides) ]", "", "        super(RGon,self).__init__(verts, basis)", "        self._in_init = False", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "RGon Constructor." ],
          "parameters" : {
            "apothem" : "Distance from center to midpoint of sides.\n",
            "basis" : "Basis.\n",
            "edge_length" : "Length of polygon edge.\n",
            "num_of_sides" : "Number of sides of polygon.\n",
            "radius" : "Distance from center to vertices.\n"
          },
          "rtype" : "RGon\n\n",
          "rvalue" : "Polygon.\n",
          "types" : {
            "apothem" : "float\n",
            "basis" : "Basis.\n",
            "edge_length" : "float\n",
            "num_of_sides" : "int\n",
            "radius" : "float\n"
          }
        },
        "end" : 605,
        "name" : "__init__",
        "start" : 553
      }, {
        "code" : [ "    def radius(self):", "        \"\"\" Returns radius of RGon.", "        ", "            :result: Radius of polygon.", "            :rtype: float", "            ", "        \"\"\"", "        return self._radius", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns radius of RGon." ],
          "rtype" : "float",
          "rvalue" : "Radius of polygon.\n"
        },
        "end" : 616,
        "name" : "radius",
        "start" : 608
      }, {
        "code" : [ "    def num_of_sides(self):", "        \"\"\" Returns number of sides of the RGon.", "        ", "            :result: Number of sides of polygon.", "            :rtype: int", "        ", "        \"\"\"", "        return self._nos", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns number of sides of the RGon." ],
          "rtype" : "int",
          "rvalue" : "Number of sides of polygon.\n"
        },
        "end" : 626,
        "name" : "num_of_sides",
        "start" : 618
      }, {
        "code" : [ "    def area(self):", "        \"\"\" Returns the area of the polygon.", "        ", "            :result: Area of the polygon.", "            :rtype: float", "            ", "            ::", "            ", "                my_rgon.area", "                ", "        \"\"\"", "        try:", "            return self._area", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the area of the polygon." ],
          "rtype" : "float\n\n",
          "rvalue" : "Area of the polygon.\n"
        },
        "end" : 641,
        "name" : "area",
        "start" : 628
      }, {
        "code" : [ "    def apothem(self):", "        \"\"\" The distance from the center to the midpoint of any side.", "        ", "            :result: Apothem of the polygon.", "            :rtype: float", "            ", "            ::", "            ", "                my_rgon.apothem", "                ", "        \"\"\"", "        try:", "            return self._apothem", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "The distance from the center to the midpoint of any side." ],
          "rtype" : "float\n\n",
          "rvalue" : "Apothem of the polygon.\n"
        },
        "end" : 659,
        "name" : "apothem",
        "start" : 646
      }, {
        "code" : [ "    def edge_length(self):", "        \"\"\" The length of any edge.", "            ", "            :result: The length of any edge.", "            :rtype: float", "            ", "            ::", "            ", "                my_rgon.edge_length", "                ", "        \"\"\"", "        try:", "            return self._edge_length", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "The length of any edge." ],
          "rtype" : "float\n\n",
          "rvalue" : "The length of any edge.\n"
        },
        "end" : 679,
        "name" : "edge_length",
        "start" : 666
      }, {
        "code" : [ "    def circle_inscr(self):", "        \"\"\" Returns the inscribed circle of this RGon.", "        ", "            :result: Inscribed circle.", "            :rtype: Circle", "            ", "            ::", "            ", "                my_rgon.circle_inscr", "            ", "        \"\"\"", "        return Circle(self._basis.xy_plane, self.radius)", " " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the inscribed circle of this RGon." ],
          "rtype" : "Circle\n\n",
          "rvalue" : "Inscribed circle.\n"
        },
        "end" : 696,
        "name" : "circle_inscr",
        "start" : 684
      }, {
        "code" : [ "    def circle_cirscr(self):", "        \"\"\" Returns the circumscribed circle of this RGon.", "        ", "            :result: Circumscribed circle.", "            :rtype: Circle", "            ", "        \"\"\"", "        return Circle(self._basis.xy_plane, self.apothem)", " " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the circumscribed circle of this RGon." ],
          "rtype" : "Circle",
          "rvalue" : "Circumscribed circle.\n"
        },
        "end" : 706,
        "name" : "circle_cirscr",
        "start" : 698
      }, {
        "code" : [ "    def interior_angle(self):", "        \"\"\" Returns the interior angle of this RGon.", "        ", "            :result: Interior angle in radians.", "            :rtype: float", "            ", "            ::", "            ", "                my_rgon.interior_angle", "        \"\"\"", "        try:", "            return self._iangle", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the interior angle of this RGon." ],
          "rtype" : "float\n\n",
          "rvalue" : "Interior angle in radians.\n"
        },
        "end" : 720,
        "name" : "interior_angle",
        "start" : 708
      }, {
        "code" : [ "        raise GeometricError(\"I can't even. You can't append vertices to a RGon!\")", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 726,
        "name" : "append",
        "start" : 725
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 729,
        "name" : "__repr__",
        "start" : 729
      }, {
        "code" : [ "        \"\"\" Returns a regular polygon inscribed inside this one while maintaining the same number of sides.", "            Optionally, you may set parameter t 0->1", "           ", "            :param t: A decimal number between [0:1].", "            :type t: float", "            :result: An regular inscribed polygon.", "            :rtype: RGon", "            ", "            ::", "            ", "                my_rgon.inflate(t)", "            ", "        \"\"\"", "        pt = Point.interpolate(self.pts[0],self.pts[1],t)", "        o = self._basis.origin", "        x = Vec(o,pt)", "        y = self._basis.z_axis.cross(x)", "        return RGon(self._nos, basis = CS(o,x,y), radius = o.dist(pt))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a regular polygon inscribed inside this one while maintaining the same number of sides.", "Optionally, you may set parameter t 0->1" ],
          "parameters" : {
            "t" : "A decimal number between [0"
          },
          "rtype" : "RGon\n\n",
          "rvalue" : "An regular inscribed polygon.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 749,
        "name" : "inflate",
        "start" : 731
      }, {
        "code" : [ "        \"\"\" Returns a regular polygon that circumscribes this one while maintaining the same number of sides.", "            Optionally, you may set parameter t 0->1", "           ", "            :param t: A decimal number between [0:1].", "            :type t: float       ", "            :result: a regular polygon circumscribing this one.", "            :rtype: RGon", "            ", "            ::", "            ", "                my_rgon.deflate(t)", "            ", "        \"\"\"        ", "        pt_a = Point.interpolate(self.pts[0],self.pts[1],t)", "        pt_b = Point.interpolate(self.pts[-1],self.pts[0],t)", "        o = self._basis.origin", "        x = Vec(o,pt_a)", "        y = self._basis.z_axis.cross(x) ", "        if (t == 0.5):", "            return RGon(self._nos, basis = CS(o,x,y), apothem = self.radius) ", "        vec_perp = (Vec(pt_b, pt_a).cross(self._basis.z_axis)).normalized()", "        return RGon(self._nos, basis = CS(o,x,y), apothem = Vec(o,self.pts[0]).dot(vec_perp))", "  " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a regular polygon that circumscribes this one while maintaining the same number of sides.", "Optionally, you may set parameter t 0->1" ],
          "parameters" : {
            "t" : "A decimal number between [0"
          },
          "rtype" : "RGon\n\n",
          "rvalue" : "a regular polygon circumscribing this one.\n",
          "types" : {
            "t" : "float       \n"
          }
        },
        "end" : 773,
        "name" : "deflate",
        "start" : 751
      }, {
        "code" : [ "        \"\"\" Returns the PGon equivalent of this RGon.", "        ", "            :result: A polygon.", "            :rtype: PGon", "            ", "            ::", "            ", "                my_rgon.to_pgon()", "        \"\"\"", "        return PGon(self._verts,self._basis)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the PGon equivalent of this RGon." ],
          "rtype" : "PGon\n\n",
          "rvalue" : "A polygon.\n"
        },
        "end" : 786,
        "name" : "to_pgon",
        "start" : 776
      }, {
        "code" : [ "        if not self._in_init : raise GeometricError(\"I cannot manipulate the vertices of this PGon.  Convert to PGon using RGon.to_pgon()\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 789,
        "name" : "_vertices_changed",
        "start" : 788
      }, {
        "code" : [ "    def from_edge(segment,num_of_sides,normal=Vec(0,0,1)):", "        \"\"\" Constructs a regular polygon given a line segment describing one edge. The side of the edge that the center of the resulting polygon falls is determined by taking the cross product of the given edge vector and the given normal vector.", "            ", "            :param segment: Edge of polygon.", "            :type segment: Segment", "            :param num_of_sides: Number of sides of polygon.", "            :type num_of_sides: int", "            :param normal: Vector normal to edge.", "            :type normal: Vec", "            :result: Regular polygon.", "            :rtype: RGon", "            ", "            ::", "            ", "                new_rgon=RGon.from_edge(Segment.by_coords2d(0,0,0,5),5, Vec(0,1,0))", "            ", "        \"\"\"", "        apothem = segment.length / (2.0 * math.tan(math.pi/num_of_sides))", "        cpt = segment.midpoint + segment.vec.cross(normal).normalized(apothem)", "        cs = CS(cpt,Vec(cpt,segment.spt),segment.vec.cross(normal))", "        return RGon(num_of_sides,apothem=apothem, basis=cs)" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a regular polygon given a line segment describing one edge. The side of the edge that the center of the resulting polygon falls is determined by taking the cross product of the given edge vector and the given normal vector." ],
          "parameters" : {
            "normal" : "Vector normal to edge.\n",
            "num_of_sides" : "Number of sides of polygon.\n",
            "segment" : "Edge of polygon.\n"
          },
          "rtype" : "RGon\n\n",
          "rvalue" : "Regular polygon.\n",
          "types" : {
            "normal" : "Vec\n",
            "num_of_sides" : "int\n",
            "segment" : "Segment\n"
          }
        },
        "end" : 812,
        "name" : "from_edge",
        "start" : 791
      } ],
      "documentation" : {
        "description" : [ "A Regular Polygon Class" ]
      },
      "end" : 812,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_pgon.py",
      "name" : "RGon",
      "references" : {
        "classes" : {
          "CS" : 5,
          "Circle" : 2,
          "PGon" : 2,
          "Point" : 5,
          "RGon" : 6,
          "Vec" : 6
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "_vertices_changed" : 1,
          "apothem" : 1,
          "append" : 1,
          "area" : 1,
          "circle_cirscr" : 1,
          "circle_inscr" : 1,
          "deflate" : 1,
          "edge_length" : 1,
          "from_edge" : 1,
          "inflate" : 1,
          "interior_angle" : 1,
          "num_of_sides" : 1,
          "radius" : 1,
          "to_pgon" : 1
        }
      },
      "start" : 547
    },
    "1cb6a4fe-810b-402a-b67b-4b09871d637c" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Vec(Geometry):       ", "    def __init__(self, a=0, b=0, c=0):", "        self.x = a", "        self.y = b", "        self.z = c", "            " ],
          "end" : 21,
          "start" : 15
        },
        "description" : "\nSimple Vector Class\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "class Vec(Geometry):", "    def __init__(self, a=0, b=0, c=0):", "        if all( hasattr(a,i) and hasattr(b,i) for i in ['x','y','z'] ) :", "            # we've been passed two things that act like points", "            self._x = b.x - a.x", "            self._y = b.y - a.y", "            self._z = b.z - a.z    ", "\t\t\t" ],
          "end" : 32,
          "start" : 24
        },
        "description" : "\nVector Construction by Two Points\n",
        "end" : 24,
        "start" : 22
      }, {
        "code" : {
          "content" : [ "vec_a = Vec(0,1,1)", "vec_b = Vec(pt_a,pt_b)", "" ],
          "end" : 38,
          "start" : 35
        },
        "description" : "\nVector Construction \n",
        "end" : 35,
        "start" : 33
      }, {
        "code" : {
          "content" : [ "vec_zero = Vec()", "" ],
          "end" : 43,
          "start" : 41
        },
        "description" : "\nZero Vector\n",
        "end" : 41,
        "start" : 39
      }, {
        "code" : {
          "content" : [ "def __add__(self, vec):", "    return Vec(self.x+vec.x , self.y+vec.y, self.z+vec.z)", "" ],
          "end" : 49,
          "start" : 46
        },
        "description" : "\nVector Addition\n",
        "end" : 46,
        "start" : 44
      }, {
        "code" : {
          "content" : [ "vec_add = vec_a + vec_b", "" ],
          "end" : 54,
          "start" : 52
        },
        "description" : "\nVector Addition Usage\n",
        "end" : 52,
        "start" : 50
      }, {
        "code" : {
          "content" : [ "def __mul__(self, other):", "\treturn other*self", " " ],
          "end" : 60,
          "start" : 57
        },
        "description" : "\nScalar Multiplication\n",
        "end" : 57,
        "start" : 55
      }, {
        "code" : {
          "content" : [ "vec_smult = vec_a*3", "" ],
          "end" : 65,
          "start" : 63
        },
        "description" : "\nScalar Multiplication Usage\n",
        "end" : 63,
        "start" : 61
      }, {
        "code" : {
          "content" : [ "def __sub__(self, vec): ", "\treturn Vec(self.x-vec.x , self.y-vec.y, self.z-vec.z)", "" ],
          "end" : 71,
          "start" : 68
        },
        "description" : "\nVector Subtraction\n",
        "end" : 68,
        "start" : 66
      }, {
        "code" : {
          "content" : [ "vec_subtract = vec_a - vec_b", "" ],
          "end" : 76,
          "start" : 74
        },
        "description" : "\nVector Subtraction Usage\n",
        "end" : 74,
        "start" : 72
      }, {
        "code" : {
          "content" : [ "def length(self): ", "    return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)", "    ", "def length2(self):", "    return self.x ** 2 + self.y ** 2 + self.z ** 2", "        " ],
          "end" : 86,
          "start" : 80
        },
        "description" : "\nVector Length\nReturns the length and the squared length of this vector.\n",
        "end" : 80,
        "start" : 77
      }, {
        "code" : {
          "content" : [ "def normalized(self, length=1.0):", "    factor = length / self.length", "    return Vec(self.x * factor, self.y * factor, self.z * factor)   ", "\t\t" ],
          "end" : 94,
          "start" : 90
        },
        "description" : "\nNormalizing a Vector\nReturns a vector in the same direction as this vector but scaled to given length\n",
        "end" : 90,
        "start" : 87
      }, {
        "code" : {
          "content" : [ "def dot(self,other): ", "    return float(self.x * other.x + self.y * other.y + self.z * other.z)", "        " ],
          "end" : 100,
          "start" : 97
        },
        "description" : "\nDot Product\n",
        "end" : 97,
        "start" : 95
      }, {
        "code" : {
          "content" : [ "def angle(self,other):", "    vdot = self.dot(other) / (self.length * other.length)", "    if vdot>1.0 : vdot = 1.0", "    if vdot<-1.0 : vdot = -1.0", "    return math.acos(vdot)", "\t\t" ],
          "end" : 110,
          "start" : 104
        },
        "description" : "\nAngle Between Two Vectors\nReturns the angle in radians, value constrained to the range [-PI,PI].\n",
        "end" : 104,
        "start" : 101
      }, {
        "code" : {
          "content" : [ "def projected_length(self,other): ", "    return self.dot(other.normalized())", "" ],
          "end" : 116,
          "start" : 113
        },
        "description" : "\nProjected Length\n",
        "end" : 113,
        "start" : 111
      }, {
        "code" : {
          "content" : [ "def projected(self,other):", "    return other * ( self.dot(other) / other.dot(other) )" ],
          "end" : 121,
          "start" : 119
        },
        "description" : "\nProjected Vector \n",
        "end" : 119,
        "start" : 117
      }, {
        "code" : {
          "content" : [ "def cross(self, other):", "    return Vec(\\", "        self.y * other.z - self.z * other.y,\\", "        self.z * other.x - self.x * other.z,\\", "        self.x * other.y - self.y * other.x\\", "    )      ", "        " ],
          "end" : 130,
          "start" : 124
        },
        "description" : "\nCross Product\n",
        "end" : 124,
        "start" : 122
      } ],
      "documentation" : {
        "description" : [ "3.02.E00a", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/NOGHX/3.02.E00a.py",
      "name" : "3.02.E00a.py",
      "references" : {
        "classes" : {
          "Geometry" : 2,
          "Vec" : 9
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "1ce8b7e5-819f-49a0-a1a6-1a730843324f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pt_1 = ln.spt", "pt_2 = ln.ept", "" ],
          "end" : 18,
          "start" : 15
        },
        "description" : "\nFinds two points on a given line\n[noprint]\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "v_1 = Vec(pt_1, pt)", "v_2 = Vec(pt_1, pt_2) #vector in direction of line", "", "pt_nearest = pt_1 + v_1.projected(v_2)", "" ],
          "end" : 26,
          "start" : 21
        },
        "description" : "\nNearest Point on a Line\n",
        "end" : 21,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "pt_mirror = pt_nearest + Vec(pt, pt_nearest)", "", "" ],
          "end" : 31,
          "start" : 29
        },
        "description" : "\nMirror Reflection Across Line\n",
        "end" : 29,
        "start" : 27
      } ],
      "documentation" : {
        "description" : [ "3.02.E02a", "Nearest Point Projections" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/Projections/3.02.E02a.py",
      "name" : "3.02.E02a.py",
      "references" : {
        "classes" : {
          "Vec" : 3
        }
      }
    },
    "1d97d0a3-fea6-4a0a-b451-eb8adc2fe1b2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def mesh_pgons(pts_top, pts_mid, pts_btm):", "    # construct an empty Mesh", "    msh = Mesh()", "    # add each of the given lists of Points to the Mesh", "    msh.append(pts_top)", "    msh.append(pts_mid)", "    msh.append(pts_btm)", "    # set cnt to the number of Points in any of these lists", "    cnt = len(pgon_top.pts)", "    # for every index from 0 to cnt:", "    for n in range(cnt-1):", "        # add mesh faces that connect corresponding points", "        msh.add_face(n,n+1,n+cnt)", "        msh.add_face(n+1,cnt+n+1,cnt+n)", "        msh.add_face(cnt+n,2*cnt+n+1,cnt*2+n)", "        msh.add_face(cnt+n,cnt+n+1,2*cnt+n+1)", "    # add mesh faces that connect the points at the edge", "    msh.add_face(cnt-1,0,cnt*2-1)", "    msh.add_face(0,cnt,cnt*2-1)", "    msh.add_face(cnt*3-1,cnt*2-1,cnt*2)", "    msh.add_face(cnt*2,cnt*2-1,cnt)", "    # return the completed Mesh", "    return msh", "    " ],
          "end" : 48,
          "start" : 23
        },
        "description" : "\nMesh from Point Lists\nMethod to create a Mesh from 3 lists of Points.\n",
        "end" : 23,
        "start" : 20
      }, {
        "code" : {
          "content" : [ "def dec_range(start, stop, step):", "    r = start", "    while r < stop:", "        yield r", "        r += step", "" ],
          "end" : 58,
          "start" : 52
        },
        "description" : "\nMethod to create a decimal range.\n[noprint]\n",
        "end" : 52,
        "start" : 49
      }, {
        "code" : {
          "content" : [ "        ", "def column(pgon,height,scale):", "    # get the vertices of the PGon", "    pts_btm = pgon.pts", "    # get the verts for the middle of the PGon by displacement", "    pts_mid =[e.eval(0.5)+Vec(0,0,max_ht*height[0]) for e in pgon.edges]", "    sin_range = Interval(0, math.pi+.1).divide(len(pgon.edges)-1,True)", "    new_pts_mid = []", "    # for every index and Point in pts_mid:", "    for i, pt in enumerate(pts_mid):", "        xf = Xform.scale((math.sin(i)*amp)+scale[0], Point.centroid(pts_mid))", "        # transform the Point and append it to a new list", "        new_pts_mid.append(pt * xf)", "    ", "    # get the verts for the bottom PGon by displacing a Pgon.", "    pts_top = [pt + Vec(0,0,max_ht*height[1]) for pt in pts_btm]", "    cos_range = Interval(0, math.pi+.1).divide(len(pgon.edges)-1,True)", "    new_pts_top = []", "    # for every index and Point in pts_mid:", "    for i, pt in enumerate(pts_top):", "        xf = Xform.scale((math.sin(i)*amp)+scale[1], Point.centroid(pts_top))", "        # transform the Point and append it to a new list", "        new_pts_top.append(pt * xf)", "    return mesh_pgons(pts_btm, new_pts_mid, new_pts_top),new_pts_top", "    " ],
          "end" : 87,
          "start" : 62
        },
        "description" : "\nHelios Column\nMethod to create a column, given a base PGon, a height and a scale value. \n",
        "end" : 62,
        "start" : 59
      }, {
        "code" : {
          "content" : [ " ", "# get the edges of the base PGon", "edges = rec.edges", "# sort the edges by length", "edges.sort(key=lambda Segment: Segment.length)", "", "# create scaling Xform", "xform1= Xform.scale(scale1,rec.centroid)", "xform2= Xform.scale(scale2,rec.centroid)", "", "# evaluate the edges of the PGon at t", "pts = [i.eval(t1) * xform1 for i in edges[:2]]", "# get the tangent Vecs to the edges", "vecs = [i.vec for i in edges[:2]]", "pts.extend([i.eval(t2) *xform2 for i in edges[2:]]) ", "vecs.extend([i.vec for i in edges[2:]])", "# for every edge in edges:", "for i in edges[2:]:", "    # get Points close to the end of the edges", "    pts.append(i.eval(.01))", "    vecs.extend([i.vec,i.vec])", "    pts.append(i.eval(.99))", "" ],
          "end" : 114,
          "start" : 91
        },
        "description" : "\nCreate Column Grid\nGet the vertices of the given PGon, add new Points to the list of Points by translating the mid Point of the PGon edges.\n",
        "end" : 91,
        "start" : 88
      }, {
        "code" : {
          "content" : [ "", "columns = []", "# get the transformation Vecs to orient the PGon", "new_vecs = [vec.cross(Vec(0,0,1)) for vec in vecs]", "new_pgons = []", "# for every Point in pts:", "for i, pt in enumerate(pts):", "    # move and re-orient the base PGon with the Vecs", "    new_pgon = PGon(pgon._verts,CS(pt,new_vecs[i],vecs[i]))", "    new_pgons.append(new_pgon)", "", "# scaling values for the PGon", "scales = [1.5, 1.5, .8, .8, .8, .8, .8, .8]", "scales[kiosk] = 2.8", "sc_pgons = []", "# for every PGon in new_pgons:", "for i, pg in enumerate(new_pgons):", "    # if the scaling factor is different than 1:", "    if scales[i] != 1:", "        # scale the base PGon", "        columns.append(pg * Xform.scale(scales[i],pgon.centroid))", "    # else: don't rescale the column", "    else: ", "        columns.append(pg)", "" ],
          "end" : 143,
          "start" : 118
        },
        "description" : "\nDistribute Column Bases\nGiven a base PGon, a list of values and a list of Points, translate and rescale the base PGon. \n",
        "end" : 118,
        "start" : 115
      }, {
        "code" : {
          "content" : [ "max_ht = 10", "pts = []", "centroids = []", "# for every PGon in pgons_top:", "for pgon_top in pgons_top:", "    # create the columns", "    c1 = column(pgon_top,[.5,1],[.5,1.5])", "    c2 = column(PGon(c1[1]),[.2,.3],[2,2.5])", "    # get the centroids of the columns", "    centroids.append(c2[0].centroid)", "    pts.append(c2[1])", "    # append the Mesh columns to the list of columns", "    columns.append([c1[0], c2[0]])", "" ],
          "end" : 161,
          "start" : 147
        },
        "description" : "\nMesh Columns\nCreate a number of Meshes with the translated PGons. \n",
        "end" : 147,
        "start" : 144
      }, {
        "code" : {
          "content" : [ "    ", "#Define the column topologies", "topology0 = [[0,5,6], [1,7,4]]", "topology1 = [[2,3]]", "topology2 = [[5,6,2,3], [2,3,4,7]]", "", "mesh0_pts = []", "#Get the top points of the columns", "for node in topology0:", "    node_pts = []", "    for column in node:", "        # add the column points to the node points", "        node_pts.extend(pts[column])", "    mesh0_pts.append(node_pts)", "    ", "#create a Mesh for all the faces of the roof", "roof_mesh = Mesh(mesh0_pts[0])", "# mesh faces between first and second columns", "roof_mesh.add_face(5,0,10)", "roof_mesh.add_face(0,1,9)", "roof_mesh.add_face(0,9,10)", "# mesh faces between for second and third columns", "roof_mesh.add_face(10,11,17)", "roof_mesh.add_face(10,17,12)", "roof_mesh.add_face(11,6,17)", "roof_mesh.add_face(6,16,17)", "# mesh faces between first and third columns", "roof_mesh.add_face(4,12,13)", "roof_mesh.add_face(4,13,3)", "roof_mesh.add_face(5,12,4)", "# mesh one last face", "roof_mesh.add_face(5,10,12)", "", "roof_mesh1 = Mesh(mesh0_pts[1])", "roof_mesh1.add_face(5,0,10)", "roof_mesh1.add_face(0,1,9)", "roof_mesh1.add_face(0,9,10)", "roof_mesh1.add_face(10,11,17)", "roof_mesh1.add_face(10,17,12)", "roof_mesh1.add_face(11,6,17)", "roof_mesh1.add_face(6,16,17)", "roof_mesh1.add_face(4,12,13)", "roof_mesh1.add_face(4,13,3)", "roof_mesh1.add_face(5,12,4)", "roof_mesh1.add_face(5,10,12)", "", "for node in topology1:", "    node_pts = []", "    for column in node :", "        # add the column points to the node points", "        node_pts.extend(pts[column])", "    mesh0_pts.append(node_pts)", "", "# create a Mesh for the middle of the roof", "roof_mesh2 = Mesh(mesh0_pts[2])", "roof_mesh2.add_face(5,10,11)", "roof_mesh2.add_face(4,5,11)", "roof_mesh2.add_face(4,11,6)", "roof_mesh2.add_face(5,0,10)", "", "for node in topology2:", "    node_pts = []", "    for column in node : node_pts.extend(pts[column])", "    mesh0_pts.append(node_pts)", "", "# create Meshes for bridging existing Meshes", "roof_mesh3 = Mesh(mesh0_pts[3])", "roof_mesh3.add_face(19,9,18)", "roof_mesh3.add_face(9,10,18)", "roof_mesh3.add_face(10,16,18)", "roof_mesh3.add_face(15,16,1)", "roof_mesh3.add_face(0,1,16)", "roof_mesh3.add_face(10,0,16)", "", "roof_mesh4 = Mesh(mesh0_pts[4])", "roof_mesh4.add_face(19,9,18)", "roof_mesh4.add_face(9,10,18)", "roof_mesh4.add_face(10,16,18)", "roof_mesh4.add_face(15,16,1)", "roof_mesh4.add_face(0,1,16)", "roof_mesh4.add_face(10,0,16)", "", "# create variables that describe the structure of the roof", "outer_order = [0,5,2,4,1,7,3,6]", "supra = [3,2,1] ", "border_pts =[]", "" ],
          "end" : 253,
          "start" : 166
        },
        "description" : "\nMesh Roof\nGiven a surface topology and a list of Mesh columns, create a Mesh roof structure with the top edges of the columns.\n[pseudo]\n",
        "end" : 166,
        "start" : 162
      }, {
        "code" : {
          "content" : [ "", "# for every index in the outer_order:", "for indx in outer_order :", "    # for every Point index in supra:", "    for s in supra :", "        # get the outer Points of the roof structure", "        border_pts.append(pts[indx][s])", "# create a PGon with the outer Points", "outline0 = PGon(border_pts)", "# get the centroid of the PGon", "scale_cen = outline0.centroid", "scale_cen.x += 77", "# scale and transform the outer PGon", "outline1 = outline0 * Xform.scale(1.1, origin = scale_cen)", "outline1 *= Xform.translation(Vec(0,0,5))", "" ],
          "end" : 273,
          "start" : 257
        },
        "description" : "\nOffset Roof Boundary\nGiven a list of vertices of a Mesh, get the boundary Points of the Mesh, create a PGon. Translate and rescale the PGon. \n",
        "end" : 257,
        "start" : 254
      }, {
        "code" : {
          "content" : [ "", "mids = []", "# get the individual edges of the PGon", "border_lines = outline1.edges", "# for every edge in the PGon: get the mid Point ", "for edge in border_lines : mids.append(edge.midpoint)", "", "roof_pts = border_pts + mids", "# create a Mesh with the roof PGon vertices", "roof_mesh5 = Mesh(roof_pts)", "offset_len = len (border_pts)", "# for every index in the number of vertices:", "for bp in range (offset_len+1):", "    # add a face to the Mesh", "    roof_mesh5.add_face(bp, offset_len + bp, bp +1 )", "    roof_mesh5.add_face(offset_len + bp - 1, offset_len + bp, bp )", "", "# create list of all the roof Meshes", "roof = [roof_mesh,roof_mesh1,roof_mesh2,roof_mesh3, roof_mesh4, roof_mesh5]", "" ],
          "end" : 296,
          "start" : 277
        },
        "description" : "\nMesh Roof Boundary\nGiven an outer PGon and a displaced outer PGon, create a Mesh between them.\n",
        "end" : 277,
        "start" : 274
      } ],
      "documentation" : {
        "description" : [ "4.04.F01a", "Subdivide a given PGon. Displace the mid Points of the PGon edges, and create Mesh columns on the new Points. Transform the scale of the columns. Take the top vertices of the columns and create an overall roof Mesh." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/HeliosHouse/4.04.F01a.py",
      "name" : "4.04.F01a.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 2,
          "Mesh" : 7,
          "PGon" : 3,
          "Point" : 2,
          "Segment" : 2,
          "Vec" : 4,
          "Xform" : 7
        }
      },
      "required" : [ "pgon (PGon) Base PGon to construct the columns with.", "rec (PGon) Base PGon to subdivide.", "t1 (float) Value to evaluate a Point of the longer edges of the PGon.", "t2 (float) Value to evaluate a Point of the shorter edges of the PGon.", "scale1 (float) Scale transformation for the Points evaluated on the long edges of the PGon.", "scale2 (float) Scale transformation for the Points evaluated on the short edges of the PGon.", "kiosk (int) Index of the Point to use as a kiosk." ],
      "result" : [ "top_edges (PLine) Top edges of the roof structure.", "roof (Mesh) Roof structure.", "columns (Mesh) Mesh columns." ]
    },
    "1df4d1b4-8f73-4de2-b7b5-e3c775903d57" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def fitness(sample):", "    # define the weight of each RGB color in the search", "    r_weight = 1.0", "    g_weight = 1.0", "    b_weight = 1.0", "    # get the difference between sample and goal Color", "    dr = 1-abs(sample.r - goal.r)", "    dg = 1-abs(sample.g - goal.g)", "    db = 1-abs(sample.b - goal.b)", "    # get the sum of the differences", "    sum = (dr*r_weight)+(dg*g_weight)+(db*b_weight)", "    # get the average", "    return sum/(r_weight+g_weight+b_weight)", "", "" ],
          "end" : 30,
          "start" : 16
        },
        "description" : "\nColor Fitness\nMethod that checks the closeness of a sample Color to the goal Color (0 to 1).\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L01a", "Given a sample Color and a goal Color to test against (either in HSV or RGB), check their closeness." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Color Optimization/4.07.L01a.py",
      "name" : "4.07.L01a.py",
      "required" : [ "sample (Color) A sample Color.", "goal (Color) A goal Color." ],
      "result" : [ "fitness (func)  Function to check closeness of a sample color to the goal color (0 to 1)." ]
    },
    "1f2a6981-304d-43ba-93e6-1ab74b163073" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def to_domain_vec(u,v,surf,real_vec):", "    # get point, u and v vectors", "    pt, u_vec, v_vec = surf._nudged(surf.domain_u.eval(u),surf.domain_v.eval(v))", "    u_vec = u_vec.normalized()", "    v_vec = v_vec.normalized()", "    n_vec = u_vec.cross(v_vec)", "    ", "    # determine u component of real vec through projection", "    xsec = Intersector()", "    pln = Plane(pt+real_vec,v_vec.cross(n_vec))", "    if xsec.of(pln,u_vec.to_line(pt)):", "        du = xsec.dist", "    else: print \"no intersection\", xsec.log", "    ", "    # determine v component of real vec through projection", "    pln = Plane(pt+real_vec,u_vec.cross(n_vec))", "    if xsec.of(pln,v_vec.to_line(pt)):", "        dv = xsec.dist", "    else: print \"no intersection\", xsec.log", "    ", "    return Vec(du,dv)", "" ],
          "end" : 39,
          "start" : 17
        },
        "description" : "\nWorld Vector to Domain Vector\nMaps a vector into the domain space of a surface. Given a surface, a u,v position on the surface, and a vector in world coords, returns a vector in domain coords that closely matches the given vector\n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "# initialize a vector field", "vecf = VecField(Interval(res_u,res_v), Point(0.5,0.5), Interval(1.0), Vec.uz())", "# initialize a value field", "valf = ValueField(Interval(res_u,res_v), 0.0)", "", "# for every u coordinate:", "for u in Interval(0.01,0.99).divide(res_u,True):", "    # for every v coordinate:", "    for v in Interval(0.01,0.99).divide(res_v,True):", "        # find closest address in vector field", "        ui,vi = vecf.address_near(Point(u,v))", "        # evaluate curve at u,v", "        crv = surf.eval_curv(u,v,True)", "        # find the delta between min and max curvature    ", "        delta = abs(crv[1] - crv[2])", "        # if min and max are very close:", "        if delta < 0.0001 : ", "            # make the delta = zero", "            delta= 0.0", "        # set value field to delta", "        valf.set(ui,vi,delta)", "        # if curvature is the same:", "        if delt==0.0:", "            # save a unit x vector in the field field", "            vecf.set(ui,vi,Vec.ux())", "        # else:", "        else:", "            # get the domain space vector", "            dvec = to_domain_vec(u,v,surf,crv[0].x_axis)", "            # if vector is flipped:", "            if dvec.x < 0 :", "                # invert the vector", "                dvec = dvec.inverted()", "            # save the vector in the vector field", "            vecf.set(ui,vi,dvec)" ],
          "end" : 77,
          "start" : 43
        },
        "description" : "\nVector and Value Fields\nCreate a vector and value fields for a surface\n",
        "end" : 43,
        "start" : 40
      } ],
      "documentation" : {
        "description" : [ "4.03.L05b", "Create a vector field to visualize the curvature of a surface" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Post-Rational Panelization/4.03.L05b.py",
      "name" : "4.03.L05b.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "Interval" : 5,
          "Plane" : 2,
          "Point" : 2,
          "ValueField" : 1,
          "Vec" : 3,
          "VecField" : 1
        }
      },
      "required" : [ "surf (Surface) A surface object", "res_u, res_v (int) The resolution for u and v sampling of the surface" ],
      "result" : [ "vecf (VectorField) A Vector Field containing maximum curvature information at sampled points", "valf (ValueField) A Value Field containing the differences between the max and min curvature" ]
    },
    "1f70538d-514a-46a4-85d9-e9197f02931b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def curve_to_lines(crv, ival, n):", "    subcrv = curve.subcurve(ival, crv.tol)", "    seg = Segment(crv.deval(ival.a), crv.deval(ival.b))", "    dist, t_max = distance_to_segment(subcrv,seg)", "    while (dist > ideal_distance) and (n < max_recursion):", "        divs_t.append(t_max)", "        n += 1", "        curve_to_lines(crv, Interval(ival.a, t_max), n)", "        curve_to_lines(crv, Interval(t_max, ival.b), n)", "    return divs_t", "", "#Setup a list of t-values corresponding to breakpoints", "divs_t = [curve.domain.a, curve.domain.b]", "curve_to_lines(curve, curve.domain, 0)", "", "# remove duplicates from t-values list", "divs_t = list(set(divs_t))", "# sort in increasing value of t ", "divs_t = sorted(divs_t)", "", "# evaluate the breakpoints along Curve", "div_pts = [curve.deval(t) for t in divs_t]", "decomp = PLine(div_pts)", "" ],
          "end" : 44,
          "start" : 20
        },
        "description" : "\nCurve to Lines\nDecompose a curve by recursively splitting curve at point of maximum distance\n",
        "end" : 20,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "num_segs = len(divs_t)-1", "", "#compute distance between the line decompostion and the original curve", "d_max = 0", "t_max = curve.domain.a", "for n in range(num_segs):", "    subcrv = curve.subcurve(Interval(divs_t[n], divs_t[n+1]))", "    seg = Segment(div_pts[n], div_pts[n+1])", "    d, t = distance_to_segment(subcrv, seg)", "    if d > d_max:", "        d_max = d", "        t_max = t", "print \"Decomposed curve into\",num_segs,\"segments\"", "print \"Distance to curve = %.3f\" % d_max, \"at t =\",t_max", "", "" ],
          "end" : 64,
          "start" : 49
        },
        "description" : "\nDistance from Curve to PLine\nCompute the maximum distance and the point at which this distance is achieved\n[noprint]\n",
        "end" : 49,
        "start" : 45
      } ],
      "documentation" : {
        "description" : [ "4.03.L02b", "Many curve decomposition algorithms use an approach that recursively splits the curve at the point of maximum", "deviation from the approximation.  This is an example that showcases this general approach, where the maximum", "distance between curve and line segment is used to measure deviation." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Curve Decomposition/4.03.L02b.py",
      "name" : "4.03.L02b.py",
      "references" : {
        "classes" : {
          "Interval" : 3,
          "PLine" : 1,
          "Segment" : 2
        }
      },
      "required" : [ "curve (Curve) The Curve to decompose.", "max_recursion (int) the maximum number of recursive steps", "ideal_distance (float) ideal maximum distance between the approximation and the original Curve" ],
      "result" : [ "ret (PLine)" ]
    },
    "2197b9be-5a67-4cac-b941-16f72d065671" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/packing.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"Creates a Bin object that contains filled areas and open sub-bins.", "        ", "            :param cpt: Corner point", "            :type cpt: Point", "            :param w: Width of Bin", "            :type w: float", "            :param h: Height of Bin", "            :type h: float", "            :param filled: Is this Bin currently filled?", "            :type filled: boolean", "            :param div_type: how to divide Bin object:", "            :               'width' or 'w'  make sub-Bin with largest width", "            :               'height' or 'h' make sub-Bin with largest height", "            :               'area' or 'a'   make sub-Bin with largest area", "            :               'max' or 'x'    make sub-Bin with maximum aspect ratio", "            :               'min' or 'n'    make sub-Bin with minimum aspect ratio", "            :type div_type: string       ", "        \"\"\"", "", "        self.cpt = cpt", "        self.w = w", "        self.h = h", "        self.filled = filled", "        self.div = div_type", "        self.boundary = Bounds(center = Point(cpt.x+w/2.0, cpt.y+h/2.0), dim_x =w, dim_y = h)", "        self.filling = []", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Creates a Bin object that contains filled areas and open sub-bins." ],
          "parameters" : {
            "cpt" : "Corner point\n",
            "div_type" : "how to divide Bin object",
            "filled" : "Is this Bin currently filled?\n",
            "h" : "Height of Bin\n",
            "w" : "Width of Bin\n"
          },
          "types" : {
            "cpt" : "Point\n",
            "div_type" : "string       ",
            "filled" : "boolean\n",
            "h" : "float\n",
            "w" : "float\n"
          }
        },
        "end" : 156,
        "name" : "__init__",
        "start" : 130
      }, {
        "code" : [ "        c = CS(self.cpt - shape.bounds.corners[0])", "        shape.basis = c   ", "        result = [Bin(self.cpt, shape.bounds.dim_x, shape.bounds.dim_y, filled = shape)]", "        rem_x = self.boundary.dim_x - shape.bounds.dim_x", "        rem_y = self.boundary.dim_y - shape.bounds.dim_y", "        if rem_x <= 0: ", "            if rem_y > 0 :result.append(Bin(self.cpt + Vec(0,shape.bounds.dim_y), self.boundary.dim_x, rem_y))", "        elif rem_y <= 0: result.append(Bin(self.cpt + Vec(shape.bounds.dim_x,0), rem_x, self.boundary.dim_y))", "        else:", "            divide_w = False", "            divide_h = False", "            if self.div == 'w' : divide_w = True", "            if self.div == 'h' : divide_h = True", "            if self.div == 'a' :", "                divide_w = ((self.boundary.dim_x * rem_y) > (rem_x * self.boundary.dim_y))", "                divide_h = not(divide_w)", "            if self.div == 'n':", "                divide_w = ((self.boundary.dim_x / rem_y) < (self.boundary.dim_y / rem_x))", "                divide_h = not(divide_w)", "            if self.div == 'x':", "                divide_w = ((self.boundary.dim_x / rem_y) > (self.boundary.dim_y / rem_x))", "                divide_h = not(divide_w)", "            if divide_w :", "                result.append(Bin(self.cpt + Vec(shape.bounds.dim_x,0), rem_x, shape.bounds.dim_y))", "                result.append(Bin(self.cpt + Vec(0,shape.bounds.dim_y), self.boundary.dim_x, rem_y))", "            if divide_h :", "                result.append(Bin(self.cpt + Vec(shape.bounds.dim_x,0), rem_x, self.boundary.dim_y))", "                result.append(Bin(self.cpt + Vec(0,shape.bounds.dim_y), shape.bounds.dim_x, rem_y))", "        self.filling = result", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 187,
        "name" : "put_item",
        "start" : 158
      }, {
        "code" : [ "        #full bin?", "        if len(self.filling) == 0:", "            if (shape.bounds.dim_x <= self.w) and (shape.bounds.dim_y <= self.h): return self", "        else:", "            for i in range(1,len(self.filling)) :", "                result = self.filling[i].can_fit(shape)", "                if  result<> None : return result", "        return None", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 197,
        "name" : "can_fit",
        "start" : 189
      }, {
        "code" : [ "        if isinstance(self.filled, PGon):", "            poly = self.filled", "            poly.set_color(bin_filled)", "            return [poly]", "        if len(self.filling) == 0:", "            e_list = []", "            if bin_edges != None:", "                for i in range(0,4):", "                    e = Segment(self.boundary.corners[i],self.boundary.corners[(i+1)%4])", "                    e.set_color(bin_edges)", "                    e.set_weight(1)", "                    e_list.append(e)", "            return e_list", "        p_list = []", "        for j in range(len(self.filling)) :", "            if bin_edges != None:", "                for i in range(0,4):", "                    e = Segment(self.boundary.corners[i],self.boundary.corners[(i+1)%4])", "                    e.set_color(bin_edges)", "                    e.set_weight(1)", "                    p_list.append(e)", "            p = self.filling[j].get_polygons(bin_filled, bin_edges)", "            if p is not None: p_list.extend(p)", "        return p_list", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 223,
        "name" : "get_polygons",
        "start" : 199
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 223,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "Bin",
      "references" : {
        "classes" : {
          "Bin" : 8,
          "Bounds" : 1,
          "CS" : 1,
          "Color" : 2,
          "PGon" : 1,
          "Point" : 1,
          "Segment" : 2,
          "Vec" : 6
        },
        "functions" : {
          "__init__" : 1,
          "can_fit" : 1,
          "get_polygons" : 1,
          "put_item" : 1
        }
      },
      "start" : 128
    },
    "222695b7-edb6-4648-89bf-5c4d397aa800" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# golden ratio", "TAU = 2 / (1 + math.sqrt(5))", "# powers of golden ratio, used for scaling tiles", "TAU_POW = [TAU**n for n in range(15)]", "", "class DzTile(object):", "        ", "    def __init__(self,**kargs):", "        #lineage, tracks tile types of ancestors", "        self.lineage = kargs[\"lineage\"] if \"lineage\" in kargs else \"RT\" ", "        #recursion level, sets the scale of tiles", "        self.rlvl = kargs[\"rlvl\"] if \"rlvl\" in kargs else 0 ", "        #the spatial transformation of this tile", "        self.xf = kargs[\"xf\"] if \"xf\" in kargs else Xform() ", "        #determines if this tile is mirrored", "        self.flip = kargs[\"flip\"] if \"flip\" in kargs else False", "        ", "    \"\"\"", "    Tile Points Property", "    Retrieves vertices of Danzer tiles in world coordinates", "    \"\"\"", "    @property", "    def tile_pts(self):", "        # a scaling factor based upon this tile's recursion level", "        factor = TAU_POW[self.rlvl]", "        xf_scale = Xform.scale(factor)", "        # return an world-space copy of each base_pt ", "        return map(lambda pt:(pt*xf_scale)*self.xf,self._base_pts)", "        ", "    \"\"\"", "    Child by Two Coordinate Systems", "    Constructs and positions a child tile by matching a CS on this tile with a CS on the desired child tile", "    \"\"\"        ", "    def child_by_explicit(self,name,cs_chld,cs_self,flip):", "        # construct a world-space cs of the desired child tile", "        cs_tile = CS()*Xform.change_basis(cs_chld,cs_self)*self.xf", "        # the transformation from world origin to this cs", "        xf = cs_tile.xform", "        if flip : xf = xf * Xform.mirror()", "        # set the recursion level to one more than this tile", "        rl = self.rlvl + 1", "        # construct the lineage string", "        l = self.lineage+\",\"+name", "        f = flip", "        ", "        # return a child tile of the desired type", "        if name.startswith(\"A\"): return DzTileA(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"B\"): return DzTileB(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"C\"): return DzTileC(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"K\"): return DzTileK(xf=xf,rlvl=rl,lineage=l,flip=f)", "", "    \"\"\"", "    Child by One Coordinate System", "    Constructs and positions a child tile by matching a CS on this tile with the base CS of the desired child tile", "    \"\"\"", "    def child_by_base(self,tile_chld,cs_self,flip):", "        return self.child_by_explicit(tile_chld,CS(),cs_self,flip)", "    ", "    \"\"\"", "    Sibling by Mirroring", "    Constructs a sibling tile of the specified type, positioned by mirroring this tile about a given CS", "    [pseudo]", "    \"\"\"", "    def sibling_by_mirror(self,name,cs_mir):", "        # construct the transformation of the desired child tile by mirroring", "        xf = Xform.mirror(cs_mir) * self.xf", "        # prepare other required arguments by modifying this tile's properties", "        rl = self.rlvl", "        l = self.lineage[:-2]+name", "        f = not self.flip", "        ", "        # return a child tile of the desired type", "        if name.startswith(\"A\"): return DzTileA(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"B\"): return DzTileB(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"C\"): return DzTileC(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"K\"): return DzTileK(xf=xf,rlvl=rl,lineage=l,flip=f)", "        raise", "        ", "    \"\"\"", "    Coordinate System Construction", "    Given the indices of three base points, constructs local- and world-space coordinate systems oriented this tile", "    \"\"\"", "    @classmethod", "    def cs_by_base_pts(cls,rlvl,pt_o,pt_x,pt_y,flip=False):", "        # scale the base points to the proper size for this rlvl", "        factor = TAU_POW[rlvl]", "        pts = [pt*factor for pt in cls._base_pts]", "        ", "        # to orient to flipped tiles, simply invert the apex point", "        if flip : pts[3] = Point(pts[3].x,pts[3].y,-pts[3].z)", "        # construct and return the desired coordinate system", "        return CS(pts[pt_o],pts[pt_x]-pts[pt_o],pts[pt_y]-pts[pt_o])", "", "    def cs_by_tile_pts(self,pt_o,pt_x,pt_y):", "        # construct and return the desired coordinate system", "        pts = self.tile_pts", "        return CS(pts[pt_o],pts[pt_x]-pts[pt_o],pts[pt_y]-pts[pt_o])", "", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @property", "    def to_mesh(self):", "        msh = Mesh()", "        for v in self.tile_pts : msh.append(v)", "        if self.flip : ", "            msh.add_face(0,1,2)", "            msh.add_face(1,3,2)", "            msh.add_face(2,3,0)", "            msh.add_face(3,1,0)", "        else :", "            msh.add_face(0,2,1)", "            msh.add_face(1,2,3)", "            msh.add_face(2,0,3)", "            msh.add_face(3,0,1)", "        return msh", "        " ],
          "end" : 130,
          "start" : 13
        },
        "description" : "\nDanzer Tile Base Class\nDefines a base class from which to derive each child class, and contains methods applicable to all Danzer prototiles\n",
        "end" : 13,
        "start" : 10
      }, {
        "code" : {
          "content" : [ "class DzTileA(DzTile):", "    _base_pts= ( \\", "            Point(0.0, 0.0, 0.0),\\", "            Point(0.9510565, 0.0, 0.0),\\", "            Point(0.6881910 , 1.3763819 , 0.0),\\", "            Point(0.5257311 , 0.6881910, 0.5)\\", "            )", "    \"\"\"", "    Inflation routine for Tile A", "    [pseudo]", "    \"\"\"", "    def inflate(self):", "        #create a child TileB by mapping child pts[2,1,0] to parent pts[0,1,3]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,2,1,0 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,0,1,3 )", "        tileB0 = self.child_by_explicit(\"B0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[1,2,0] to parent pts[3,2,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,1,2,0 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,3,2,1 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[2,3,1] to parent pts[2,0,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,2,3,1, True )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,2,0,1 )", "        tileC1 = self.child_by_explicit(\"C1\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mapping child pts[2,0,3] to parent pts[3,1,0]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,2,0,3, True)", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,3,1,0 )", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK0.cs_by_tile_pts(0,1,3)", "        tileK1 = tileK0.sibling_by_mirror(\"K1\",cs_mir)", "        ", "        #create a child TileB by mapping child pts[2,3,1] to parent pts[0,3,2]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,2,3,1 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,0,3,2 )", "        tileB1 = self.child_by_explicit(\"B1\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        tileB2 = self.child_by_explicit(\"B2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mapping child pts[1,0,2] to parent pts[1,3,2]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,1,0,2, True)", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,1,3,2 )", "        tileK2 = self.child_by_explicit(\"K2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK2.cs_by_tile_pts(0,1,3)", "        tileK3 = tileK2.sibling_by_mirror(\"K3\",cs_mir)", "        ", "        #create two child TileK by mirroring the previous two tiles", "        cs_mir = tileK2.cs_by_tile_pts(0,2,3)", "        tileK4 = tileK2.sibling_by_mirror(\"K4\",cs_mir)##", "        tileK5 = tileK3.sibling_by_mirror(\"K5\",cs_mir)", "        ", "        #return all children", "        return [tileB0,tileC0,tileC1,tileK0,tileK1,tileB1,tileB2,tileK2,tileK3,tileK4,tileK5]", "" ],
          "end" : 187,
          "start" : 134
        },
        "description" : "\nDanzer Tile A Class\nExtends DzTile, and adds methods specific to a Danzer Tile A\n",
        "end" : 134,
        "start" : 131
      }, {
        "code" : {
          "content" : [ "class DzTileB(DzTile):", "    _base_pts= ( \\", "            Point(0.0, 0.0, 0.0),\\", "            Point(0.9510565, 0.0, 0.0),\\", "            Point(0.2628656 , 1.3763819, 0.0),\\", "            Point(0.2628656 , 0.4253254 , 0.3090170)\\", "        )", "    \"\"\"", "    Inflation routine for Tile B", "    [pseudo]", "    \"\"\"", "    def inflate(self):", "        #create a child TileA by mapping child base to parent pts[3,0,1]", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    3,0,1 )", "        tileB0 = self.child_by_base(\"B0\",cs_prnt,not self.flip)    # opposite handdeness as parent", "        #create a child TileA by mapping child base to parent pts[3,0,2]", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    3,0,2 )", "        tileK0 = self.child_by_base(\"K0\",cs_prnt,self.flip)# same handedness as parent", "        #create a child TileK by mapping child pts[1,0,3] to parent pts[0,3,1]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,    1,0,3 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    0,3,1 )", "        tileK1 = self.child_by_explicit(\"K2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create two child TileK by mirroring the previous two tiles", "        cs_mir = tileK0.cs_by_tile_pts(0,2,3)", "        tileK2 = tileK0.sibling_by_mirror(\"K2\",cs_mir)", "        tileK3 = tileK1.sibling_by_mirror(\"K3\",cs_mir)", "        ", "        #create a child TileB by mapping child pts[2,0.1] to parent pts[1,3,2]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,    2,0,1 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    1,3,2 )", "        tileB1 = self.child_by_explicit(\"B1\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[2,1,3] to parent pts[2,0,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,    2,1,3 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    2,0,1 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        ", "        #return all children", "        return [tileB0,tileK0,tileK1,tileK2,tileK3,tileB1,tileC0]", "" ],
          "end" : 230,
          "start" : 191
        },
        "description" : "\nDanzer Tile B Class\nExtends DzTile, and adds methods specific to a Danzer Tile B\n",
        "end" : 191,
        "start" : 188
      }, {
        "code" : {
          "content" : [ "class DzTileC(DzTile):", "    _base_pts= (\\", "            Point(0.0, 0.0, 0.0),\\", "            Point(0.5877853, 0.0, 0.0),\\", "            Point(0.8506509 , 1.3763819, 0.0),\\", "            Point(0.4253254 , 0.6881910 , 0.50 )\\", "        )", "    \"\"\"", "    Inflation routine for Tile C", "    [pseudo]", "    \"\"\"", "    def inflate(self):", "        #create a child TileA by mapping child base to parent pts[0,1,3]", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,    0,1,3 )", "        tileA0 = self.child_by_base(\"A0\",cs_prnt,not self.flip)    # opposite handdeness as parent", "        #create a child TileK by mapping child pts[1,0,2] to parent pts[2,3,1]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,    1,0,2)", "        cs_prnt = DzTileC().cs_by_base_pts(self.rlvl,    2,3,1 )", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK0.cs_by_tile_pts(0,2,3)", "        tileK1 = tileK0.sibling_by_mirror(\"K1\",cs_mir)        ", "        ", "        #create a child TileC by mapping child pts[1,2,0] to parent pts[3,1,2]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,    1,2,0)", "        cs_prnt = DzTileC().cs_by_base_pts(self.rlvl,    3,1,2 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileC by mirroring the previous tile", "        cs_mir = tileC0.cs_by_tile_pts(0,2,3)", "        tileC1 = tileC0.sibling_by_mirror(\"C1\",cs_mir)   ", "        ", "        #return all children", "        return [tileA0,tileK0,tileK1,tileC0,tileC1]", "", "        " ],
          "end" : 269,
          "start" : 234
        },
        "description" : "\nDanzer Tile C Class\nExtends DzTile, and adds methods specific to a Danzer Tile C\n",
        "end" : 234,
        "start" : 231
      }, {
        "code" : {
          "content" : [ "class DzTileK(DzTile):", "    _base_pts= ( \\", "        Point(0.0, 0.0, 0.0),\\", "        Point(0.9510565, 0.0, 0.0),\\", "        Point(0.2628656 , 0.5257311 , 0.0),\\", "        Point(0.2628656 , 0.3440955 , 0.250)\\", "        )", "    \"\"\"", "    Inflation routine for Tile K", "    \"\"\"", "    def inflate(self):", "        #a cs at pts[3,1,0] on child tile", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,3,1,0)", "        #a cs at pts[3,1,0] on parent tile", "        cs_prnt = DzTileK().cs_by_base_pts(self.rlvl,3,0,2)", "        #create a child TileK by mapping cs on child to cs on parent", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,self.flip)", "        ", "        #a cs at pts[2,0,1] on parent tile", "        cs_prnt = DzTileK().cs_by_base_pts(self.rlvl,2,0,1)", "        #create a child TileK by mapping child base to cs on parent", "        tileB0 = self.child_by_base(\"B0\",cs_prnt,self.flip)", "        ", "        #return both children", "        return [tileK0,tileB0]", "        ", "" ],
          "end" : 299,
          "start" : 273
        },
        "description" : "\nDanzer Tile K Class\nExtends DzTile, and adds methods specific to a Danzer Tile K\n",
        "end" : 273,
        "start" : 270
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Danzer Tiling/4.01.L05a.py",
      "name" : "4.01.L05a.py",
      "references" : {
        "classes" : {
          "CS" : 4,
          "DzTile" : 5,
          "DzTileA" : 10,
          "DzTileB" : 11,
          "DzTileC" : 9,
          "DzTileK" : 10,
          "Mesh" : 1,
          "Point" : 17,
          "TAU" : 2,
          "TAU_POW" : 3,
          "Xform" : 5,
          "_base_pts" : 4
        }
      }
    },
    "22a8c7ee-e9db-4876-b2a1-b52815b40d9d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class LTurtle(object):", "    ", "    def __init__(self,instructions):", "        self._pts = [Point()]", "        self._css = [CS()]", "        self.angle = math.pi/4", "        self.step_size = 1.0", "        ", "        # resulting line segments", "        self.segs = []", "        # execute given instructions", "        self.execute(instructions)", "", "    \"\"\"", "    Push and Pop Methods", "    Methods that allow the turtle to branch", "    \"\"\"", "    # adds the current point and coordinate system to lists", "    def push(self):", "        self._pts.append(self.pos)", "        self._css.append(self.frame)", "        ", "    # removes the last point and coordinate system from lists", "    def pop(self):", "        self._pts = self._pts[:-1]", "        self._css = self._css[:-1]", "        ", "    # retrieves the last item from the list of Coordinate Systems", "    @property", "    def frame(self): ", "        return self._css[-1]", "    ", "    # retrieves the last item from the list of positions", "    @property", "    def pos(self): ", "        return self._pts[-1]", "    ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @frame.setter", "    def frame(self,value): ", "        self._css[-1] = value", "    ", "    @pos.setter", "    def pos(self,value): ", "        self._pts[-1] = value", "", "    \"\"\"", "    Execute Instructions", "    Interprets the instruction string, alters this LTurtle's position and orientation accordingly, and updates this LTurtle's history of positions accordingly.", "    \"\"\"", "    def execute(self,inst):", "        # while there are still instructions to execute:", "        while len(inst)>0:", "            chr = inst[0]", "            ", "            # start a new branch if the character is '['", "            if chr == '[': self.push()", "            # go back to the start of this branch if the character is ']'", "            elif chr == ']': self.pop() ", "            ", "            # yaw right", "            elif chr == '-': self.rotate_frame(\"z_axis\")", "            # yaw left", "            elif chr == '+': self.rotate_frame(\"z_axis\",-1)", "            # pitch up", "            elif chr == '^': self.rotate_frame(\"x_axis\",-1)", "            # pitch down", "            elif chr == '&': self.rotate_frame(\"x_axis\")", "            # roll right", "            elif chr == '}': self.rotate_frame(\"y_axis\")", "            # roll left", "            elif chr == '{': self.rotate_frame(\"y_axis\",-1)", "            ", "            # step forward :", "            elif chr == 'F':", "                # draw a segment along the y axis of the current frame", "                nxt_pt = self.pos + (self.frame.y_axis * self.step_size)", "                self.segs.append(Segment(self.pos,nxt_pt))", "                self.pos = nxt_pt", "            ", "            # remove this character and keep going ", "            inst = inst[1:]", "", "    \"\"\"", "    Rotate Frame", "    Applies a rotational transformation to the frame of this LTurtle", "    \"\"\"", "    def rotate_frame(self,axis,angle_mult=1.0):", "        if axis == \"x_axis\" : axis = self.frame.x_axis", "        elif axis == \"y_axis\" : axis = self.frame.y_axis", "        elif axis == \"z_axis\" : axis = self.frame.z_axis", "        angle = self.angle * angle_mult", "        self.frame *= Xform.rotation(axis=axis,angle=angle)" ],
          "end" : 116,
          "start" : 21
        },
        "description" : "\nLTurtle Class\nDefines a 'turtle' agent that is capable of moving about in space in accordance with an interpretation of an instruction string\n",
        "end" : 21,
        "start" : 18
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/LSystem/4.02.L06b.py",
      "name" : "4.02.L06b.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "LTurtle" : 1,
          "Point" : 1,
          "Segment" : 1,
          "Xform" : 1
        }
      }
    },
    "22d0ad95-d1ed-41b2-baa3-4639b9e6c9c2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# setup argument dict for color interpolation", "args = {\"u0v0\":Color(0),\"u0v1\":Color(1,0,0),\"u1v0\":Color(1),\"u1v1\":Color(0)}", "", "def colored_point(x,y):", "    # get u and v values at x,y", "    args['u'] = hist_u[gen].get(x,y)", "    args['v'] = hist_v[gen].get(x,y)", "    ", "    # map the u and v values onto the color space", "    uv_color = Color().interpolate2d(**args)", "    ", "    # create a point and assign it the mapped color", "    pt = Point(x,y,0)", "    pt.set_color(uv_color)", "    return pt", "    ", "# for each x- and y-location in the value fields:", "points = [colored_point(x,y) for x,y in hist_u[0].addresses]" ],
          "end" : 30,
          "start" : 13
        },
        "description" : "\nVisualize Method\nGiven a Grey-Scott object that contains a populated history, creates a set of points representing the state of the model for a given generation\n",
        "end" : 13,
        "start" : 10
      } ],
      "documentation" : {
        "description" : [ "4.02.L01c", "Creates a set of points representing the state of a Grey-Scott model at a given time" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Reaction Diffusion/4.02.L01c.py",
      "name" : "4.02.L01c.py",
      "references" : {
        "classes" : {
          "Color" : 5,
          "Point" : 1
        }
      }
    },
    "241514d1-37f4-4ec0-8712-0a2c0311d3a1" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_danzer.py",
      "definitions" : [ {
        "code" : [ "        #a cs at pts[3,1,0] on child tile", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,3,1,0)", "        #a cs at pts[3,1,0] on parent tile", "        cs_prnt = DzTileK().cs_by_base_pts(self.rlvl,3,0,2)", "        #create a child TileK by mapping cs on child to cs on parent", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,self.flip)", "        ", "        #a cs at pts[2,0,1] on parent tile", "        cs_prnt = DzTileK().cs_by_base_pts(self.rlvl,2,0,1)", "        #create a child TileK by mapping child base to cs on parent", "        tileB0 = self.child_by_base(\"B0\",cs_prnt,self.flip)", "        ", "        #return both children", "        return [tileK0,tileB0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 313,
        "name" : "inflate",
        "start" : 299
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 313,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DzTileK",
      "references" : {
        "classes" : {
          "DzTile" : 1,
          "DzTileK" : 4,
          "Point" : 4,
          "_base_pts" : 1
        },
        "functions" : {
          "inflate" : 1
        }
      },
      "start" : 289
    },
    "24171259-01e9-4b76-b73b-7b91ded5b1ad" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# set the random seed", "random.seed(0)", "# create an Interval with the maximum stock size", "stock_size = Interval(0,size)", "height = stock_size.b/10", "", "strips = []", "# for every number in the number of items:", "for i in range(n):", "    # create a random number and add it to the list", "    strips.append(random.uniform(height,stock_size.b/2))", "    " ],
          "end" : 32,
          "start" : 19
        },
        "description" : "\nGenerates a list of random numbers\n[noprint]\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "", "# create a Strip object with the size of stock", "stock = Strip(stock_size.a, stock_size.b)", "# sort the length of the random length values", "strips.sort(reverse=True)", "# bin the random length values into Strips", "stock_filled = stock.bin_strips(strips, stock_size)", "", "out_list = []", "# for every value in the binned items:", "for j,s in enumerate(stock_filled):", "    # set a y position for the container PGon", "    y = j * height", "    # starting point of the PGon", "    spt = Point(s.boundary.eval(.5), y+height/2.0)", "    # create a PGon for the container with the Strips", "    stock = PGon.rectangle(spt, s.boundary.length, height)", "    # get the items that are packed in the containers", "    lines = s.get_filled()", "    # for every item in the items packed:", "    for line in lines:", "        # starting point of the PGon", "        spt_rect = Point(line.eval(.5), y+height/2.0)", "        # create a PGon representing the packed items", "        rect = PGon.rectangle(spt_rect, line.length, height)" ],
          "end" : 60,
          "start" : 36
        },
        "description" : "\nPack 1D Strips\nGiven a list of random lengths, create a Strip object and pack the items.\n",
        "end" : 36,
        "start" : 33
      } ],
      "documentation" : {
        "description" : [ "4.05.L01b", "Given objects with random lengths, use the Strip class to pack the objects in the least amount of Strips as possible." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01b.py",
      "name" : "4.05.L01b.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "PGon" : 2,
          "Point" : 2,
          "Strip" : 1
        }
      },
      "required" : [ "Strip (Strip) Strip class for packing.", "size (float) Length of material.", "strips ([float]) List of strips to be placed" ],
      "result" : [ "stock (PGon) Rectangles representing the container strips.", "rect (PGon) Rectangles representing the objects being located" ]
    },
    "24d91180-8179-4f24-85ab-2e3815cbf4a9" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Bird():", "    ", "    def __init__(self, pos_start = None, vel_start = None):", "        # ensure this Bird has an initial position and velocity", "        if pos_start is None :  pos_start = Point.random(constrain2d=True)", "        if vel_start is None :  vel_start = Vec.random(constrain2d=True)", "        ", "        # this Bird's position in space", "        self.pos = pos_start ", "        # this Bird's velocity", "        self.vel = vel_start ", "        # an upper limit to this Bird's velocity", "        self.max_vel = 0.5", "        # this Bird's acceleration", "        self.acl = Vec() ", "        # a limit on how much external forces influence this Bird", "        self.max_frc = 0.25", "        self.clear_history()", "        self.record()", "        ", "    \"\"\"", "    Step Method", "    Causes the Bird to move. The position is updated using the current velocity, and the velocity is updated using the current acceleration", "    \"\"\"        ", "    def step(self):", "        # update the acceleration", "        self.vel += self.acl", "        self.vel = self.vel.limited(self.max_vel) ", "        # record the step (note that we record prior to moving)", "        self.record() ", "        # update the position", "        self.pos += self.vel ", "        # reset acceleration back to zero for next step", "        self.acl = Vec() ", "            ", "    \"\"\"", "    Steer Method", "    Provides an interface for influencing the trajectory of this Bird. Subsequent manipulations within any given step are collected in the acceleration vector before being applied to this Bird's velocity. The 'force' of steering will be limited to a constant value.", "    \"\"\"    ", "    def steer(self, vec):", "        # keep the acceleration to within the maximum", "        vec = vec.limited(self.max_frc) ", "        # add the accelation vector", "        self.acl += vec", "        ", "    \"\"\"", "    Reset the Bird to its initial position and values", "    resets this bird back to his initialized condition.", "    replaces existing history lists with single inital values", "    [noprint]", "    \"\"\"    ", "    def reset(self):", "        self.is_alive = True", "        if len(self.hist_pos) > 0:", "            self.pos = self.hist_pos[0]", "            self.vel = self.hist_vel[0]", "            self.acl = self.hist_acl[0]", "        self.clear_history()", "        self.record()", "        ", "    \"\"\"", "    Clear and Record Methods", "    Clear the history and records a step", "    [noprint]", "    \"\"\"    ", "    # clear the position, velocity and acceleration histories", "    def clear_history(self):", "        self.hist_pos = []", "        self.hist_vel = []", "        self.hist_acl = []", "        ", "    # record this step ", "    def record(self):", "        # add position, velocity and acceleration to history", "        self.hist_pos.append(self.pos)", "        self.hist_vel.append(self.vel)", "        self.hist_acl.append(self.acl)" ],
          "end" : 101,
          "start" : 25
        },
        "description" : "\nA Simple Bird Class\nDefines an agent with position, velocity, acceleration vectors, and a history that tracks where this Bird has been.\n",
        "end" : 25,
        "start" : 22
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Birds/4.02.L05a.py",
      "name" : "4.02.L05a.py",
      "references" : {
        "classes" : {
          "Bird" : 1,
          "Point" : 1,
          "Vec" : 3
        }
      }
    },
    "2563cc37-4c63-404f-a848-b029768407c2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "x_rays, y_rays, z_rays = [],[],[]", "for pt in pts:", "    vec_x = Vec(pt,attr_pt).normalized()", "    vec_y = vec_x.cross(Vec(0,0,1)).normalized()", "    vec_z = vec_x.cross(vec_y).normalized()", "    ", "    x_rays.append(Ray(pt,vec_x))", "    y_rays.append(Ray(pt,vec_y))", "    z_rays.append(Ray(pt,vec_z))", "    " ],
          "end" : 24,
          "start" : 15
        },
        "description" : "\nField of Frames\nConstructs a frame at each point in the plane responding to an attractor\n",
        "end" : 15,
        "start" : 12
      } ],
      "documentation" : {
        "description" : [ "3.02.E01a", "todo" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/Cross Products/3.02.E01a.py",
      "name" : "3.02.E01a.py",
      "references" : {
        "classes" : {
          "Ray" : 3,
          "Vec" : 2
        }
      },
      "required" : [ "pt (Point)- needs to be in the x-y plane", "attr_pt (Point) - can be any point in 3D" ]
    },
    "27fd5906-6750-49c0-bc6e-b0b63f91c529" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "    " ],
          "end" : 21,
          "start" : 20
        },
        "description" : "\nAmmann A3\nhttp://tilings.math.uni-bielefeld.de/substitution_rules/ammann_a3\n[noprint]\n",
        "end" : 20,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "", "#constants for scaling between generations", "TAU = (1 + math.sqrt(5)) / 2   ", "TAU_2 = TAU**2", "TAU_3 = TAU**3", "", "class AmmannA3Tile(object):", "    ", "    def __init__(self,xf=Xform(), lineage=\"RT\",scale=None):", "        self.lineage = lineage", "        #used to translate and scale at each inflation", "        self.xf = xf", "        self._xf_scale = Xform.scale(1/TAU) #0.618033", "        #the current scale of this tile", "        self.scale = scale", "    ", "    \"\"\"", "    Coordinate System Construction", "    Given indices referring to this tile's base points, returns a coordinate system in local space.", "    [noprint]", "    \"\"\"", "    def _cs_from_base_pts(self,pt_o=0,pt_x=1,pt_y=2):", "        #refers to the index of the origin of our CS", "        pt_0 = self._base_pts[pt_o]", "        #refers to the index a point on the x-axis", "        pt_x = self._base_pts[pt_x]-self._base_pts[pt_o]", "        #refers to the index a point on the y-axis", "        pt_y = self._base_pts[pt_y]-self._base_pts[pt_o]", "        return CS(pt_0, pt_x, pt_y)", "    ", "    \"\"\"", "    Tile Points", "    Returns the vertices of this tile in world coordinates.", "    [noprint]", "    \"\"\"", "    # world base Points for this tile", "    @property", "    def tile_pts(self):", "        return [p*self.xf for p in self._base_pts]", "        ", "    # draw a PGon from the Points", "    def to_pgon(self):", "        pg = PGon(self.tile_pts[:self.boundary_base_pt_cnt])", "        pg.name = self.lineage", "        return pg    ", "        " ],
          "end" : 71,
          "start" : 25
        },
        "description" : "\nAmmann A3 Prototile Class\nDefines a class that encapsulates methods for producing an Ammann A3 tiling\n",
        "end" : 25,
        "start" : 22
      }, {
        "code" : {
          "content" : [ "class AmmannA3TileA(AmmannA3Tile):", "    # the idealized base Points for all Tiles of type A", "    @property", "    def _base_pts(self):", "        return [ \\", "            Point(0.0, 0.0),\\", "            Point(TAU_3, 0.0),\\", "            Point(TAU_3, TAU_2),\\", "            Point(TAU_3-TAU_2, TAU_2),\\", "            Point(TAU_3-TAU_2, TAU),\\", "            Point(0, TAU)\\", "            ]", "", "    \"\"\"", "    Inflation Method for Tile A", "    Inflates this tile and returns a list of smaller tiles", "    \"\"\"        ", "    def inflate(self):", "        #a transformation from this tile to the 1st child tile", "        xf_pos = self._cs_from_base_pts(0,1,5).xform", "        #create a scaled TileB at the designated position ", "        b0=AmmannA3TileB(self.xf * xf_pos * self._xf_scale,self.lineage+\",b0\")", "        ", "        #a transformation from this tile to the 2nd child tile", "        xf_pos = self._cs_from_base_pts(1,2,0).xform", "        #create a scaled TileA at the designated position ", "        a0=AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a0\")", "        ", "        #return all child tiles", "        return [b0,a0]", "        ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @property", "    def boundary_base_pt_cnt(self): return 6", "" ],
          "end" : 112,
          "start" : 75
        },
        "description" : "\nAmman Tile A Class\nExtends AmmanA3Tile, and adds methods specific to an Ammann tile A\n",
        "end" : 75,
        "start" : 72
      }, {
        "code" : {
          "content" : [ "class AmmannA3TileB(AmmannA3Tile):", "    #returns the ideal base points specific to Amman B Tiles", "    @property", "    def _base_pts(self):", "        #explicitly define each point in sequence, and return ordered list", "        return [ \\", "            Point(0.0, 0.0),\\", "            Point(TAU_2-TAU,0),\\", "            Point(2*TAU_2-(TAU+1), 0.0),\\", "            Point(2*TAU_2, 0.0),\\", "            Point(2*(TAU_2), TAU),\\", "            Point((2*(TAU_2))-1, TAU),\\", "            Point((2*(TAU_2))-1, TAU+TAU_2),\\", "            Point((2*(TAU_2))-1-TAU, TAU+TAU_2),\\", "            Point((2*(TAU_2))-1-TAU, TAU_2),\\", "            Point(TAU_2-TAU, TAU_2),\\", "            Point(0, TAU_2),\\", "            Point(0,TAU),\\", "            Point(TAU_2+TAU-1, TAU_2)\\", "            ]", "            ", "    \"\"\"", "    Inflation Method for Tile B", "    Inflates this tile and returns a list of smaller tiles", "    [pseudo]", "    \"\"\"       ", "    def inflate(self):", "        #create a child TileA from base_pts [10,0,9]", "        xf_pos = self._cs_from_base_pts(10,0,9).xform", "        a0 = AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a0\")", "        #create a child TileA from base_pts [2,3,8]", "        xf_pos = self._cs_from_base_pts(2,3,8).xform", "        a1 = AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a1\")", "         #create a child TileA from base_pts [5,6,11]", "        xf_pos = self._cs_from_base_pts(5,6,11).xform", "        a2 = AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a2\")", "         #create a child TileC from base_pts [12,10,1]", "        xf_pos = self._cs_from_base_pts(12,10,1).xform", "        c0 = AmmannA3TileC(self.xf * xf_pos * self._xf_scale,self.lineage+\",c0\")", "        ", "        #return all child tiles", "        return [a0,a1,a2,c0]", "        ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @property", "    def boundary_base_pt_cnt(self): return 11", "" ],
          "end" : 166,
          "start" : 117
        },
        "description" : "\nAmman Tile B Class\nExtends AmmanA3Tile, and adds methods specific to an Ammann tile B\n[pseudo]\n",
        "end" : 117,
        "start" : 113
      }, {
        "code" : {
          "content" : [ "class AmmannA3TileC(AmmannA3Tile):", "    ", "    #returns the ideal base points specific to Amman C Tiles", "    @property", "    def _base_pts(self):", "        #explicitly define each point in sequence, and return ordered list", "        return [ \\", "            Point(1+TAU_2, 0.0),\\", "            Point(1+TAU_2, TAU),\\", "            Point((1+TAU_2)-1, TAU),\\", "            Point((1+TAU_2)-1, TAU+TAU_2),\\", "            Point((1+TAU_2)-1-TAU, TAU+TAU_2),\\", "            Point((1+TAU_2)-1-TAU, TAU+1),\\", "            Point(1-TAU, TAU+1),\\", "            Point(1-TAU, TAU),\\", "            Point(0, TAU),\\", "            Point(0.0, 0.0),\\", "            Point((1+TAU_2)-(TAU+1),0),\\", "            Point((1+TAU_2)-(TAU+1)+(TAU-1),TAU+1)\\", "                ]", "                ", "    \"\"\"", "    Inflation Method for Tile C", "    Inflates this tile and returns a list of smaller tiles", "    [pseudo]", "    \"\"\"       ", "    def inflate(self):", "        #create a child TileA from base_pts [10,0,5]", "        xf_pos = self._cs_from_base_pts(10,0,5).xform", "        a0 = AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a0\")", "        #create a child TileA from base_pts [2,3,7]", "        xf_pos = self._cs_from_base_pts(2,3,7).xform", "        a1 = AmmannA3TileA(self.xf * xf_pos * self._xf_scale,self.lineage+\",a1\")", "        #create a child TileC from base_pts [11,5,10]", "        xf_pos = self._cs_from_base_pts(11,5,10).xform", "        c0 = AmmannA3TileC(self.xf * xf_pos * self._xf_scale,self.lineage+\",c0\")", "        ", "        #return all child tiles", "        return [a0,a1,c0]", "        ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @property", "    def boundary_base_pt_cnt(self): return 10", "    ", "", "" ],
          "end" : 218,
          "start" : 171
        },
        "description" : "\nAmman Tile C Class\nExtends AmmanA3Tile, and adds methods specific to an Ammann tile C\n[pseudo]\n",
        "end" : 171,
        "start" : 167
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Tiling by Inflation/4.01.L04c.py",
      "name" : "4.01.L04c.py",
      "references" : {
        "classes" : {
          "AmmannA3Tile" : 4,
          "AmmannA3TileA" : 7,
          "AmmannA3TileB" : 2,
          "AmmannA3TileC" : 3,
          "CS" : 1,
          "PGon" : 1,
          "Point" : 31,
          "TAU" : 33,
          "TAU_2" : 31,
          "TAU_3" : 5,
          "Xform" : 2
        }
      }
    },
    "28d8204f-be17-4d22-880b-001e71503ebf" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "PHI = 0.69126979252", "def fib_pt(theta):", "    r = PHI**theta", "    return CS().eval_cyl(r,theta)", "" ],
          "end" : 20,
          "start" : 15
        },
        "description" : "\n[noprint]\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "pl_ccw = PLine()", "ival_theta = Interval(0,math.pi*2*turns)", "for theta in ival_theta.divide(segs_per_turn,True):", "    pt = fib_pt(theta) * radius", "    pt.z = height * ival_theta.deval(theta)**falloff", "    pl_ccw.append(pt)", "    ", "" ],
          "end" : 32,
          "start" : 24
        },
        "description" : "\nConstructs a 3d Golden Spiral (a Golden Helix, perhaps?) as a polyline.\n[noprint]\n",
        "end" : 24,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "xf = Xform.mirror(\"world_xz\")", "pl_cw = PLine([p*xf for p in pl_ccw.pts])", "pl_join = pl_cw.join(pl_ccw)", "" ],
          "end" : 38,
          "start" : 35
        },
        "description" : "\nConstructs a new Polyline by mirroring the existing one about the world xz plane, and joining the result.\n",
        "end" : 35,
        "start" : 33
      } ],
      "documentation" : {
        "description" : [ "3.08.E01a", "Create a Polyline from a golden spiral" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/ Manipulating Bases/3.08.E01a.py",
      "name" : "3.08.E01a.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 1,
          "PHI" : 2,
          "PLine" : 2,
          "Xform" : 1
        }
      },
      "required" : [ "todo" ],
      "result" : [ "todo" ]
    },
    "29ba5ec5-6718-442e-8d65-60e626216c50" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/cellular_automata.py",
      "definitions" : [ {
        "code" : [ "        self.width = int(pixel_res.a)", "        self.height = int(pixel_res.b)", "        self.clear(include_corners,wrap)", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 11,
        "name" : "__init__",
        "start" : 8
      }, {
        "code" : [ "        x,y = self._reframe(x,y)", "        self.cells.set(x,y,val)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 15,
        "name" : "set_cell",
        "start" : 13
      }, {
        "code" : [ "        for n, bool in enumerate(initial_cell):", "            self.cells._pixels[n] = bool", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 20,
        "name" : "set_cells",
        "start" : 18
      }, {
        "code" : [ "        self.rule = func", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 26,
        "name" : "set_rule",
        "start" : 25
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 28,
        "name" : "get_cell",
        "start" : 28
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 30,
        "name" : "get_cells",
        "start" : 30
      }, {
        "code" : [ "        while x > self.width -1 : x = x - self.width", "        while y > self.height -1: y = y - self.height", "        while x < 0 : x = self.width + x", "        while y < 0 : y = self.height + y", "        return x,y", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 37,
        "name" : "_reframe",
        "start" : 32
      }, {
        "code" : [ "        self.cells = BoolField(Interval(self.width,self.height),wrap,include_corners)", "        self.step_count = 0", "        self.hist = []", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 42,
        "name" : "clear",
        "start" : 39
      }, {
        "code" : [ "        self.hist.append(self.cells)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 45,
        "name" : "record",
        "start" : 44
      }, {
        "code" : [ "        nxt_cells = BoolField(Interval(self.width,self.height),self.cells.wrap,self.cells.include_corners)", "        t = max(min(1.0,t),0.0)", "        for x in range(0,self.width):", "            for y in range(0,self.height):", "                cur_cell = self.cells.get(x,y)", "                neighbor_cells = self.cells.neighbors_of(x,y)", "                nxt_cell = self.rule(cur_cell, neighbor_cells)", "                nxt_cells.set(x,y,nxt_cell)", "        self.cells = nxt_cells", "        self.step_count += 1", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 59,
        "name" : "step",
        "start" : 49
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 59,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/cellular_automata.py",
      "name" : "CA",
      "references" : {
        "classes" : {
          "BoolField" : 2,
          "CA" : 1,
          "Interval" : 3
        },
        "functions" : {
          "__init__" : 1,
          "_reframe" : 1,
          "clear" : 1,
          "get_cell" : 1,
          "get_cells" : 1,
          "record" : 1,
          "set_cell" : 1,
          "set_cells" : 1,
          "set_rule" : 1,
          "step" : 1
        }
      },
      "start" : 6
    },
    "2b98b12f-989b-4d5a-91d8-e9915f0d7bb3" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "definitions" : [ {
        "code" : [ "        return abs(a-b) < self.epsilon", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 24,
        "name" : "appx_eq",
        "start" : 23
      }, {
        "code" : [ "        \"\"\" Overloads the multiplication **(*)** operator.", "", "            :param other: Geometry to be multiplied.", "            :type other: Geometry", "            :result: New geometry.", "            :rtype: Geometry", "        \"\"\"", "        from .dc_xform import Xform", "        if isinstance(other, Xform) :", "            return other*self" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the multiplication **(*)** operator." ],
          "parameters" : {
            "other" : "Geometry to be multiplied.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "New geometry.\n",
          "types" : {
            "other" : "Geometry\n"
          }
        },
        "end" : 35,
        "name" : "__mul__",
        "start" : 26
      }, {
        "code" : [ "        \"\"\" Transfers the properties of the other geometry to this geometry, overwriting any properties this object currently has\"\"\"", "        new_props = {}", "        if hasattr(other, 'props') : new_props = other.props", "        self.props = new_props", "        return new_props", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Transfers the properties of the other geometry to this geometry, overwriting any properties this object currently has" ]
        },
        "end" : 43,
        "name" : "copy_props",
        "start" : 38
      }, {
        "code" : [ "        \"\"\" Sets the geometry's color", "", "            :param a: Color object to set the geometry's color, or number value (between 0 and 1) to create a new color. If only a is passed as a float, the color will be grayscale.", "            :type a: Color or float", "            :param b: If no color object is passed, the G value in an RGB scale.", "            :type b: float", "            :param c: If no color object is passed, the B value in an RGB scale.", "            :type c: float", "            :result: Sets the geometry's color.", "            :rtype: Geometry", "        \"\"\"", "        from .dc_color import Color", "        if not hasattr(self, 'props') : self.props = {}", "        if isinstance(a, (Color) ) : self.props['color'] = a", "        else : self.props['color'] = Color(a,b,c)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Sets the geometry's color" ],
          "parameters" : {
            "a" : "Color object to set the geometry's color, or number value (between 0 and 1) to create a new color. If only a is passed as a float, the color will be grayscale.\n",
            "b" : "If no color object is passed, the G value in an RGB scale.\n",
            "c" : "If no color object is passed, the B value in an RGB scale.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "Sets the geometry's color.\n",
          "types" : {
            "a" : "Color or float\n",
            "b" : "float\n",
            "c" : "float\n"
          }
        },
        "end" : 60,
        "name" : "set_color",
        "start" : 46
      }, {
        "code" : [ "        \"\"\" Gets the geometry's color", "", "            :result: Gets the geometry's color.", "            :rtype: Color", "        \"\"\"", "        # TODO: test if object has props", "        # TODO: test if props dict contains entry for color", "        if hasattr(self, 'props') : return self.props['color']", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Gets the geometry's color" ],
          "rtype" : "Color",
          "rvalue" : "Gets the geometry's color.\n"
        },
        "end" : 72,
        "name" : "get_color",
        "start" : 63
      }, {
        "code" : [ "        \"\"\" Sets the geometry's name.", "", "            :param str: A str with the new geometry's name.", "            :type str: str", "            :result: Sets the geometry's name.", "            :rtype: str", "        \"\"\"", "        if not hasattr(self, 'props') : self.props = {}", "        self.props['name'] = str", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Sets the geometry's name." ],
          "parameters" : {
            "str" : "A str with the new geometry's name.\n"
          },
          "rtype" : "str",
          "rvalue" : "Sets the geometry's name.\n",
          "types" : {
            "str" : "str\n"
          }
        },
        "end" : 83,
        "name" : "set_name",
        "start" : 74
      }, {
        "code" : [ "        \"\"\" Sets the geometry's weight.", "", "            :param num: A number with the new geometry's weight.", "            :type num: float", "            :result: Sets the geometry's weight.", "            :rtype: float", "        \"\"\"", "        if not hasattr(self, 'props') : self.props = {}", "        self.props['weight'] = num", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Sets the geometry's weight." ],
          "parameters" : {
            "num" : "A number with the new geometry's weight.\n"
          },
          "rtype" : "float",
          "rvalue" : "Sets the geometry's weight.\n",
          "types" : {
            "num" : "float\n"
          }
        },
        "end" : 94,
        "name" : "set_weight",
        "start" : 85
      }, {
        "code" : [ "        \"\"\" Sets the geometry's fill.", "", "            :param a: Color object to set the geometry's fill, or number value (between 0 and 1) to create a new color. If only a is passed as a float, the color will be grayscale.", "            :type a: Color or float", "            :param b: If no color object is passed, the G value in an RGB scale.", "            :type b: float", "            :param c: If no color object is passed, the B value in an RGB scale.", "            :type c: float", "            :result: Sets the geometry's fill.", "            :rtype: Geometry", "        \"\"\"", "        from .dc_color import Color", "        if not hasattr(self, 'props') : self.props = {}", "        if isinstance(a, (Color) ) : self.props['fill'] = a", "        else : self.props['fill'] = Color(a,b,c)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Sets the geometry's fill." ],
          "parameters" : {
            "a" : "Color object to set the geometry's fill, or number value (between 0 and 1) to create a new color. If only a is passed as a float, the color will be grayscale.\n",
            "b" : "If no color object is passed, the G value in an RGB scale.\n",
            "c" : "If no color object is passed, the B value in an RGB scale.\n"
          },
          "rtype" : "Geometry",
          "rvalue" : "Sets the geometry's fill.\n",
          "types" : {
            "a" : "Color or float\n",
            "b" : "float\n",
            "c" : "float\n"
          }
        },
        "end" : 110,
        "name" : "set_fill",
        "start" : 96
      }, {
        "code" : [ "    def do_translate(self):", "        \"\"\" If this property is set to false, outies will not translate this geometry into external formats, and pass along the class as-is.", "        \"\"\"", "        return True", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "If this property is set to false, outies will not translate this geometry into external formats, and pass along the class as-is." ]
        },
        "end" : 118,
        "name" : "do_translate",
        "start" : 114
      }, {
        "code" : [ "    def xform(self): ", "        #TODO: i think these are obsolete", "        return self.objCS.xform", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 123,
        "name" : "xform",
        "start" : 120
      }, {
        "code" : [ "    def ixform(self): ", "        #TODO: i think these are obsolete", "        return self.objCS.ixform", " " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 128,
        "name" : "ixform",
        "start" : 125
      } ],
      "documentation" : {
        "description" : [ "A base geometry class for all other geometry to inherit." ],
        "images" : {
          "1&12&E04a-1&png" : "test image 2\n",
          "1&12&E04a-2&png" : "test image 2"
        }
      },
      "end" : 128,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "Geometry",
      "references" : {
        "classes" : {
          "Color" : 4,
          "Geometry" : 1,
          "Xform" : 1
        },
        "functions" : {
          "__mul__" : 1,
          "appx_eq" : 1,
          "copy_props" : 1,
          "do_translate" : 1,
          "get_color" : 1,
          "ixform" : 1,
          "set_color" : 1,
          "set_fill" : 1,
          "set_name" : 1,
          "set_weight" : 1,
          "xform" : 1
        }
      },
      "start" : 16
    },
    "2bea037c-4b30-4924-abc8-5f0bedd0cc39" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def maze_rules(cur_val,nei_vals): ", "    count = sum(nei_vals) #sums all True cells in the neighborhood", "    # if three True neighbours, turn on", "    if count == 3 : return True", "    # if more than four True neighbours, turn off", "    elif count > 4: return False", "    # in all other cases, do not alter this cell", "    else: return cur_val", "    ", "    " ],
          "end" : 26,
          "start" : 16
        },
        "description" : "\nMaze Rules Function\nEvaluate cell status to create a maze, based on algorithm published by Kostas Terzidis,\"Algorithms for Visual Design\", pp. 168-171\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "", "def life_rules(cur_val,nei_vals):", "    count = sum(nei_vals) #sums all True cells in the neighborhood", "    # if this cell is True:", "    if cur_val:", "        # if we have 2 or 3 neighbors, stay alive - otherwise, die!", "        if count == 2 or count == 3: return True", "        return False", "    # if this cell is False:", "    else:", "        # if we have 3 neighbors, be born - otherwise, stay dead!", "        if (count == 3): return True", "        return False", "        ", "        " ],
          "end" : 45,
          "start" : 30
        },
        "description" : "\nLife Rules Function\nEvaluate cell status to play Conway's Game of Life\n",
        "end" : 30,
        "start" : 27
      }, {
        "code" : {
          "content" : [ "", "def vichniac_rules(cur_val,nei_vals):", "    #sums all True cells in the neighborhood and self", "    count = sum(nei_vals) + cur_val", "    if count > 4 : return True", "    return False", "" ],
          "end" : 55,
          "start" : 49
        },
        "description" : "\nVichniac's Vote Rule Function\nEvaluate cell status according to Vichniac's Vote Rule\n",
        "end" : 49,
        "start" : 46
      } ],
      "documentation" : {
        "description" : [ "4.02.L02c", "Sample functions for use with the CA class" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Cellular Automata/4.02.L02c.py",
      "name" : "4.02.L02c.py",
      "required" : [ "cur_val (boolean) The value of the home cell", "nei_vals (list of booleans) The values of the neighboring cells" ],
      "result" : [ "nxt_val(boolean) The updated value for the home cell" ]
    },
    "2c190cc8-7f03-4b5e-8cf4-bb2299ea1b44" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "" ],
          "end" : 27,
          "start" : 26
        },
        "description" : "\n# according to Radin, the Pinwheel tiling contains one prototile \n# a triangle with the following edge lenghts: 1, 2, sqrt(5)\n# (http://www.ma.utexas.edu/users/radin/papers/pinwheel.pdf)\n# (http://www.michaelwhittaker.ca/fractalpinwheel.pdf)\n# some nice variation (color) here: http://tilings.math.uni-bielefeld.de/substitution_rules/pinwheel_1_2_0\n[noprint]\n",
        "end" : 26,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "", "#a constant for scaling between generations", "XF_SCALE = Xform.scale(1/math.sqrt(5))", "", "class PinwheelTile(object):", "    def __init__(self,xf=Xform(), lineage=\"RT\"):", "        self.lineage = lineage", "        self.xf = xf", "", "        # the idealized base Points for all Pinwheel tiles", "        self._base_pts= [\\", "            Point(),\\", "            Point(2.0, 0.0),\\", "            Point(0.0, 1.0),\\", "            Point(0.2, 0.4),\\", "            Point(1.2, 0.4),\\", "            Point(0.4, 0.8),\\", "            Point(1.0, 0.0),\\", "        ]", "", "        \"\"\"", "        [noprint]", "        \"\"\"", "        # sets base colors for Pinwheel tiles", "        self._colors=[\\", "            Color(0.41,0.34,0.13),\\", "            Color(0.76,0.63,0.24),\\", "            Color(0.11,0.22,0.41),\\", "            Color(0.25,0.43,0.71),\\", "            Color(1.00,0.25,0.25),\\", "        ]", "                      ", "    \"\"\"", "    Tile Points Property", "    Returns the vertices of this tile in world coordinates", "    \"\"\"", "    @property", "    def tile_pts(self):", "        #transform each base point by the xform of this tile", "        return [p*self.xf for p in self._base_pts]", "        ", "    \"\"\"", "    Coordinate System Construction Method", "    Returns a coordinate system in local space given indices referring to this tile's base points", "    \"\"\"", "    def _cs_from_base_pts(self,pt_o=0,pt_x=1,pt_y=2):", "        #select the CS origin from our list of base_pts", "        pt_0 = self._base_pts[pt_o]", "        #construct vectors describing the desired x and y-axes", "        vec_x = Vec(pt_0,self._base_pts[pt_x])", "        vec_y = Vec(pt_0,self._base_pts[pt_y])", "        #construct and return the desired CS", "        return CS(pt_0, vec_x, vec_y)", "     ", "    \"\"\"", "    Inflation Method", "    Inflates this PinwheelTile and returns a list of smaller tiles.", "    \"\"\"", "    def inflate(self):", "        #a transformation from this tile to the 1st child tile", "        xf_pos = self._cs_from_base_pts(3,6,5).xform", "        #create a scaled child tile at the designated position ", "        tile0 = PinwheelTile(self.xf * xf_pos * XF_SCALE,self.lineage+\",0\")", "                                  ", "        #create a child tile from base_pts [4,5,6]", "        xf_pos = self._cs_from_base_pts(4,5,6).xform", "        tile1 = PinwheelTile(self.xf * xf_pos * XF_SCALE,self.lineage+\",1\")", "        #create a child tile from base_pts [3,6,0]", "        xf_pos = self._cs_from_base_pts(3,6,0).xform", "        tile2 = PinwheelTile(self.xf * xf_pos * XF_SCALE,self.lineage+\",2\")", "        #create a child tile from base_pts [5,0,2]", "        xf_pos = self._cs_from_base_pts(5,0,2).xform ", "        tile3 = PinwheelTile(self.xf * xf_pos * XF_SCALE,self.lineage+\",3\")", "        #create a child tile from base_pts [4,1,6]", "        xf_pos = self._cs_from_base_pts(4,1,6).xform", "        tile4 = PinwheelTile(self.xf * xf_pos * XF_SCALE,self.lineage+\",4\")", "        ", "        #return all child tiles", "        return [tile0,tile1,tile2,tile3,tile4]", "        ", "    \"\"\"", "    Misc", "    Assorted methods, including one for creating a mesh from this PinwheelTile's vertices.", "    [noprint]", "    \"\"\"   ", "    ", "    def to_pgon(self):", "        pts = [self._base_pts[0],self._base_pts[1],self._base_pts[2]]", "        return PGon([pt * self.xf for pt in pts])        ", "        ", "    # create a mesh from the vertices of a tile", "    def to_mesh(self, color=None, pc_inheritance=0.5):", "        # if the tile is not colored yet:", "        if color is None :", "            # get a Color based on its lineage", "            clr_list = self._lineage_to_colors()", "            try:", "                clr_list.reverse()", "                color = clr_list[0]", "                # for every Color of the list: ", "                for parent_color in clr_list[1:]:", "                    # get and interpolated value for them ", "                    color = Color.interpolate(color,parent_color,pc_inheritance)", "            except:", "                color = clr_list", "                ", "        # draw a Mesh with the Points", "        msh = Mesh()", "        msh.append(self._base_pts[0] * self.xf)", "        msh.append(self._base_pts[1] * self.xf)", "        msh.append(self._base_pts[2] * self.xf)", "        msh.add_face(0,1,2)", "        msh.set_name(self.lineage)", "        msh.set_color(color)", "        return msh", "    ", "    # returns the centroid of this tile", "    @property", "    def centroid(self): ", "        return Point.centroid(self.tile_pts)", "    ", "    def _lineage_to_colors(self):", "        lin = self.lineage.split(',')", "        if len(lin)==0 : return Color()", "        return [self._colors[int(str)] for str in lin[1:]]", "    ", "" ],
          "end" : 157,
          "start" : 31
        },
        "description" : "\nPinwheel Prototile Class\nDefines a Pinwheel Tiling class\n",
        "end" : 31,
        "start" : 28
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Tiling by Inflation/4.01.L04a.py",
      "name" : "4.01.L04a.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Color" : 7,
          "Mesh" : 1,
          "PGon" : 1,
          "PinwheelTile" : 6,
          "Point" : 8,
          "Vec" : 2,
          "XF_SCALE" : 6,
          "Xform" : 2
        }
      }
    },
    "2e62cc75-1d82-46d1-9821-d6e099eb1516" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# initialize an empty container for the Points", "pts = []", "# for every ri value in an Interval:", "for ri in Interval(.5,1).divide(res,include_last=True):", "    # for every gi value in an Interval:", "    for gi in Interval(.5,1).divide(res,include_last=True):", "        # if the gi value is 0: make it a small number", "        if gi == 0: gi = 0.001", "        # for every bi value in an Interval:", "        for bi in Interval().divide(res,include_last=True):", "            # create a Surface from those three values", "            surf = make_surf(ri,gi,bi)", "            # check the fitness of the current Surface", "            fit = fitness(surf)", "            clr = Color(ri,gi,bi) # surface color", "            # if the value is smaller than the best_fit:", "            if fit <= best_fit:", "                # the best fit is now the current", "                best_fit = fit", "                # create a Mesh from the Surface", "                best_msh = Surface(surf).surrogate", "                best_msh.set_color(clr)", "                # Create a translation with the current location", "                xf = Xform.translation(Vec(ri,gi,bi)-Vec())", "                # create a Point with the current location", "                pt = Point(ri,gi,bi)", "                # translate the Point", "                new_pt = pt * xf", "                pts.append(new_pt)", "                # translate the Mesh", "                best_msh = best_msh *xf " ],
          "end" : 50,
          "start" : 20
        },
        "description" : "\nGreedy Floor-to-Facade Area Optimization\nPerform a directed fitness search, by checking neighboring fitness value and translating in the direction of the best fit, and visualize the results\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.07.L02d", "Given a fitness function and a step size, perform a directed search, by checking neighboring facade area to floor area ratios and moving in the direction of best fit. Create a path representing search history." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Floor-Facade Area Optimization/4.07.L02d.py",
      "name" : "4.07.L02d.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Interval" : 3,
          "Point" : 1,
          "Surface" : 1,
          "Vec" : 2,
          "Xform" : 1
        }
      },
      "required" : [ "fitness (function) Function to calculate floor / facade area fitness.", "make_surf (function) A function that makes surfaces.", "res (int) Resolution of the solution space grid to compute.", "best_fit (float) Threshold for the best fit value." ],
      "result" : [ "pts ([Point]) Seach path for the best fit Surface.", "best_msh (Mesh) The best fit Surface.", "best_fit (float) The best fit value." ]
    },
    "3089a4b5-dbe1-47f9-aa18-de55c3f3fa22" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def factor(pt,attractor):", "    factor = (pt.distance(attractor))/force", "    # make sure the factor is at least zero", "    if factor < 0 : factor = 0.0", "    # make sure the factor is no larger than one", "    if factor > 1 : factor = 1.0", "    return factor" ],
          "end" : 27,
          "start" : 20
        },
        "description" : "\nFactor Function\nReturn a value based on the distance of a point from an attractor\n[noprint]\n",
        "end" : 20,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def get_s(i, length,attractor):", "    # set an s-vector based on a segment emanating from the node", "    s_vec = segs[i].vec.inverted()", "\t# scale it by a factor of distance to an attractor point", "    s_vec.length = factor(segs[i].spt,attractor)", "    # translate the spt of the segment by the scaled vector", "    return segs[i].spt + s_vec", "    " ],
          "end" : 39,
          "start" : 31
        },
        "description" : "\nBase Point Function\nCreate base points for the center tetrahedron of our component\n",
        "end" : 31,
        "start" : 28
      }, {
        "code" : {
          "content" : [ "def get_e(i, length):", "    # translate in the z-direction", "    e0 = segs[i].ept + Vec(0,0,length)", "\t# compute a vector perpendicular to the line segment", "    cross = segs[i].vec.cross(Vec(0,0,1))", "    cross.length = length", "    inv_cross = cross.inverted()", "\t# translate in the direction of this perpendicular vector", "    e1 = segs[i].ept + cross", "    # translate in the direction opposite of this perpendicular vector", "    e2 = segs[i].ept + inv_cross", "    return [e0,e1,e2]", " " ],
          "end" : 56,
          "start" : 43
        },
        "description" : "\nEdge Point Function\nCreate edge points of our component by translating the endpoint of a segment in 3 different directions\n",
        "end" : 43,
        "start" : 40
      }, {
        "code" : {
          "content" : [ "def mesh_quad(pt_a,pt_b,pt_c,pt_d):", "    # given four points, create a mesh", "    msh = Mesh([pt_a,pt_b,pt_c,pt_d])", "    msh.add_face(0,1,2,3)", "    # set the color of the mesh by its distance to an attractor point", "    t = factor(msh.face_centroid(0),attr_pt)", "    msh.set_color(Color.interpolate(clr_a,clr_b,t))", "    # return the mesh", "    return msh", "\t" ],
          "end" : 71,
          "start" : 61
        },
        "description" : "\nMesh Quad Function\nCreates a mesh consisting of a single quad face, and sets its color using the distance to the attractor point\n[pseudo]\n",
        "end" : 61,
        "start" : 57
      }, {
        "code" : {
          "content" : [ "", "def mesh_arm(arm_index,idxs):", "    # define the edge points for this arm of the component", "    epts = get_e(arm_index, length)", "    # using the provided indices of edge and tet points, create three quad meshes", "    m0 = mesh_quad(epts[2],tet_pts[idxs[0]],apex_pt,epts[0])", "    m1 = mesh_quad(epts[1],epts[0],apex_pt,tet_pts[idxs[1]])", "    m2 = mesh_quad(epts[1],tet_pts[idxs[2]],tet_pts[idxs[3]],epts[2])", "    return [m0,m1,m2]", "" ],
          "end" : 86,
          "start" : 76
        },
        "description" : "\nMesh Arm Function\nWeaves a single arm of our component using selected indices of tet points, edge points, and the apex point\n[pseudo]\n",
        "end" : 76,
        "start" : 72
      }, {
        "code" : {
          "content" : [ "# set the height of the component", "height = 0.1", "# make point at apex of the center tetrahedron ", "apex_pt = segs[0].spt + Vec(0,0,height)", "# all the pts of the central tetrahedron", "tet_pts = [get_s(i, height,attr_pt) for i in range(len(segs))]", "", "# a container to hold resulting meshes", "meshes = []", "", "# defining the proper tet_pts to connect", "t_idxs = (1,2,2,1)", "# create this mesh 'arm' ", "meshes_arm = mesh_arm(0,t_idxs)", "meshes.extend(meshes_arm)", "", "# follow the same pattern for the next two arms", "meshes_arm = mesh_arm(1,(2,0,0,2))", "meshes.extend(meshes_arm)", "meshes_arm = mesh_arm(2,(0,1,1,0))", "meshes.extend(meshes_arm)", "", "# create one last mesh on the bottom of the tet", "msh = Mesh([tet_pts[0],tet_pts[1],tet_pts[2]])", "msh.add_face(0,1,2)", "meshes.append(msh)", "" ],
          "end" : 116,
          "start" : 90
        },
        "description" : "\nTiling Routine\nUsing established base geometries, work through each arm and them the bottom of the tetrahedron, creating meshes.\n",
        "end" : 90,
        "start" : 87
      } ],
      "documentation" : {
        "description" : [ "4.01.L02b", "Given a lattice-based tiling, scale the original Segments according to a distance to a given point. Create a mesh Segments and color the Mesh based on the distance factor." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Dressed Tilings/4.01.L02b.py",
      "name" : "4.01.L02b.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Mesh" : 2,
          "Vec" : 3
        }
      },
      "required" : [ "segs ([Segment]) Base geometries to mesh.", "force (float) Attractor force to offset geometries.", "clr_a (Color) First color to interpolate.", "clr_b (Color) Second color to interpolate.", "attr_pt (Point) An attractor Point" ],
      "result" : [ "ret ([Mesh]) Meshes with color attributes created by offsetting an original geometry." ]
    },
    "31e5857e-39bc-43cf-827f-cf810002221b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def walk_curvature(uv_pt, uv_tar, ebounds, maximum=True, flip=False):", "    # if the initial point is target:", "    if uv_pt == uv_tar : ", "        # record an error", "        raise Exception(\"uv_pt and uv_tar must not be conincident\")", "    # build 2d point list for pline", "    pts_uv = [uv_pt]", "    # walker is not on the edge", "    at_edge = False", "    # the direciton to walk each turn", "    step_vec = Vec(uv_pt,uv_tar)", "    # the maximum amount to walk each turn", "    step_size = 0.01", "    ", "    # for each turn:", "    for n in range(100):", "        # find the average vector near point", "        crv_vec = vec_field.avg_vec_near(uv_pt)", "        # if vector is non-zero:", "        if crv_vec.length2 > 0 :", "            # normalize it", "            crv_vec = crv_vec.normalized()", "        # else continue in same direction", "        else:", "            crv_vec = step_vec.normalized()", "        # if walking on minimum curvature:", "        if not(maximum): ", "            # get minimum vector", "            crv_vec = crv_vec.cross(Vec.uz())", "        # reduce vector to step size", "        step_vec = crv_vec.normalized(step_size)", "        # if we are walking backwards:", "        if flip:", "            # invert the vector", "            step_vec = step_vec.inverted()", "        # move point along vector", "        uv_pt = uv_pt+step_vec", "        # if outside vector field:", "        if not uv_pt in ebounds:", "            # move to nearests point in field", "            uv_pt = Bounds.unit_square().near_pt(uv_pt)", "            # walker is at an edge", "            at_edge = True", "        # add point to point list", "        pts_uv.append(uv_pt)", "        # if walker is at an edge:", "        if at_edge: ", "            # break loop", "            break", "    # return the point list", "    return pts_uv", "    " ],
          "end" : 69,
          "start" : 17
        },
        "description" : "\nWalk Curvature\nWalk along the surface following lines of maximum or minimum curvature, starting at a given point and heading in a given direction.\n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "def spine(uv_seed,uv_tar, ebounds, maximum=False):", "    # walk curve in one direction", "    pts_uv = walk_curvature(uv_seed,uv_tar,ebounds,maximum)", "    # reverse the point list", "    pts_uv.reverse()", "    # walk curve in the other direction", "    npts_uv = walk_curvature(uv_seed,uv_tar,ebounds,maximum, flip=True)", "    # add lists together", "    pts_uv.extend(npts_uv)", "    # return a polyline made from points", "    return(PLine(pts_uv))", "    " ],
          "end" : 85,
          "start" : 73
        },
        "description" : "\nWalk Spine\nCreate a spine (polyline) that records a single walk from edge to edge\n",
        "end" : 73,
        "start" : 70
      }, {
        "code" : {
          "content" : [ "def get_polylines(start=None, maximum=True, count=5):", "    # create a nudge size", "    nudge = (0.1 / count)", "    # define bounds", "    ebounds = Bounds(center=Point(0.5,0.5),dim_x=1.0-nudge,dim_y=1.0-nudge)", "    # if there is no start spine:", "    if start == None:", "        # create a start spine", "        start = spine(seed_uv,tar_uv, ebounds, maximum=True)", "    # init return, longest curve, and length", "    ret_list = []", "    crv_longest = None", "    crv_longest_length = 0", "    ", "    # for each strip:", "    for t in Interval().divide(count,False):", "        # find point on start spine", "        uv_pt = start.eval(t)     ", "        # if it is in bounds:", "        if uv_pt in ebounds:", "            # find a target on the spine", "            tar_vec = Vec(uv_pt,start.eval(t+nudge))", "            # if target is same point:", "            if tar_vec.length == 0: ", "                # there is a problem", "                print \"problem with direction vec\", uv_pt,\"==\",start.eval(t+nudge)", "            # else:", "            else:", "                # create new target orthogonal to spine", "                tar_pt = uv_pt + tar_vec.cross(Vec.uz()).normalized(nudge)", "                # create a new spine", "                new_line = spine(uv_pt, tar_pt, ebounds, maximum)", "                # add this to return lsit", "                ret_list.append(new_line)", "                # if length is greater than longest:", "                if new_line.length > crv_longest_length:", "                    # save this spine as longest", "                    crv_longest = new_line", "                    crv_longest_length = new_line.length", "    # return list of spines and longest spine", "    return ret_list, crv_longest", "" ],
          "end" : 131,
          "start" : 89
        },
        "description" : "\nCross Spine\nGiven a spine, create a set of spines orthogonal to it \n",
        "end" : 89,
        "start" : 86
      }, {
        "code" : {
          "content" : [ "# initialize starting point and target point", "seed_uv = Point(0.40,0.25)", "tar_uv = Point(0.40,0.50)", "", "# get spines of minimum curvature", "min_list, min_longest = get_polylines(maximum = False)", "", "# get spines of maximum curvature", "max_list, max_longest = get_polylines(start = min_longest, maximum = True)", "", "", "" ],
          "end" : 146,
          "start" : 135
        },
        "description" : "\nPanelize Surface\nWalk the surface, creating spines of maximum and minimum curvature \n",
        "end" : 135,
        "start" : 132
      } ],
      "documentation" : {
        "description" : [ "4.03.L05c", "Use a vector field to create lines of minimum and maximum curvature" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Post-Rational Panelization/4.03.L05c.py",
      "name" : "4.03.L05c.py",
      "references" : {
        "classes" : {
          "Bounds" : 2,
          "Interval" : 1,
          "PLine" : 1,
          "Point" : 3,
          "Vec" : 4
        }
      },
      "required" : [ "vecf (VectorField) A Vector Field containing maximum curvature information at sampled points", "valf (ValueField) A Value Field containing the differences between the max and min curvature", "strip_cnt (integer) The number of maximum and minimum curvature lines to generate" ],
      "result" : [ "max_pl, min_pl ([Polyline)] Polylines representing lines of maximum and minimum curvature" ]
    },
    "32da1c12-d73e-4c63-a94d-45bcdc6f4d3c" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/reaction_diffusion.py",
      "definitions" : [ {
        "code" : [ "        self.width = dimensions.a", "        self.height = dimensions.b", "", "        # set default coefficients", "        self.f, self.k = 0.023, 0.077", "        self.du, self.dv = 0.095, 0.03", "", "        self.clear()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 16,
        "name" : "__init__",
        "start" : 8
      }, {
        "code" : [ "        return self.k", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 19,
        "name" : "k_at",
        "start" : 18
      }, {
        "code" : [ "        return self.f", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 22,
        "name" : "f_at",
        "start" : 21
      }, {
        "code" : [ "        x,y = self._reframe(x,y)", "        self._uvals.set(x,y,val)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 26,
        "name" : "set_u",
        "start" : 24
      }, {
        "code" : [ "        x,y = self._reframe(x,y)", "        self._vvals.set(x,y,val)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 30,
        "name" : "set_v",
        "start" : 28
      }, {
        "code" : [ "    def get_v(self,x,y): return self._vvals.get(x,y)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 32,
        "name" : "get_u",
        "start" : 32
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 33,
        "name" : "get_v",
        "start" : 33
      }, {
        "code" : [ "        x,y,w,h = int(x),int(y),int(w),int(h)", "        for xi in range(x,x+w):", "            for yi in range(y,y+h):", "                self.set_u(xi,yi,0.5)", "                self.set_v(xi,yi,0.25)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 40,
        "name" : "set_rect",
        "start" : 35
      }, {
        "code" : [ "        while x > self.width -1 : x = x - self.width", "        while y > self.height -1: y = y - self.height", "        while x < 0 : x = self.width + x", "        while y < 0 : y = self.height + y", "        return x,y", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 47,
        "name" : "_reframe",
        "start" : 42
      }, {
        "code" : [ "        self._uvals = ValueField(Interval(self.width,self.height),1.0)", "        self._vvals = ValueField(Interval(self.width,self.height))", "        self.step_count = 0", "        self.hist_u = []", "        self.hist_v = []", "        ", "        self.max_recorded_u = 0.0", "        self.min_recorded_u = 1.0", "        self.max_recorded_v = 0.0", "        self.min_recorded_v = 1.0", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 59,
        "name" : "clear",
        "start" : 49
      }, {
        "code" : [ "        self.hist_u.append(self._uvals)", "        self.hist_v.append(self._vvals)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 63,
        "name" : "record",
        "start" : 61
      }, {
        "code" : [ "        ival_u = Interval(self.min_recorded_u,self.max_recorded_u)", "        ival_v = Interval(self.min_recorded_v,self.max_recorded_v)", "        uv_color = Color.interpolate(u_color,v_color)        ", "        imgs = []", "", "        img = Image(Interval(self.width,self.height),base_color)", "", "        for px in range(len(img._pixels)):", "            ut = ival_u.deval(self.hist_u[gen]._pixels[px])", "            vt = ival_v.deval(self.hist_v[gen]._pixels[px])", "            if power:", "                if uv_flag == 'uv':", "                    c0 = Color.interpolate(base_color,u_color,ut**power)", "                    c1 = Color.interpolate(v_color,uv_color,ut**power)", "                    c = Color.interpolate(c0,c1,vt**power)", "                elif uv_flag == 'u':", "                    c = Color.interpolate(base_color,u_color,ut**power)", "                elif uv_flag == 'v':", "                    c = Color.interpolate(base_color,v_color,vt**power)", "            else:", "                if uv_flag == 'uv':", "                    c0 = Color.interpolate(base_color,u_color,ut)", "                    c1 = Color.interpolate(v_color,uv_color,ut)", "                    c = Color.interpolate(c0,c1,vt)", "                elif uv_flag == 'u':", "                    c = Color.interpolate(base_color,u_color,ut)", "                elif uv_flag == 'v':", "                    c = Color.interpolate(base_color,v_color,vt)", "            img._pixels[px]= c", "", "        return img", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 96,
        "name" : "to_image",
        "start" : 65
      }, {
        "code" : [ "    ", "        imgs = []", "        for n in range(len(self.hist_u)):", "            img = self.to_image(v_color, u_color, base_color, power, uv_flag, n)", "", "            imgs.append(img)", "        return imgs", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 105,
        "name" : "to_image_sequence",
        "start" : 98
      }, {
        "code" : [ "        if u > self.max_recorded_u : self.max_recorded_u = u", "        if u < self.min_recorded_u : self.min_recorded_u = u", "        if v > self.max_recorded_v : self.max_recorded_v = v", "        if v < self.min_recorded_v : self.min_recorded_v = v", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 111,
        "name" : "log_uv",
        "start" : 107
      }, {
        "code" : [ "        nxt_uvals = ValueField(Interval(self.width,self.height),0.0)", "        nxt_vvals = ValueField(Interval(self.width,self.height),0.0)", "        t = max(min(1.0,t),0.0)", "        for x in range(0,self.width):", "            for y in range(0,self.height):", "                cur_f = self.f_at(x,y)", "                cur_k = self.k_at(x,y)", "                cur_u = self._uvals.get(x,y)", "                cur_v = self._vvals.get(x,y)", "                d2 = cur_u * cur_v * cur_v", "                neighbors_u = self._uvals.neighbors_of(x,y)", "                neighbors_v = self._vvals.neighbors_of(x,y)", "", "                nxt_u = cur_u + t * ((self.du * ( sum(neighbors_u) - 4.0 * cur_u) - d2) + cur_f * (1.0 - cur_u))", "                nxt_v = cur_v + t * ((self.dv * ( sum(neighbors_v) - 4.0 * cur_v) + d2) - cur_k * cur_v)", "", "                nxt_uvals.set(x,y,max(0.0,nxt_u))", "                nxt_vvals.set(x,y,max(0.0,nxt_v))", "                self.log_uv(nxt_u,nxt_v)", "        ", "        self._uvals = nxt_uvals", "        self._vvals = nxt_vvals", "        self.step_count += 1", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 136,
        "name" : "step",
        "start" : 113
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 136,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/reaction_diffusion.py",
      "name" : "GrayScott",
      "references" : {
        "classes" : {
          "Color" : 17,
          "GrayScott" : 1,
          "Image" : 1,
          "Interval" : 8,
          "ValueField" : 4
        },
        "functions" : {
          "__init__" : 1,
          "_reframe" : 1,
          "clear" : 1,
          "f_at" : 1,
          "get_u" : 1,
          "get_v" : 1,
          "k_at" : 1,
          "log_uv" : 1,
          "record" : 1,
          "set_rect" : 1,
          "set_u" : 1,
          "set_v" : 1,
          "step" : 1,
          "to_image" : 1,
          "to_image_sequence" : 1
        }
      },
      "start" : 6
    },
    "3381f21d-a729-4bf9-8047-2a4d71e277b7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def rot_surface(rad_cap, rad_mid, mid_height):", "    # makes a set of Points on the XZ Plane", "    pts = [Point(rad_cap,0,0),Point(rad_mid,0,mid_height),Point(rad_cap,0,1)]", "    ", "    # creates a function to make Surfaces with the Points", "    def func(u,v):", "        # rotation angle", "        ang = Interval.twopi().eval(u)", "        # rotated Points", "        rot_pts = [pt*Xform.rotation(axis=Vec.uz(),angle=ang) for pt in pts]", "        # evaluate Points on a bezier Curve", "        return Curve.bezier(rot_pts).eval(v)", "    # return the Surface function", "    return func" ],
          "end" : 30,
          "start" : 16
        },
        "description" : "\nRotational Surface\nMethod that given three Points, creates a rotational Surface by rotating the Points around the Z Axis.\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L02a", "Method that given three Points, creates a cylindrical Surface by rotating the Points around the Z Axis." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Floor-Facade Area Optimization/4.07.L02a.py",
      "name" : "4.07.L02a.py",
      "references" : {
        "classes" : {
          "Curve" : 1,
          "Interval" : 1,
          "Point" : 3,
          "Vec" : 1,
          "Xform" : 1
        }
      },
      "required" : [ "pts ([Point]) 3 Points decribing the profile to create a rotational Surface.", "u (float) u value to evaluate.", "v (float) v value to evaluate." ],
      "result" : [ "curve ([Curve]) A set of bezier Curves representing a Surface." ]
    },
    "3394191f-99ed-4845-bdc7-07d004808ed7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pts = [pl_b.pts[0]]", "plns = [] ", "# for every vertex excluding the first: ", "for n in range(1,len(pl_a)):", "    # construct the projection plane", "    pln = Plane.from_pts(pl_a.pts[n-1],pl_a.pts[n],pts[-1]) ", "    # project the vertex to this plane", "    pts.append( pln.near_pt(pl_b.pts[n]) )", "    # adjust vertex", "    plns.append(pln)", "#add on first and last planes", "plns.append(Plane.from_pts(pl_a.pts[0],pl_a.pts[-1],pts[-1]))", "xsec = Intersector()", "# if first and last planes intersect:", "if xsec.of(plns[0], plns[-1]):", "    # get the closest point of intersection", "    pt = xsec[0].near_pt(pl_b.pts[0])", "    # adjust first vertex", "    pts[0] = pt", "new_pline = PLine(pts)", "" ],
          "end" : 37,
          "start" : 17
        },
        "description" : "\nModified Polyline\nGiven two polylines with equal vertex count, modify one so that polylines can be connected by flat quads\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.05.F03a", "Given two non-planar PLines with equal vertex count, change the vertex locations of one PLine in order to create planar quads for each edge PGon created between the corresponding sides." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Sanddollar/4.05.F03a.py",
      "name" : "4.05.F03a.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "PLine" : 1,
          "Plane" : 2
        }
      },
      "required" : [ "pl_a (PLine) A base polyline.", "pl_b (PLine) A polyline to be modified." ],
      "result" : [ "A modified polyline (PLine)" ]
    },
    "33c919a2-799b-4b32-b97d-d7de1e6e9635" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def node(edge,vconfig):", "    rgons = []", "    #create a set of regular polygons around each vertex node", "    for n in vconfig:", "        rgons.append(RGon.from_edge(edge,n))", "        edge = rgons[-1].edges[0]", "    # create a list of half segments from these regular polygons", "    segs = [Segment(rg.pts[0],Vec(rg.pts[0],rg.pts[1])/2.0) for rg in rgons]", "    return segs", "" ],
          "end" : 26,
          "start" : 16
        },
        "description" : "\nNode Function\nDefines a lattice of half line segments emanating from a vertex node\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "seed = Segment(Point(),Vec(0,1))*Xform.rotation(angle=pi/6.0,axis=Vec(0,0,1))", "v_config = (3,6,3,6) ", "", "# define the number of nodes for every cluster ", "nodes_per_clst = 3", "# define the number of nodes for every row", "clst_per_row = u_cnt", "", "sqrt3_2 = 3.0**0.5/2.0 # the height of an eq triangle is sqrt(3/2)*side_length", "" ],
          "end" : 40,
          "start" : 30
        },
        "description" : "\nSetting the parameters of seed edge, vertex configuration and nodes per cluster\n[noprint]\n",
        "end" : 30,
        "start" : 27
      }, {
        "code" : {
          "content" : [ "for n in range(u_cnt*v_cnt*nodes_per_clst):", "    # set the translation between clusters in the x-direction", "    if n>0 and n%nodes_per_clst==0:", "\t      seed._pt += Vec(2*seed.length,0)", "        ", "    # set the translation between clusters in the y-direction", "    if n>0 and n%(nodes_per_clst*clst_per_row)==0:", "        dy = sqrt3_2*seed.length*2", "\t\t#alternate odd and even rows", "        if n%(nodes_per_clst*clst_per_row*2)==0 : dx = -2*seed.length*(clst_per_row+0.5)", "        else : dx = -2*seed.length*(clst_per_row-0.5)       ", "        seed *= Xform.translation(Vec(dx,dy))", "    #set the transformation between nodes within a cluster", "    if n>0:", "        tri = RGon.from_edge(seed,3)", "        seed*= Xform.rotation(angle=2*pi/3.0,axis=Vec(0,0,-1),center=tri.centroid)", "    ", "    cur_node = node(seed,v_config)", "", "    " ],
          "end" : 63,
          "start" : 44
        },
        "description" : "\nCreates a grid of lattice units by setting the seed edge from vertex node to node\n[noprint]\n",
        "end" : 44,
        "start" : 41
      } ],
      "documentation" : {
        "description" : [ "4.01.L01c", "Given a \"seed edge\", create a semi-regular, tri-hexagonal tiling from a lattice." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Regular Tiling/4.01.L01c.py",
      "name" : "4.01.L01c.py",
      "references" : {
        "classes" : {
          "Point" : 1,
          "RGon" : 2,
          "Segment" : 2,
          "Vec" : 6,
          "Xform" : 3
        }
      },
      "required" : [ "u_cnt (Int) Number of clusters in U direction.", "v_cnt (Int) Number of clusters in V direction." ],
      "result" : [ "ret ([[Segment]]) List of segments." ]
    },
    "349726cd-e94d-4b1c-8779-f0fe809ad78e" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_grid.py",
      "definitions" : [ {
        "code" : [ "    ", "        \"\"\" Vector field constructor.", "            ", "            TODO: UPDATE DOCUMENTATION ", "            ", "            :param pixel_dim: Resolution of vector grid.", "            :type pixel_dim: Interval", "            :param spatial_origin: Center of vector field.", "            :type spatial_origin: Point", "            :param spatial_dim: Dimension of vector field.", "            :type spatial_dim: Interval", "            :param initial_value: Start value for vector field.", "            :type initial_value: Vec", "            :param include_corners: Boolean Value.", "            :type include_corners: bool", "            :param wrap: Boolean Value.", "            :type wrap: bool", "            :result: A vector field.", "            :rtype: VecField", "            ", "        \"\"\"", "        super(VecField,self).__init__(pixel_dim,bnds,**kwargs)", "        self.populate(initial_value,True)", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Vector field constructor.", "TODO: UPDATE DOCUMENTATION" ],
          "parameters" : {
            "include_corners" : "Boolean Value.\n",
            "initial_value" : "Start value for vector field.\n",
            "pixel_dim" : "Resolution of vector grid.\n",
            "spatial_dim" : "Dimension of vector field.\n",
            "spatial_origin" : "Center of vector field.\n",
            "wrap" : "Boolean Value.\n"
          },
          "rtype" : "VecField",
          "rvalue" : "A vector field.\n",
          "types" : {
            "include_corners" : "bool\n",
            "initial_value" : "Vec\n",
            "pixel_dim" : "Interval\n",
            "spatial_dim" : "Interval\n",
            "spatial_origin" : "Point\n",
            "wrap" : "bool\n"
          }
        },
        "end" : 198,
        "name" : "__init__",
        "start" : 175
      }, {
        "code" : [ "        \"\"\" Returns a list of Rays that correspond to the Vecs from the Vector Field.", "        ", "            :result: A list of Rays.", "            :rtype: [Ray]", "        \"\"\"", "        return [Ray(pt,vec) for vec,pt in zip(self._pixels, self._base_pts )]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a list of Rays that correspond to the Vecs from the Vector Field." ],
          "rtype" : "[Ray]",
          "rvalue" : "A list of Rays.\n"
        },
        "end" : 206,
        "name" : "to_rays",
        "start" : 200
      }, {
        "code" : [ "        \"\"\" Returns closest vector to the given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: Nearest Vec.", "            :rtype: Vec", "            ", "        \"\"\"", "        return self.get(*self.address_near(a,b))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns closest vector to the given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "Nearest Vec.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 219,
        "name" : "vec_near",
        "start" : 208
      }, {
        "code" : [ "        \"\"\" Returns locations of vectors near the given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: List of locations of near vectors.", "            :rtype: [tup]", "            ", "        \"\"\"", "        return [self.get(*add) for add in self.addresses_near(a,b)]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns locations of vectors near the given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "[tup]",
          "rvalue" : "List of locations of near vectors.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 232,
        "name" : "vecs_near",
        "start" : 221
      }, {
        "code" : [ "        \"\"\" Returns an average vector from the near vectors around the given location. May be passed a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: An average vector.", "            :rtype: Vec", "            ", "        \"\"\"", "        ", "        try:", "            sample_pt = Point(a.x,a.y)", "        except:", "            sample_pt = Point(a,b)", "            ", "        vecs = self.vecs_near(sample_pt)", "        cpts = self.cpts_near(sample_pt)", "        try:", "            dists = [1.0/sample_pt.distance2(cpt) for cpt in cpts]", "            tot = sum(dists)", "            weights = [dist/tot for dist in dists]", "            vec = Vec()", "            for n in range(len(vecs)):", "                vec = vec + vecs[n]* weights[n]", "            return vec", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns an average vector from the near vectors around the given location. May be passed a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "An average vector.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 260,
        "name" : "avg_vec_near",
        "start" : 234
      }, {
        "code" : [ "        \"\"\" Rotates vectors in a VecField around a given point. May be passed a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point to rotate around.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: Modifies this Vector Field in place.", "            :rtype: None", "                        ", "        \"\"\"", "        try:", "            spin_pt = Point(a.x,a.y)", "        except:", "            spin_pt = Point(a,b)", "            ", "        import math as m # import math library", "        # for every x value in the vector field:", "        for x in range(self.px_width):", "            # for every y value in the vector field", "            for y in range(self.px_height):", "                # create a new spin vector", "                v_x = y*(m.sin(spin_pt.y) + m.cos(spin_pt.x)) # vector x-component", "                v_y = x*(m.sin(spin_pt.x) - m.cos(spin_pt.y)) # vector y-component", "                new_vec = Vec(v_x, v_y) # construct new spin vector", "                # set vector at x,y to new spin vector", "                self.set(x,y,new_vec)", "            " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Rotates vectors in a VecField around a given point. May be passed a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point to rotate around.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "None\n            ",
          "rvalue" : "Modifies this Vector Field in place.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 293,
        "name" : "spin_pt",
        "start" : 267
      } ],
      "documentation" : {
        "description" : [ "| A raster grid of vectors.", "| Each pixel contains a positioned 3d vector (a Ray)." ]
      },
      "end" : 293,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_grid.py",
      "name" : "VecField",
      "references" : {
        "classes" : {
          "Grid" : 1,
          "Point" : 4,
          "Ray" : 1,
          "Vec" : 3,
          "VecField" : 2
        },
        "functions" : {
          "__init__" : 1,
          "avg_vec_near" : 1,
          "spin_pt" : 1,
          "to_rays" : 1,
          "vec_near" : 1,
          "vecs_near" : 1
        }
      },
      "start" : 167
    },
    "355f2ab4-2bae-485c-a1b0-f6a9ad51e576" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create a quadtree to search for point neighbors", "struc = QuadTree(2,Bounds(center=Point(),dim_x=init_rad*2,dim_y=init_rad*2))", "# start our lattice with a single point", "struc.append(Point(0,0,0))", "", "max_pts = 50", "max_steps = 200", "", "# create containers for storing trails and lattice segments", "segs = []", "success_trails = []", "fail_trails = []", "", "for n in range(max_pts):", "    # create a particle", "    ptcl = Particle()", "    # for each step of this particle", "    for step in range(max_steps):", "        ptcl.step()", "        # if the particle is within sight of the lattice", "        if particle.check(struc):", "            # append this particle to the Quadtree", "            struc.append(ptcl.pos)", "            # draw a segment between the this particle and its other", "            segs.append(Segment(ptcl.pos,ptcl.other))", "            if len(ptcl.hist) > 1 : ", "                # append the path of this particle to the success trail list", "                success_trails.append(ptcl.draw_trail)", "                ptcl.hist = []", "            break", "        # keep the particle within bounds", "        if abs(ptcl.pos.x) > init_rad or abs(ptcl.pos.y) > init_rad:", "            break", "    # append the path of this particle to the fail trail list", "    if len(ptcl.hist) > 1 : fail_trails.append(ptcl.draw_trail)", "" ],
          "end" : 53,
          "start" : 17
        },
        "description" : "\nDLA Routine\nCreates DLA particles one at a time, and steps each until either the existing structure is found, or the maximum number of steps is reached\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.01.L06b", "Given a step count and number of particles, create a DLA structure" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/DLA/4.01.L06b.py",
      "name" : "4.01.L06b.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "Particle" : 1,
          "Point" : 2,
          "QuadTree" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "Particle (Particle) Particle class." ],
      "result" : [ "segs ([Segment]) A set of lines.", "success_trails ([PLine]) Trails of successful particles", "fail_trails ([PLine]) Trails of unsuccessful particles" ]
    },
    "36e3b3ec-071d-4086-88f1-b7a75d4b23ea" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class Particle():", "    def __init__(self):", "        # set the position to a random pt that lies on the perimeter ", "        # of a circle of a given radius", "        self.pos = CS().eval_cyl(init_rad, random.random()*math.pi*2)", "        # define the inital vector of movement", "        self.vel = Vec(self.pos,Point()).normalized(step_size)", "        self.rov = rov", "        # initialize a container for storing a history of positions", "        self.hist = []", "                ", "    \"\"\"", "    Step Method", "    Slightly alters this particle's trajectory toward a random vector, and moves it one step forward", "    \"\"\"", "    def step(self):", "        self.hist.append(self.pos)", "        # randomly alter the current trajectory", "        rand_vec = Vec.random(Interval(-1.0,1.0),True,True)", "        self.vel = Vec.interpolate(self.vel,rand_vec,randomness)", "        ", "        # move the particle forward by a distance of one step", "        self.vel = self.vel.normalized(step_size)", "        self.pos += self.vel", "            ", "    \"\"\"", "    Check DLA Lattice Structure", "    Determines if a particle is within range of a given DLA lattice, stored as a set of  points in a Quadtree.", "    \"\"\"", "    def check(self, struc):", "        # find points that lie within this particle's range of vision", "        bnd = Bounds(center=self.pos,dim_x=self.rov,dim_y=self.rov)", "        near_pts = struc.pts_in_bounds(bnd)", "        ", "        # return False if there are no points in sight", "        if len(near_pts)==0 : return False", "        else:", "            # record the nearest point as this particle's \"other\"", "            self.oth = Point.near(self.pos,near_pts)", "            # because our ROV bounds is square, we must double-check", "            # the distance between this particle and the other", "            if self.oth.distance(self.pos) > self.rov : return False", "            # reposition this particle to be one step away the other", "            self.pos = self.oth + Vec(self.oth,self.pos).normalized(step_size)", "            return True", "    ", "    \"\"\"", "    Misc", "    Assorted drawing functions", "    [noprint]", "    \"\"\"", "    # return a point representation of the particle", "    @property", "    def draw(self):", "        return self.pos", "        ", "    # return a PLine representation of the particle's trail", "    @property", "    def draw_trail(self):", "        if len(self.hist) < 2 : return False", "        return PLine(self.hist)", "" ],
          "end" : 81,
          "start" : 19
        },
        "description" : "\nDLA Particle Class\nDefines an agent able to move along a random vector, and capable of determining if it has moved within range of a DLA lattice structure. \n",
        "end" : 19,
        "start" : 16
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/DLA/4.01.L06a.py",
      "name" : "4.01.L06a.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "CS" : 1,
          "Interval" : 1,
          "PLine" : 1,
          "Particle" : 1,
          "Point" : 2,
          "Vec" : 4
        }
      }
    },
    "36f66172-1946-4d37-83d9-603c9377807e" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_2d.py",
      "definitions" : [ {
        "code" : [ "    def _base_pts(self):", "        return [ ", "            Point(0.0, 0.0)," ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 145,
        "name" : "_base_pts",
        "start" : 143
      }, {
        "code" : [ "        # TileB has its origin CS on _base_pts[0], the XAxis points towards _base_pts[1], and the YAxis points towards _base_pts[5]", "        cs = self._cs_from_base_pts(0,1,5)", "        # Create a TileB on the new CS and scale it down", "        b0 = AmmannA3TileB(self.xf * cs.xform * self._xf_scale,self.lineage+\",b0\")", "        ", "        # TileA has its origin CS on _base_pts[1], the XAxis points towards _base_pts[2], and the YAxis points towards _base_pts[0]", "        cs = self._cs_from_base_pts(1,2,0)", "        # Create a TileA on the new CS and scale it down", "        a0 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a0\")", "        return [b0,a0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 166,
        "name" : "inflate",
        "start" : 156
      }, {
        "code" : [ "        pg = PGon(self.base_pts[:6])", "        pg.name = self.lineage", "        return pg", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 172,
        "name" : "to_pgon",
        "start" : 169
      }, {
        "code" : [ "        pg = PLine([self.base_pts[5],self.base_pts[6],self.base_pts[2]])", "        return pg", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 176,
        "name" : "to_lines",
        "start" : 174
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 176,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_2d.py",
      "name" : "AmmannA3TileA",
      "references" : {
        "classes" : {
          "AmmannA3Tile" : 1,
          "AmmannA3TileA" : 2,
          "AmmannA3TileB" : 1,
          "PGon" : 1,
          "PLine" : 1,
          "Point" : 7
        },
        "functions" : {
          "_base_pts" : 1,
          "inflate" : 1,
          "to_lines" : 1,
          "to_pgon" : 1
        }
      },
      "start" : 141
    },
    "3818f4cf-07d5-4fea-bd24-c7c5dfe38239" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "flock = [Bird() for n in range(count)]", "", "for step in range(count):", "    # establish a searchable \"sky\" for each step", "    sky = QuadTree.encompass(pts = flock)", "    for bird in flock:", "        # find Birds within the ROV and ROC of this Bird", "        nears = bird.scan(sky)", "        too_nears = bird.in_range(nears, bird.roc)", "        ", "        # call align, seek, and flee behavior functions", "        bird.align(nears, w_align)", "        bird.seek(nears, w_seek)", "        bird.flee(too_nears, w_flee)", "        # update Bird location", "        bird.step()" ],
          "end" : 32,
          "start" : 17
        },
        "description" : "\nTrue Flocking Routine\nCreates a flock of flocking Bird objects, and steps each bird a given number of steps\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.02.L05d", "Move a flock of Birds using the Flocking algorithm" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Birds/4.02.L05d.py",
      "name" : "4.02.L05d.py",
      "references" : {
        "classes" : {
          "Bird" : 1,
          "QuadTree" : 1
        }
      },
      "required" : [ "Bird (class) A flocking Bird class", "count (int) The number of steps", "w_align, w_seek, w_flee (float) The relative strength of the align, seek and flee behaviors" ],
      "result" : [ "flock ([Bird]) A group of Birds with their history filled out" ]
    },
    "383a67e4-0baa-4be3-873f-4e54e2273510" : {
      "code" : [ "    outie = dc.make_out(dc.outies.Rhino, \"axiom\")", "    outie.iconscale = 0.1", "    ta = DzTileA(xf=Xform.translation(Vec(1,0,0)),rlvl=1)", "    tb = DzTileB(xf=Xform.translation(Vec(2,0,0)),rlvl=1)", "    tc = DzTileC(xf=Xform.translation(Vec(3,0,0)),rlvl=1)", "    tk = DzTileK(xf=Xform.translation(Vec(4,0,0)),rlvl=1)", "    ", "    for t in [ta,tb,tc,tk] : outie.put(t.draw())", "    outie.draw()", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 329,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DanzerAxiom",
      "start" : 320
    },
    "38a66203-5624-44bf-9a47-f0b42055a7bb" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pt_cnt = len(pgon.pts)", "direction = []", "for n in range(pt_cnt):", "    this_pt = pgon.pts[n]", "    prev_pt = pgon.pts[n-1]", "    next_pt = pgon.pts[n+1] if n < pt_cnt-1 else pgon.pts[0]", "    ", "    vec_a = Vec(this_pt,next_pt)", "    vec_b = Vec(this_pt,prev_pt)", "    vec_crs = vec_a.cross(vec_b).normalized()", "    ", "    direction.append(vec_crs.z > 0)", "    ", "if sum(direction) == pt_cnt : ", "    print \"polygon is convex\"", "else: ", "    print \"polygon is concave\"", "" ],
          "end" : 33,
          "start" : 15
        },
        "description" : "\nConvex or Concave\nTests each vertex of a polygon to see whether its interior angle is less than or equal to 180 degrees\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "    ", "pts = []", "for n in range(pt_cnt):", "    if not direction[n]: pts.append(pgon.pts[n])" ],
          "end" : 39,
          "start" : 36
        },
        "description" : "\n[noprint]\n",
        "end" : 36,
        "start" : 34
      } ],
      "documentation" : {
        "description" : [ "3.02.E01c", "todo" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/Cross Products/3.02.E01c.py",
      "name" : "3.02.E01c.py",
      "references" : {
        "classes" : {
          "Vec" : 2
        }
      }
    },
    "39926ffe-38d7-4465-9c93-98e39f66c605" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/packing.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"Creates a Strip object that contains filled areas and open sub-strips.", "        ", "            :param start: start of Strip", "            :type start: integer", "            :param length: Length of Strip", "            :type length: float", "            :param filled: Is this Strip currently filled?", "            :type filled: boolean   ", "        \"\"\"", "        self.boundary = Interval(start, start+length)", "        if filled is None:", "            self.filling = None" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Creates a Strip object that contains filled areas and open sub-strips." ],
          "parameters" : {
            "filled" : "Is this Strip currently filled?\n",
            "length" : "Length of Strip\n",
            "start" : "start of Strip\n"
          },
          "types" : {
            "filled" : "boolean   ",
            "length" : "float\n",
            "start" : "integer\n"
          }
        },
        "end" : 18,
        "name" : "__init__",
        "start" : 7
      }, {
        "code" : [ "    def filled(self):", "        return not(self.filling is None)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 27,
        "name" : "filled",
        "start" : 25
      }, {
        "code" : [ "        # Note - if you call can_fill, self.filled should be False", "        if self.filled:", "            self.remainder.put_item(length)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 31,
        "name" : "put_item",
        "start" : 29
      }, {
        "code" : [ "        if self.filled:", "            return self.remainder.can_fit(length)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 41,
        "name" : "can_fit",
        "start" : 40
      }, {
        "code" : [ "        result = []", "        if self.filled:", "            result.append(self.filling)", "            if self.remainder != None : ", "                r = self.remainder.get_filled()", "                if r <> [] : result.extend(r)", "        return result", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 54,
        "name" : "get_filled",
        "start" : 47
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 54,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "Strip",
      "references" : {
        "classes" : {
          "Interval" : 3,
          "Strip" : 3
        },
        "functions" : {
          "__init__" : 1,
          "can_fit" : 1,
          "filled" : 1,
          "get_filled" : 1,
          "put_item" : 1
        }
      },
      "start" : 5
    },
    "3a3ad470-f5a0-4f38-95fb-326b6de431e5" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_circle.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"Arc Constructor", "        ", "            :param cs: Coordinate system.", "            :type cs: CS", "            :param radius: Radius of arc.", "            :type radius: float", "            :param sweep_angle: Angle of arc.", "            :type swee_angle: float", "            :result: Arc object", "            :rtype: Arc", "            ", "            ::", "            ", "                my_arc=Arc(CS(Point(0,0,0)), 6.0, 1.5) ", "            ", "        \"\"\"", "        self._basis = cs", "        self.rad = radius", "        self.angle = sweep_angle", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Arc Constructor" ],
          "parameters" : {
            "cs" : "Coordinate system.\n",
            "radius" : "Radius of arc.\n",
            "sweep_angle" : "Angle of arc.\n"
          },
          "rtype" : "Arc\n\n",
          "rvalue" : "Arc object\n",
          "types" : {
            "cs" : "CS\n",
            "radius" : "float\n",
            "swee_angle" : "float\n"
          }
        },
        "end" : 167,
        "name" : "__init__",
        "start" : 148
      }, {
        "code" : [ "        \"\"\" Evaluates this Arc and returns a Point.", "        ", "            :param t: Normalized value between 0 and 1.", "            :type t: float", "            :result: a Point on the Arc.", "            :rtype: Point", "            ", "            ::", "            ", "                my_arc.eval(0.5)", "        \"\"\"", "        x = self.rad * math.cos(t*self.angle)", "        y = self.rad * math.sin(t*self.angle)", "        return self._basis.eval(x,y)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates this Arc and returns a Point." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "a Point on the Arc.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 183,
        "name" : "eval",
        "start" : 169
      }, {
        "code" : [ "        \"\"\" Evaluates this Arc and returns a Plane.", "        ", "            :param t: Normalized value between 0 and 1.", "            :type t: float", "            :result: a Plane on the Arc.", "            :rtype: Plane", "            ", "            ::", "            ", "                my_arc.eval_pln(0.5)", "        \"\"\"", "        pt = self.eval(t)", "        return Plane(pt,Vec(self.origin,pt).cross(self._basis.z_axis))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates this Arc and returns a Plane." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1.\n"
          },
          "rtype" : "Plane\n\n",
          "rvalue" : "a Plane on the Arc.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 198,
        "name" : "eval_pln",
        "start" : 185
      }, {
        "code" : [ "        \"\"\" Evaluates this Arc and returns a Point. Equivalent to eval.", "            ", "            :param t: Normalized value between 0 and 1.", "            :type t: float", "            :result: a Point on the Arc.", "            :rtype: Point", "            ", "        \"\"\"", "        # only here so that we may use arcs as curves", "        return self.eval(t)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates this Arc and returns a Point. Equivalent to eval." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1.\n"
          },
          "rtype" : "Point",
          "rvalue" : "a Point on the Arc.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 210,
        "name" : "deval",
        "start" : 200
      }, {
        "code" : [ "        \"\"\" Evaluates this Arc and returns a Plane. Equivalent to eval_pln.", "        ", "            :param t: Normalized value between 0 and 1.", "            :type t: float", "            :result: a Plane on the Arc.", "            :rtype: Plane", "        \"\"\"    ", "        # only here so that we may use arcs as curves", "        return self.eval_pln(t)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates this Arc and returns a Plane. Equivalent to eval_pln." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "a Plane on the Arc.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 221,
        "name" : "deval_pln",
        "start" : 212
      }, {
        "code" : [ "    def length(self):", "        \"\"\" Returns length of this Arc.", "        ", "            :result: Length of arc.", "            :rtype: float", "            ", "            ::", "            ", "                my_arc.length", "        \"\"\"", "        return self.rad * self.angle", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns length of this Arc." ],
          "rtype" : "float\n\n",
          "rvalue" : "Length of arc.\n"
        },
        "end" : 234,
        "name" : "length",
        "start" : 223
      }, {
        "code" : [ "    def epts(self):", "        \"\"\" Returns the end points of this Arc.", "            ", "            :result: End points of this arc.", "            :rtype: Point, Point", "            ", "            ::", "            ", "                my_arc.epts", "        ", "        \"\"\"", "        return self.eval(0), self.eval(1) ", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the end points of this Arc." ],
          "rtype" : "Point, Point\n\n",
          "rvalue" : "End points of this arc.\n"
        },
        "end" : 248,
        "name" : "epts",
        "start" : 236
      }, {
        "code" : [ "    def spt(self):", "        \"\"\" Returns the start Point of this Arc.", "        ", "            :result: Start Point of this arc.", "            :rtype: Point", "            ", "            ::", "            ", "                my_arc.spt", "            ", "        \"\"\"", "        return self.eval(0)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the start Point of this Arc." ],
          "rtype" : "Point\n\n",
          "rvalue" : "Start Point of this arc.\n"
        },
        "end" : 262,
        "name" : "spt",
        "start" : 250
      }, {
        "code" : [ "    def ept(self):", "        \"\"\" Returns the end Point of this Arc.", "            ", "            :result: End Point of this arc.", "            :rtype: Point", "            ", "            ::", "            ", "                my_arc.ept", "            ", "        \"\"\"", "        return self.eval(1) ", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the end Point of this Arc." ],
          "rtype" : "Point\n\n",
          "rvalue" : "End Point of this arc.\n"
        },
        "end" : 276,
        "name" : "ept",
        "start" : 264
      }, {
        "code" : [ "    def origin(self):", "        \"\"\" Returns the origin of the basis of this Arc.", "        ", "            :result: Origin of this Arc's basis.", "            :rtype: Point", "            ", "            ::", "            ", "                my_arc.origin", "        \"\"\"", "        return self._basis.origin", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the origin of the basis of this Arc." ],
          "rtype" : "Point\n\n",
          "rvalue" : "Origin of this Arc's basis.\n"
        },
        "end" : 289,
        "name" : "origin",
        "start" : 278
      }, {
        "code" : [ "    def is_major(self):", "        return self.angle > math.pi", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 293,
        "name" : "is_major",
        "start" : 291
      }, {
        "code" : [ "    def is_minor(self):", "        return self.angle < math.pi", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 297,
        "name" : "is_minor",
        "start" : 295
      }, {
        "code" : [ "    def is_semicircle(self):", "        return self.angle == math.pi          ", "      " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 301,
        "name" : "is_semicircle",
        "start" : 299
      }, {
        "code" : [ "        \"\"\" Returns the distance between an Arc and a Point.", "        ", "            :param p: Point to look for a near Point on the LinearEntity.", "            :type p: Point", "            :result: Tuple of near point on Arc, and distance from point to near point", "            :rtype: (Point, float)", "            ", "        \"\"\"", "    ", "        #find the normal vector to the plane of the arc", "        if self.spt != self.ept:", "            pln_normal = (Vec(self.origin, self.spt).cross(Vec(self.origin, self.ept))).normalized()", "        else:", "            pln_normal = (Vec(self.origin, self.ept).cross(Vec(self.origin, self.eval(0.25)))).normalized()", "        ", "        # if normal vector points to same side of plane as curve point", "        if Vec(self.origin, p).dot(pln_normal) > 0:", "            pt_proj = p - pln_normal*(Vec(self.origin, p).dot(pln_normal))", "        else:", "            pt_proj = p + pln_normal*(Vec(self.origin, p).dot(-pln_normal))", "        dist_1 = p.distance(pt_proj) ", "", "        #find intersection of the projected point with full circle (both lying on same plane)", "        vec_u = Vec(self.origin, pt_proj).normalized()", "        pt_int = self.origin + vec_u*self.rad  ", "", "        #set up quantities to test whether the intersection point is on the arc", "        v_perp = Vec(self.spt, self.ept).cross(pln_normal)", "        if (self.angle > math.pi): v_perp = -v_perp", "", "        #if intersection point is on the arc", "        if (Vec(self.spt, pt_int).dot(v_perp) > 0):     ", "            dist_2 = pt_proj.distance(pt_int)", "        #if pt_int is not on the arc", "        else:", "            dist_2 = min(pt_proj.distance(self.spt), pt_proj.distance(self.ept))", "   ", "        angle = Vec(self.origin, self.spt).angle(Vec(self.origin, pt_int))", "        ", "        if self.basis.deval(self._basis.xAxis.cross(Vec(self.origin, pt_int))).z < 0:", "            angle = math.pi * 2 - angle", "        t = angle/self.angle", "        near = (pt_int, t, math.sqrt(dist_1**2 + dist_2**2))", "        ", "        if near[1] < 0 or near[1] > 1:", "            if p.distance(self.spt) < p.distance(self.ept):", "                near = (self.spt,0.0,p.distance(self.spt))", "            else: near = (self.ept,1.0,p.distance(self.ept))", "        ", "        return near", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the distance between an Arc and a Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the LinearEntity.\n"
          },
          "rtype" : "(Point, float)",
          "rvalue" : "Tuple of near point on Arc, and distance from point to near point\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 355,
        "name" : "near",
        "start" : 305
      }, {
        "code" : [ "        \"\"\" Returns the closest point to a given Arc", "       ", "            :param p: Point to look for a near Point on the Arc.", "            :type p: Point", "            :result: Near point on Arc.", "            :rtype: Point", "        \"\"\"", "        return self.near(p)[0]", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point to a given Arc" ],
          "parameters" : {
            "p" : "Point to look for a near Point on the Arc.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Near point on Arc.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 366,
        "name" : "near_pt",
        "start" : 358
      }, {
        "code" : [ "        vx = Vec(self.origin,self.ept)", "        vy = Vec(self.origin,self.eval(1.0+EPSILON))", "        cs = CS(self.origin,vx,vy)", "        return Arc(cs,self.rad,math.pi*2-self.angle)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 373,
        "name" : "reciprocal",
        "start" : 369
      }, {
        "code" : [ "        \"\"\" Splits this arc by a given Plane", "        ", "            :result: Origin of this Arc's basis.", "            :rtype: Point", "            ", "            ::", "            ", "                my_arc.origin", "        \"\"\"    ", "        from .dc_intersection import Intersector ", "        xsec = Intersector()", "        if not xsec.of(self, plane): return False", "        ", "        pts = xsec.results + [self.ept]", "        delts = [j-i for i, j in zip([0]+xsec.angs, xsec.angs+[self.angle])]", "        angs = xsec.angs + [self.angle]", "        ", "        split_arcs = []", "        cs = self.basis", "        for pt, delt, ang in zip(pts,delts,angs):", "            split_arcs.append(Arc(cs,self.rad,delt))", "            vx = Vec(cs.origin,pt)", "            vy = Vec(cs.origin,self.eval(ang/self.angle+EPSILON))", "            cs = CS(cs.origin,vx,vy)", "            ", "        return split_arcs    ", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Splits this arc by a given Plane" ],
          "rtype" : "Point\n\n",
          "rvalue" : "Origin of this Arc's basis.\n"
        },
        "end" : 402,
        "name" : "split_by",
        "start" : 376
      }, {
        "code" : [ "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 406,
        "name" : "__repr__",
        "start" : 406
      }, {
        "code" : [ "    def from_tan(start_pt,sweep_pt,tan):", "        \"\"\"Returns an arc using a start point, a sweep point and a tangent to the arc at the start point.", "            ", "            :param start_pt: Arc start Point.", "            :type start_pt: Point", "            :param sweep_pt: Arc sweep Point.", "            :type sweep_pt: Point", "            :param tan: Tangent vector at start point.", "            :type tan: Vec", "            :result: Arc", "            :rtype: Arc", "            ", "        \"\"\"", "        ", "        vec_ab = Vec(start_pt, sweep_pt)", "        try:", "            vec_rad = tan.cross(tan.cross(vec_ab))", "            ang = vec_ab.angle(vec_rad)", "            rad = vec_ab.length/math.cos(ang)/2.0", "            center = Point(start_pt+vec_rad.normalized(rad))", "        ", "            if (vec_ab.dot(tan) > 0):", "                arc_out = Arc.from_pts(center,start_pt,sweep_pt)", "            else:", "                arc_out = Arc.from_pts(center,start_pt, sweep_pt, True)    ", "            return arc_out", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns an arc using a start point, a sweep point and a tangent to the arc at the start point." ],
          "parameters" : {
            "start_pt" : "Arc start Point.\n",
            "sweep_pt" : "Arc sweep Point.\n",
            "tan" : "Tangent vector at start point.\n"
          },
          "rtype" : "Arc",
          "rvalue" : "Arc\n",
          "types" : {
            "start_pt" : "Point\n",
            "sweep_pt" : "Point\n",
            "tan" : "Vec\n"
          }
        },
        "end" : 437,
        "name" : "from_tan",
        "start" : 411
      }, {
        "code" : [ "    def from_pts(center,start_pt,sweep_pt,is_major=False):", "        \"\"\" Returns an arc using a center, a start point and a sweep point.", "            ", "            :param center: Center Point of Arc.", "            :type center: Point", "            :param start_pt: Start Point of Arc.", "            :type start_pt: Point", "            :param sweep_pt: Sweep Point of Arc.", "            :type sweep_pt: Point", "            :param is_major: Boolean Value.", "            :type is_major: bool", "            :result: Arc", "            :rtype: Arc", "            ", "        \"\"\"", "        ", "        radius = center.distance(start_pt)", "        angle = Vec(center, start_pt).angle(Vec(center, sweep_pt))", "        ", "        if is_major:", "            angle = 2*math.pi - angle", "            cs = CS(center, Vec(center, start_pt), Vec(center, sweep_pt).inverted())", "        else:", "            cs = CS(center, Vec(center, start_pt), Vec(center, sweep_pt))    ", "        return Arc(cs, radius, angle)", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns an arc using a center, a start point and a sweep point." ],
          "parameters" : {
            "center" : "Center Point of Arc.\n",
            "is_major" : "Boolean Value.\n",
            "start_pt" : "Start Point of Arc.\n",
            "sweep_pt" : "Sweep Point of Arc.\n"
          },
          "rtype" : "Arc",
          "rvalue" : "Arc\n",
          "types" : {
            "center" : "Point\n",
            "is_major" : "bool\n",
            "start_pt" : "Point\n",
            "sweep_pt" : "Point\n"
          }
        },
        "end" : 469,
        "name" : "from_pts",
        "start" : 444
      }, {
        "code" : [ "    def thru_pts(start_pt, mid_pt, end_pt):", "        \"\"\" Returns an arc that goes through a startpoint, midpoint and endpoint", "                ", "            :param start_pt: Start Point of Arc.", "            :type start_pt: Point", "            :param mid_pt: Mid Point of Arc.", "            :type mid_pt: Point", "            :param end_pt: End Point of Arc.", "            :type end_pt: Point", "            :result: Arc", "            :rtype: Arc", "            ", "        \"\"\"", "    ", "    ", "        v1 = Vec(start_pt, mid_pt)", "        v2 = Vec(start_pt, end_pt)", "        v3 = Vec(end_pt, mid_pt)", "        ", "        try:", "            xl = v1.cross(v3).length", "            if xl == 0 : return False", "                ", "            rad = 0.5*v1.length*v2.length*v3.length/xl        ", "            denom = 2*xl*xl", "            ", "            a1 = v3.length*v3.length*v1.dot(v2)/denom", "            a2 = v2.length*v2.length*v1.dot(v3)/denom", "            a3 = v1.length*v1.length*(-v2.dot(v3))/denom", "            center = start_pt*a1 + mid_pt*a2 + end_pt*a3", "            ", "            #test to see which arc between start_pt and end_pt contains mid_pt", "            #condition given by the angle between v1 and the perpendicular vector to v2 being acute", "            pln_normal = Vec(center, start_pt).cross(Vec(center, end_pt))", "            if pln_normal.length == 0:", "                pln_normal = v1.cross(v2)", "            v_perp = v2.cross(pln_normal)", "            ", "            try:", "                arc_out = Arc.from_pts(center,start_pt,end_pt, not v1.dot(v_perp))", "            except:", "                angle = Vec(center,start_pt).angle(Vec(center, end_pt))", "                radius = center.distance(start_pt)", "                cs = CS(center, Vec(center, start_pt), Vec(center, mid_pt))", "                arc_out = Arc(cs, radius, angle)", "            return arc_out   ", "            " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns an arc that goes through a startpoint, midpoint and endpoint" ],
          "parameters" : {
            "end_pt" : "End Point of Arc.\n",
            "mid_pt" : "Mid Point of Arc.\n",
            "start_pt" : "Start Point of Arc.\n"
          },
          "rtype" : "Arc",
          "rvalue" : "Arc\n",
          "types" : {
            "end_pt" : "Point\n",
            "mid_pt" : "Point\n",
            "start_pt" : "Point\n"
          }
        },
        "end" : 519,
        "name" : "thru_pts",
        "start" : 473
      }, {
        "code" : [ "    def best_fit(pts_in):", "        \"\"\" Returns a best fit arc using the modified least squares method.", "        ", "            :param pts_in: Points to fit Arc to.", "            :type pts_in: [Point]", "            :result: Best fit Arc", "            :rtype: Arc", "            ", "        \"\"\"", "        ", "        # Get the number of input points", "        cnt = len(pts_in)", "        # An Arc needs at least 3 points", "        if len(pts_in) < 2 :", "            raise GeometricError(\"Please provide more points\") ", "        x, y, x, xsq, ysq, xy, xysq, xsqy, xcube, ycube = [0]*10", "        ", "        # Get new point values for the center point of the arc", "        for pt in pts_in :", "            x += pt.x ", "            y += pt.y", "            xsq += pt.x*pt.x", "            ysq += pt.y*pt.y", "            xy += pt.x*pt.y", "            xysq += pt.x*pt.y*pt.y", "            xsqy += pt.x*pt.x*pt.y", "            xcube += pt.x*pt.x*pt.x", "            ycube += pt.y*pt.y*pt.y", "        ", "        # Get the center point for the arc", "        A = cnt*xsq - x*x", "        B = cnt*xy - x*y", "        C = cnt*ysq - y*y", "        D = 0.5*(cnt*xysq - x*ysq + cnt*xcube - x*xsq)", "        E = 0.5*(cnt*xsqy - y*xsq + cnt*ycube - y*ysq)", "        ", "        denom = A*C - B*B", "        if (denom != 0):", "            center = Point((D*C - B*E)/denom, (A*E - B*D)/denom)", "        else: ", "             raise GeometricError(\"A*C == B*B ... I Cannot find center of this Arc\") ", "        ", "        # Get the radius of the arc by getting the average distance from the points to the center", "        rad = sum([pt.distance(center) for pt in pts_in])/cnt", "        ", "        # Create segments between all the points and the center", "        segs = [Segment(center,pt) for pt in pts_in]", "        # The reference segment will be the first segment", "        ref_vec = segs[0].vec", "        for seg in segs:", "            # Get the angle between all the segments and the reference segment", "            seg.angle = ref_vec.angle(seg.vec)", "            # Make sure the ange is not negative", "            if ref_vec.cross(seg.vec).z < 0 : seg.angle = - seg.angle", "            ", "        # Sort the segments by angle", "        segs = sorted(segs, key=lambda seg: seg.angle)", "        # Get the sweep angle", "        sweep = segs[-1].angle - segs[0].angle", "        ", "        # Orient the CS with the segment with the smallest angle", "        cs = CS(center,segs[0].vec,segs[1].vec)", "        return Arc(cs,rad,sweep)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a best fit arc using the modified least squares method." ],
          "parameters" : {
            "pts_in" : "Points to fit Arc to.\n"
          },
          "rtype" : "Arc",
          "rvalue" : "Best fit Arc\n",
          "types" : {
            "pts_in" : "[Point]\n"
          }
        },
        "end" : 589,
        "name" : "best_fit",
        "start" : 526
      } ],
      "documentation" : {
        "description" : [ "a circle class" ]
      },
      "end" : 589,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_circle.py",
      "name" : "Arc",
      "references" : {
        "classes" : {
          "A" : 3,
          "Arc" : 9,
          "B" : 5,
          "C" : 3,
          "CS" : 6,
          "D" : 3,
          "E" : 3,
          "EPSILON" : 2,
          "HasBasis" : 1,
          "Intersector" : 1,
          "Plane" : 1,
          "Point" : 2,
          "Segment" : 1,
          "Vec" : 34
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "best_fit" : 1,
          "deval" : 1,
          "deval_pln" : 1,
          "ept" : 1,
          "epts" : 1,
          "eval" : 1,
          "eval_pln" : 1,
          "from_pts" : 1,
          "from_tan" : 1,
          "is_major" : 1,
          "is_minor" : 1,
          "is_semicircle" : 1,
          "length" : 1,
          "near" : 1,
          "near_pt" : 1,
          "origin" : 1,
          "reciprocal" : 1,
          "split_by" : 1,
          "spt" : 1,
          "thru_pts" : 1
        }
      },
      "start" : 143
    },
    "3a3adcfe-22b9-44db-8979-800ea9993468" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "import decodes", "from decodes.core import *", "#constructs an outie", "outie = decodes.make_out(decodes.Outies.Rhino)", "", "#adds geometry to this outie", "outie.put(Point(1,2))", "", "#draws everything in this outie to our CAD environment", "outie.draw()" ],
          "end" : 24,
          "start" : 15
        },
        "description" : "\nUsing an \"outie\" to draw geometry to a given CAD environment\n",
        "end" : 15,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "2.01.E01f", "Simply creating and manipulating geometry won't mean much if we can't see it, and more importantly transport it to a traditional CAD context where we can put it to use." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01f.py",
      "name" : "2.01.E01f.py",
      "references" : {
        "classes" : {
          "Point" : 1
        }
      },
      "required" : [ "some_geometry (Geometry) Some geometry we'd like to draw" ],
      "result" : [ "None" ]
    },
    "3b92bb27-57c0-4883-98a6-97a5828bfdf2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#set the diameter of the tool", "tool_spacing = 0.03", "#set the number of u and v divisions", "u_divs = int((surf.u1 - surf.u0)//tool_spacing)", "v_divs = int((surf.v1 - surf.v0)//tool_spacing)", "# create a Polyline for each of the u and v divisions", "u_lines = [surf.isopolyline(u_val = u, res = v_divs) for u in Interval().divide(u_divs)]", "v_lines = [surf.isopolyline(v_val = v, res = u_divs) for v in Interval().divide(v_divs)]", "    ", "" ],
          "end" : 25,
          "start" : 15
        },
        "description" : "\nDivides a Surface evenly along its isoparms to develop toolpaths for a CNC mill.\n",
        "end" : 15,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.05.L03a", "Given a Surface and a swap bool, divide the Surface evenly along its isoparms to develop toolpaths for a CNC mill." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Toolpathing/4.05.L03a.py",
      "name" : "4.05.L03a.py",
      "references" : {
        "classes" : {
          "Interval" : 2
        }
      },
      "required" : [ "surf (Surface) A Surface to create toolpaths from." ],
      "result" : [ "u_lines([PLine]) PLines representing the u direction cutpaths.", "v_lines([PLine]) PLines representing the v direction cutpaths." ]
    },
    "3bf2bbb0-20fb-4419-b8e9-533f46edff81" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_color.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Color constructor.", "        ", "            :param a: First color value (between 0.0 and 1.0). Defaults to 0.5.", "            :type a: float", "            :param b: Second color value (between 0.0 and 1.0). Defaults to 0.5.", "            :type b: float", "            :param c: Third color value (between 0.0 and 1.0). Defaults to 0.5.", "            :type c: float", "            :result: Color object.", "            :rtype: Color", "        \"\"\"", "        if a is None : self.r,self.g,self.b = 0.5,0.5,0.5", "        elif b is None or c is None : " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Color constructor." ],
          "parameters" : {
            "a" : "First color value (between 0.0 and 1.0). Defaults to 0.5.\n",
            "b" : "Second color value (between 0.0 and 1.0). Defaults to 0.5.\n",
            "c" : "Third color value (between 0.0 and 1.0). Defaults to 0.5.\n"
          },
          "rtype" : "Color",
          "rvalue" : "Color object.\n",
          "types" : {
            "a" : "float\n",
            "b" : "float\n",
            "c" : "float\n"
          }
        },
        "end" : 23,
        "name" : "__init__",
        "start" : 11
      }, {
        "code" : [ "    def hue(self):  ", "        \"\"\" Returns hue value of this color.", "        ", "            :result: Decimal value representing hue.", "            :rtype: float", "        \"\"\"", "        return colorsys.rgb_to_hsv(self.r,self.g,self.b)[0]", "    @property" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns hue value of this color." ],
          "rtype" : "float",
          "rvalue" : "Decimal value representing hue.\n"
        },
        "end" : 44,
        "name" : "hue",
        "start" : 37
      }, {
        "code" : [ "    def sat(self):  ", "        \"\"\" Returns saturation value of this color.", "        ", "            :result: Decimal value representing saturation.", "            :rtype: float", "        \"\"\"        ", "        return colorsys.rgb_to_hsv(self.r,self.g,self.b)[1]", "    @property" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns saturation value of this color." ],
          "rtype" : "float",
          "rvalue" : "Decimal value representing saturation.\n"
        },
        "end" : 52,
        "name" : "sat",
        "start" : 45
      }, {
        "code" : [ "    def val(self):  ", "        \"\"\" Returns the numeric value of this color.", "        ", "            :result: Decimal value representing this color.", "            :rtype: float", "        \"\"\"    ", "        return colorsys.rgb_to_hsv(self.r,self.g,self.b)[2]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the numeric value of this color." ],
          "rtype" : "float",
          "rvalue" : "Decimal value representing this color.\n"
        },
        "end" : 60,
        "name" : "val",
        "start" : 53
      }, {
        "code" : [ "    def y(self):  ", "        \"\"\" Returns the y-value of this color.", "        ", "            :result: y-value of this color.", "            :rtype: float", "        \"\"\"", "        return colorsys.rgb_to_yiq(self.r,self.g,self.b)[0]", "    @property" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the y-value of this color." ],
          "rtype" : "float",
          "rvalue" : "y-value of this color.\n"
        },
        "end" : 69,
        "name" : "y",
        "start" : 62
      }, {
        "code" : [ "    def i(self):  ", "        \"\"\" Returns the i-value of this color.", "        ", "            :result: i-value of this color.", "            :rtype: float", "        \"\"\"        ", "        return colorsys.rgb_to_yiq(self.r,self.g,self.b)[1]", "    @property" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the i-value of this color." ],
          "rtype" : "float",
          "rvalue" : "i-value of this color.\n"
        },
        "end" : 77,
        "name" : "i",
        "start" : 70
      }, {
        "code" : [ "    def q(self):  ", "        \"\"\" Returns the q-value of this color.", "        ", "            :result: q-value of this color.", "            :rtype: float", "        \"\"\"        ", "        return colorsys.rgb_to_yiq(self.r,self.g,self.b)[2]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the q-value of this color." ],
          "rtype" : "float",
          "rvalue" : "q-value of this color.\n"
        },
        "end" : 85,
        "name" : "q",
        "start" : 78
      }, {
        "code" : [ "    def RGB(r,g,b):", "        \"\"\" Creates a color object from RGB values.", "        ", "            :param r: R color value (between 0.0 and 1.0). ", "            :type r: float", "            :param g: G color value (between 0.0 and 1.0). ", "            :type g: float", "            :param b: B color value (between 0.0 and 1.0). ", "            :type b: float", "            :result: Color object.", "            :rtype: Color", "        \"\"\"", "        return Color(r,g,b)", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Creates a color object from RGB values." ],
          "parameters" : {
            "b" : "B color value (between 0.0 and 1.0). \n",
            "g" : "G color value (between 0.0 and 1.0). \n",
            "r" : "R color value (between 0.0 and 1.0). \n"
          },
          "rtype" : "Color",
          "rvalue" : "Color object.\n",
          "types" : {
            "b" : "float\n",
            "g" : "float\n",
            "r" : "float\n"
          }
        },
        "end" : 100,
        "name" : "RGB",
        "start" : 87
      }, {
        "code" : [ "    def HSB(h,s=1,b=1):", "        \"\"\" Creates a color object from HSB values.", "        ", "            :param h: H color value (between 0.0 and 1.0). ", "            :type h: float", "            :param s: S color value (between 0.0 and 1.0). Defaults to 1.", "            :type s: float", "            :param b: B color value (between 0.0 and 1.0). Defaults to 1.", "            :type b: float", "            :result: Color object.", "            :rtype: Color", "        \"\"\"", "        clr = colorsys.hsv_to_rgb(h,s,b)", "        #print clr[0],clr[1],clr[2]", "        return Color(clr[0],clr[1],clr[2])", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Creates a color object from HSB values." ],
          "parameters" : {
            "b" : "B color value (between 0.0 and 1.0). Defaults to 1.\n",
            "h" : "H color value (between 0.0 and 1.0). \n",
            "s" : "S color value (between 0.0 and 1.0). Defaults to 1.\n"
          },
          "rtype" : "Color",
          "rvalue" : "Color object.\n",
          "types" : {
            "b" : "float\n",
            "h" : "float\n",
            "s" : "float\n"
          }
        },
        "end" : 117,
        "name" : "HSB",
        "start" : 102
      }, {
        "code" : [ "    def interpolate(c0,c1,t=0.5):", "        \"\"\" Returns a new color interpolated from two Color objects.", "        ", "            :param c0: First Color object", "            :type c0: Color", "            :param c1: Second Color object", "            :type c1: Color", "            :param t: Interpolation value (between 0.0 and 1.0). Defaults to 0.5.", "            :type t: float", "            :result: Interpolated Color object.", "            :rtype: Color", "        \"\"\"", "        r = (1-t) * c0.r + t * c1.r", "        g = (1-t) * c0.g + t * c1.g", "        b = (1-t) * c0.b + t * c1.b", "        return Color(r,g,b)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a new color interpolated from two Color objects." ],
          "parameters" : {
            "c0" : "First Color object\n",
            "c1" : "Second Color object\n",
            "t" : "Interpolation value (between 0.0 and 1.0). Defaults to 0.5.\n"
          },
          "rtype" : "Color",
          "rvalue" : "Interpolated Color object.\n",
          "types" : {
            "c0" : "Color\n",
            "c1" : "Color\n",
            "t" : "float\n"
          }
        },
        "end" : 135,
        "name" : "interpolate",
        "start" : 119
      }, {
        "code" : [ "    def interpolate2d(u0v0, u0v1, u1v0, u1v1,u=0.5,v=0.5):", "        \"\"\" Returns a new color interpolated from four Color objects.", "        ", "            :param u0v0: Color object at bottom left corner", "            :type u0v0: Color", "            :param u0v1: Color object at top left corner", "            :type u0v1: Color", "            :param u1v0: Color object at bottom right corner", "            :type u1v0: Color", "            :param u1v1: Color object at top right corner", "            :type u1v1: Color", "            :param u: Interpolation value (between 0.0 and 1.0). Defaults to 0.5.", "            :type u: float", "            :param v: Interpolation value (between 0.0 and 1.0). Defaults to 0.5.", "            :type v: float", "            :result: Interpolated Color object.", "            :rtype: Color", "        \"\"\"", "        c1 = Color().interpolate(u1v0,u1v1,v)", "        c0 = Color().interpolate(u0v0,u0v1,v)", "        return Color().interpolate(c0,c1,u)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a new color interpolated from four Color objects." ],
          "parameters" : {
            "u" : "Interpolation value (between 0.0 and 1.0). Defaults to 0.5.\n",
            "u0v0" : "Color object at bottom left corner\n",
            "u0v1" : "Color object at top left corner\n",
            "u1v0" : "Color object at bottom right corner\n",
            "u1v1" : "Color object at top right corner\n",
            "v" : "Interpolation value (between 0.0 and 1.0). Defaults to 0.5.\n"
          },
          "rtype" : "Color",
          "rvalue" : "Interpolated Color object.\n",
          "types" : {
            "u" : "float\n",
            "u0v0" : "Color\n",
            "u0v1" : "Color\n",
            "u1v0" : "Color\n",
            "u1v1" : "Color\n",
            "v" : "float\n"
          }
        },
        "end" : 158,
        "name" : "interpolate2d",
        "start" : 137
      }, {
        "code" : [ "    def average(colors = []):", "        \"\"\" Returns a new color that is the average of a list of Color objects.", "        ", "            :param c: Color Objects", "            :type c: List", "            :result: Averaged Color object.", "            :rtype: Color", "        \"\"\"", "        try:", "            n = len(colors)", "        except:", "            n = 0", "        if n== 0:", "            return Color(1.0)", "        r,g,b = 0,0,0", "        for c in colors:", "            r += c.r", "            g += c.g", "            b += c.b", "        return Color(r/n,g/n,b/n)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a new color that is the average of a list of Color objects." ],
          "parameters" : {
            "c" : "Color Objects\n"
          },
          "rtype" : "Color",
          "rvalue" : "Averaged Color object.\n",
          "types" : {
            "c" : "List\n"
          }
        },
        "end" : 181,
        "name" : "average",
        "start" : 161
      }, {
        "code" : [ "        return \"color[{0},{1},{2}]\".format(self.r,self.g,self.b)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 184,
        "name" : "__repr__",
        "start" : 183
      }, {
        "code" : [ "        \"\"\" Overloads the equal **(==)** operator for Color identity.", "        ", "            :param other: Color to be compared.", "            :type other: Color", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"    ", "        bool = True", "        if abs(self.r - other.r) > 1.0/255:", "            bool = False", "        if abs(self.g - other.g) > 1.0/255:", "            bool = False", "        if abs(self.b - other.b) > 1.0/255:", "            bool = False                       ", "        return bool", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the equal **(==)** operator for Color identity." ],
          "parameters" : {
            "other" : "Color to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Color\n"
          }
        },
        "end" : 202,
        "name" : "__eq__",
        "start" : 186
      }, {
        "code" : [ "        \"\"\" Overloads the not equal **(!=)** operator for Color identity.", "        ", "            :param other: Color to be compared.", "            :type other: Color", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"", "        bool = False", "        if abs(self.r - other.r) > 1.0/255:", "            bool = True", "        if abs(self.g - other.g) > 1.0/255:", "            bool = True", "        if abs(self.b - other.b) > 1.0/255:", "            bool = True                       ", "        return bool        ", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the not equal **(!=)** operator for Color identity." ],
          "parameters" : {
            "other" : "Color to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Color\n"
          }
        },
        "end" : 220,
        "name" : "__ne__",
        "start" : 204
      } ],
      "documentation" : {
        "description" : [ "a simple color class" ]
      },
      "end" : 220,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_color.py",
      "name" : "Color",
      "references" : {
        "classes" : {
          "Color" : 9
        },
        "functions" : {
          "__eq__" : 1,
          "__init__" : 1,
          "__ne__" : 1,
          "__repr__" : 1,
          "average" : 1,
          "hue" : 1,
          "i" : 1,
          "interpolate" : 1,
          "interpolate2d" : 1,
          "q" : 1,
          "sat" : 1,
          "val" : 1,
          "y" : 1
        }
      },
      "start" : 6
    },
    "3c0ba38f-5305-4ce9-bfdb-13f57b97f71b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class SBin():", "    # construct a bin with a remainder and a cut panel", "    def __init__(self, _remainder, _panels = []):", "        self.panels = _panels", "        self.remainder = _remainder", "        ", "    # method to create a list of cut panels ", "    def cut(self, width = 1.0):", "        result = []", "        # for item in remainder pieces:", "        for i in range(len(self.remainder)):", "            # create a new SBin that is a copy", "            new_bin = SBin(copy.copy(self.remainder),copy.copy(self.panels))", "            # cut the one side of the bin", "            cut = panel_cut(new_bin.remainder, width, i)", "            # if it is a valid cut: add it to the list of results", "            if cut[2]:", "                # define the valid panels ", "                new_bin.panels.append(cut[0])", "                # define the invalid panels", "                new_bin.remainder = cut[1]", "                # append the new bin", "                result.append(new_bin)", "            else:", "                return None", "        return result" ],
          "end" : 42,
          "start" : 16
        },
        "description" : "\nBin Class\nClass that stores recursively subdivided panels, and divides them according to their validity. \n",
        "end" : 16,
        "start" : 13
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Dennis Shelden/4.03.F02d.py",
      "name" : "4.03.F02d.py",
      "references" : {
        "classes" : {
          "SBin" : 2,
          "_panels" : 2,
          "_remainder" : 2
        }
      }
    },
    "3f2787f7-741a-47f3-8d69-0e38b22fbb18" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "ln_a = Segment(pt_a, vec_a)", "ln_a.set_color(0.25,0.40,0.0)", "ln_a.set_weight(2.0)" ],
          "end" : 17,
          "start" : 15
        },
        "description" : "\nSetting the color of a piece of Decodes Geometry\n",
        "end" : 15,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "2.01.E01e", "Any piece of Decodes geometry may be assigned a display color and a \"draw weight\"" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01e.py",
      "name" : "2.01.E01e.py",
      "references" : {
        "classes" : {
          "Segment" : 1
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "410136f5-6875-4957-b04d-eeae54500e44" : {
      "code" : [ "    xform = Xform.translation(Point(4,1)) ", "    xform *= Xform.rotation(center=Point(),angle=math.pi/3, axis=Vec(0,1,1))", "    tk = DzTileK(xf=xform,rlvl=0)", "    out_0.put(tk.draw())", "", "    inflt1 = tk.inflate()", "    for tile in inflt1 : ", "        out_1.put(tile.draw())", "        inflt2 = tile.inflate()", "        for tile in inflt2 : out_2.put(tile.draw())", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 378,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "inflationK",
      "start" : 368
    },
    "41dc0e68-49fe-4205-bfb1-aa4c98b8cf1f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def blob(t):", "    # define a number of values with mathematical functions", "    c = math.cos(2*math.pi*t)", "    s = math.sin(2*math.pi*t)", "    r = 50*(1 + rad*math.cos(4*math.pi*t) + alpha*math.cos(6*math.pi*t))", "    # create a Point based on the mathematical values", "    pt_out = Point(r*c, r*s)", "    return pt_out", "" ],
          "end" : 28,
          "start" : 19
        },
        "description" : "\nBlob by D1 and D2\nMethod to create a blobby curve based on a radius and an alpha value\n",
        "end" : 19,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "4.04.L05b", "Create a solution space matrix of blobby curves." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Blobs/4.04.L05b.py",
      "name" : "4.04.L05b.py",
      "references" : {
        "classes" : {
          "Point" : 1
        }
      },
      "required" : [ "rad (float) Radius of blob.", "alpha ([float]) Decimal value to create the blob." ],
      "result" : [ "crv_out (Curve) A close curve with different shape and size. A portion of the curves will be self-intersecting." ]
    },
    "4279e637-f83c-41f2-b578-ac5f3282c47f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def spiroline(r0,r1,p,clr=Color(),z=0.0):", "    res_per_turn = 36", "    rad_sum = r0+r1", "    num_of_turns = int(r1 / gcd(r0,r1))", "    ", "    pts = [Point(r0+r1+p,0,z)]", "    for t in Interval(0,math.pi*2*num_of_turns)/(res_per_turn*num_of_turns):", "        x = (rad_sum)*math.cos(t) + p*math.cos((rad_sum)*t/r1)", "        y = (rad_sum)*math.sin(t) + p*math.sin((rad_sum)*t/r1)", "        pts.append(Point(x,y,z))", "        ", "    segs = []", "    for n in range(len(pts)) : ", "        seg = Segment(pts[n-1],pts[n])", "        seg.set_color(clr)", "        segs.append(seg)", "    return segs", "" ],
          "end" : 34,
          "start" : 16
        },
        "description" : "\n",
        "end" : 16,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "clrs = [Color(i/sample_count,0.75,0.25) for i in range(sample_count)]", "lines = []", "for i in range(sample_count):", "    pos = pos_range.eval(i/sample_count)", "    lines.extend(spiroline(rad_0,rad_1,pos,clrs[i],i))" ],
          "end" : 40,
          "start" : 36
        },
        "description" : "\n",
        "end" : 36,
        "start" : 35
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/Loose Examples/2.XX.XX - Spirograph/2.E02d.py",
      "name" : "2.E02d.py",
      "references" : {
        "classes" : {
          "Color" : 2,
          "Interval" : 1,
          "Point" : 2,
          "Segment" : 1
        }
      }
    },
    "42e30788-c7af-4393-8c9b-2acb61d4461a" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def does_cast_shadow(pt, vec, site, buildings):", "    # create a ray with the given Point and Vec", "    ray = Ray(pt,vec)", "    # test if this ray intersects the site", "    if xsec.of(ray,site) : ", "        return True", "    ", "    # if not, test the surrounding buildings", "    for face in buildings:", "        if xsec.of(ray,face) : ", "            return True", "" ],
          "end" : 31,
          "start" : 19
        },
        "description" : "\nTest for Shadow Casting on Site or Surrounding Buildings\n",
        "end" : 19,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "", "intx = Interval(0,15)", "# define Bounds for the voxel", "envelope = Bounds(ival_x =intx,ival_y = Interval(0,25),ival_z = Interval(0,20))", "# create a VoxelField with Bounds and x,y,z step sizes", "vf = VoxelField(envelope, 10, 10, 10)", "# initiate an Intersector object", "xsec = Intersector()", "", "# make a container to store points not touching a site", "slices = [[] for z in range(vf.res_z)]", "proj_pts = []", "# for every x value in the VovexlField resolution: ", "for x in range(vf.res_x): ", "    # for every y value in the VovexlField resolution: ", "    for y in range(vf.res_y): ", "        # for every z value in the VovexlField resolution: ", "        for z in range(vf.res_z):", "            # create a Point with the x,y, and z values", "            pt = vf.cpt_at(x,y,z)", "            # for every Vec in Vecs:", "            for vec in vecs:", "                # create a ray with the Point and the solar Vec", "                ray = Ray(pt,vec)", "                # for every face of the bldgs:", "                for face in bldgs:", "                    # if the Points intersect with a face of the bldgs: ", "                    if xsec.of(ray,face):", "                        # flag this Point", "                        vf.set(x,y,z,.01)", "                # if the Ray doesn't intersect the building:", "                if vf.get(x,y,z) != .01:", "                    # if the Ray doesn't intersect the site either:", "                    if xsec.of(ray,geom):", "                        # increase the value of the counter", "                        vf.set(x,y,z,1)", "                        proj_pts.append(xsec[0])", "                        break", "            # if this point found an intersection:", "            if vf.get(x,y,z) == 1:", "                # stop looking for intersections in this stack", "                break", "            # append any points that don't produce intersections ", "            else: slices[z].append(pt)", "" ],
          "end" : 79,
          "start" : 35
        },
        "description" : "\nGiven solar vectors, and building PLines evaluate the solar incidence of a VoxelField onto a given site. \n[noprint]\n",
        "end" : 35,
        "start" : 32
      } ],
      "documentation" : {
        "description" : [ "4.04.F03b", "Given solar vectors, and building PLines evaluate the solar incidence of a VoxelField onto a given site." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Right to Light/4.04.F03b.py",
      "name" : "4.04.F03b.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "Intersector" : 1,
          "Interval" : 3,
          "Ray" : 2,
          "VoxelField" : 1
        }
      },
      "required" : [ "bldgs ([PLine]) Building PLines surrounding the site.", "geom (PLine) Site PLine for projecting onto.", "vecs ([Vec]) Solar Vecs at a given time and place." ],
      "result" : [ "slices ([[Point]]) Points that don't touch the site.", "proj_pts ([Point]) Points projected to the site." ]
    },
    "46705747-1ac9-4979-a3fc-c5fa39955efc" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# set the resolution", "res = 10", "", "# for every Segment in segs:", "for seg in segs : ", "    pts = []", "    # for every index in the res + 1:", "    for n in range(res+1):", "        # evaluate a Segment, and get Points", "        pt = seg.eval(n/float(res))", "        # evaluate the Surface at a U and V value", "        pt = surf.deval(pt.x, pt.y)", "        # add the Point to the list", "        pts.append(pt)", "    # create a PLine with the Segment Points", "    new_pline = PLine(pts)" ],
          "end" : 32,
          "start" : 16
        },
        "description" : "\nProject Segments\nProjects a given collection of Segments onto a Surface\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.F02e", "Given a Surface function, and a list of Segments, project the Segments onto the Surface." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Williams Biot-Savart/4.07.F02e.py",
      "name" : "4.07.F02e.py",
      "references" : {
        "classes" : {
          "PLine" : 1
        }
      },
      "required" : [ "segs ([Segment]) Splitted Segments.", "surf (function) Surface function." ],
      "result" : [ "new_pline ([PLine]) PLine representing the projected Segments." ]
    },
    "4814d02c-69fc-44b2-854a-ea44e4fb33a2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# create the DzTileA seed", "tiles = [DzTileA()]", "", "# for every generation of tiles:", "for n in range(iterations):", "    # create a container to hold inflated tiles", "    next_tiles = []", "    # for every tile in the current generation:", "    for tile in tiles : ", "        #inflate the tile, and store the results", "        next_tiles.extend(tile.inflate())", "    # set things up for the next generation of inflation", "    tiles = next_tiles", "", "" ],
          "end" : 28,
          "start" : 14
        },
        "description" : "\nCreate a DzTile tile, inflate it a number of times.\n",
        "end" : 14,
        "start" : 12
      } ],
      "documentation" : {
        "description" : [ "4.01.L05b", "Create a DzTile object and inflate the tile." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Danzer Tiling/4.01.L05b.py",
      "name" : "4.01.L05b.py",
      "references" : {
        "classes" : {
          "DzTileA" : 1
        }
      },
      "required" : [ "iterations (int) Number of subdivisions." ],
      "result" : [ "tiles ([DzTile]) Inflated Danzer Tiles." ]
    },
    "4838359c-4b4c-4458-a5cd-986c596b50bc" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "flock = [Bird() for n in range(count)]", "", "for step in range(count):", "    for bird in flock:", "        # create a steering vector", "        vec = Vec(bird.pos,goal_pt)", "        # if this Bird is not close to goal point:", "        if vec.length > close_enough : ", "            # steer Bird toward goal, slowing as target is approached", "            bird.steer( vec  - bird.vel )", "            bird.step()" ],
          "end" : 28,
          "start" : 18
        },
        "description" : "\nSimple Flocking Routine\nCreates a flock of Bird objects, and steers them toward a goal point\n",
        "end" : 18,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "4.02.L05b", "Move a flock of simple Birds toward a goal." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Birds/4.02.L05b.py",
      "name" : "4.02.L05b.py",
      "references" : {
        "classes" : {
          "Bird" : 1,
          "Vec" : 1
        }
      },
      "required" : [ "Bird (class) A simple Bird class", "goal_pt (Point) The point that the flock will seek", "close_enough (float) The distance from the goal that will cause Bird to stop", "count (int) The number of steps" ],
      "result" : [ "flock ([Bird]) A group of Birds with their history filled out" ]
    },
    "483eaf35-f39e-40b2-877c-6c370e3d3999" : {
      "code" : [ "    r_int = Interval.twopi()", "", "    r_ints = r_int.rand_interval(n)", "    pts = []", "    for i in range(n):", "        dist = random.uniform(1,size)", "        pts.append(CylCS().eval(dist, r_ints[i].b))", "    return pts", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 322,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "rand_points",
      "start" : 314
    },
    "49427bae-40e8-4d66-ab5d-f9caab6a48d2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# a curve for our rotational surface", "def curv_func(t):", "    return Point(t,math.sin(t)+1.2)", "crv = Curve(curv_func,Interval(0,math.pi*2))", "", "# a rotational surface about the x-axis", "v_domain =  Interval(math.pi,math.pi*2)", "surf_a = RotationalSurface(crv,axis = Vec(-1,0), dom_v = v_domain)", "", "# a handkerchief surface", "def func_b(u,v): ", "    return Point(u,v,((1/3)*u**3+u*v**2+2*(u**2-v**2))/4 )", "surf_b = Surface(func_b,Interval(-1,1),Interval(-1,1))", "", "# an umbrella surface", "def func_c(u,v): ", "    return Point(u*v,u,v**2)", "surf_c = Surface(func_c,Interval(0.01,1),Interval(-1,1))", "", "#a monkey saddle surface", "def func_d(u,v): ", "    return Point(x+u,y+v,(u**3-3*u*(v**2))/4)", "surf_d = Surface(func_d,Interval(-1,1),Interval(-1,1))", "", "# two halves of a monkey saddle surface", "surf_d1 = Surface(func_d, Interval(0,1), Interval(-1,1))", "surf_d2 = Surface(func_d, Interval(-1,0), Interval(-1,1))", "" ],
          "end" : 42,
          "start" : 14
        },
        "description" : "\nDefinition of Analysis Surfaces\nDefines a series of surfaces to analyze with the curvature tools\n",
        "end" : 14,
        "start" : 11
      } ],
      "documentation" : {
        "description" : [ "4.03.L05a", "Define surfaces to analyze with the curvature tools" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Post-Rational Panelization/4.03.L05a.py",
      "name" : "4.03.L05a.py",
      "references" : {
        "classes" : {
          "Curve" : 1,
          "Interval" : 12,
          "Point" : 4,
          "RotationalSurface" : 1,
          "Surface" : 5,
          "Vec" : 1
        }
      },
      "result" : [ "surf_a, surf_b, surf_c (Surface) Parametric surfaces" ]
    },
    "499efb31-ef9b-49cb-b574-40ccd564ba7b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# initialize an instance of the GrayScott object class", "scott = GrayScott()", "", "# seed this empty field with rectangles", "scott.set_rect(3,3,3,3)", "scott.set_rect(13,13,3,2)", "scott.set_rect(18,4,3,8)", "", "# for every generation to be produced:", "for n in range(max_gen):", "    # record the state of the GrayScott every so often", "    if n % stepsize == 0: scott.record() ", "    # update the GrayScott model", "    scott.step() ", "", "" ],
          "end" : 34,
          "start" : 18
        },
        "description" : "\nReaction-Diffusion Routine\nCreates a GrayScott object with some arbitrary 'seed' rectangles, and steps the simulation forward a given number of generations. A 'snapshot' of the state of the model is recorded every so often, as controlled by the 'stepsize' variable.\n",
        "end" : 18,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "4.02.L01b", "Given the GrayScott class defined in the previous example, perform the Reaction-Diffusion algorithma nd record the time history." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Reaction Diffusion/4.02.L01b.py",
      "name" : "4.02.L01b.py",
      "references" : {
        "classes" : {
          "GrayScott" : 1
        }
      },
      "required" : [ "GrayScott (Class) A Class that implements the Gray Scott Reaction-Diffusion algorithm.", "max_gen (int) The number of generations for the algorithm to run.", "stepsize (int) The number of generations to run before recording the state of the model.", "select_step (int) The recorded step of the model to visualize." ],
      "result" : [ "points (list of points) A list of points with color and weight set." ]
    },
    "4a4ea360-45cf-43e8-84ef-8ee95319641a" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create a graph of the mesh points", "msh = srf.surrogate", "graph  = msh.to_pt_graph()", "valence = 6", "", "# for each step in the relaxation", "for step in range(steps):", "    # create a new mesh", "    new_msh = Mesh()", "    # for each point in the old mesh:", "    for pi in range(len(msh.pts)):", "        # if it is not an edge:", "        if len(graph.edges[pi])>=valence:", "            # relax it", "            cntr = Point.centroid([msh.pts[n] for n in graph.edges[pi]])", "            new_msh.append(srf.project(cntr))", "        # else: do nothing", "        else: new_msh.append(msh.pts[pi])", "    ", "    # rebuild faces", "    for face in msh.faces:", "        if len(face)==3: new_msh.add_face(face[0], face[1], face[2])", "        if len(face)==4: new_msh.add_face(face[0], face[1], face[2], face[3])", "    ", "    msh = new_msh # overwrite the old mesh" ],
          "end" : 40,
          "start" : 15
        },
        "description" : "\nRelax a given surface using its surrogate\n",
        "end" : 15,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L05d", "Given a rotational surface and step count, produce a mesh whose vertices have been moved to more relaxed positions." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Mesh Relaxation/4.07.L05d.py",
      "name" : "4.07.L05d.py",
      "references" : {
        "classes" : {
          "Mesh" : 1,
          "Point" : 1
        }
      },
      "required" : [ "srf (Surface) A Surface whose mesh representation to relax", "steps (int) A step count." ],
      "result" : [ "a relaxed mesh" ]
    },
    "4b80538d-4f1b-490f-9f8b-15dffec461a0" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#a point along the curve", "pt_out = crv.func(t)", "", "#nearest neighbors of pt in question; used for discrete approx calcs", "pt_t, pt_plus, pt_minus = nearest_neighbors(crv,t)", "", "# draws a tangent line at t with res of discrete approx given by crv.tol", "vec_t = Vec(pt_plus - pt_minus)", "factor = crv.appx_length/(20*vec_t.length)", "ln_out = Segment(pt_t + vec_t*factor, pt_t - vec_t*factor)", "" ],
          "end" : 29,
          "start" : 18
        },
        "description" : "\nIllustrates the key geometric objects of tangent vector\n",
        "end" : 18,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "3.07.E03b", "Use of nearest neighbor calculations to draw Curve Tangent Line" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Geometric Properties/3.07.E03b.py",
      "name" : "3.07.E03b.py",
      "references" : {
        "classes" : {
          "Segment" : 1,
          "Vec" : 1
        }
      },
      "required" : [ "t (float) parameter at which to evaluate", "crv (Curve) a curve to evaluate", "nearest_neighbors (function) a function that returns the nearest neighbor points of a given evaluation parameter" ],
      "result" : [ "pt_out (Point) the point at parameter t", "ln_out (Segment) a line segment representing the curve tangent at the given parameter" ]
    },
    "4bb7ced7-e52a-4b93-aec9-06ea751456d1" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_vec.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Vector Constructor. ", "", "            :param a: a value.", "            :type a: float", "            :param b: b value", "            :type b: float", "            :param c: c value", "            :type c: float", "            :result: Vector object.", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec=Vec(1,1,1)", "                ", "                vec_1=Vec(Point(1,1,1))", "                ", "                vec_2=Vec(Point(0,0,0), Point(1,1,1))", "", "        \"\"\"", "        if a is None : a = 0.0", "        if b is None : b = 0.0", "        if c is None : c = 0.0", "", "        if all( hasattr(a,i) and hasattr(b,i) for i in ['x','y','z'] ) :", "            # we've been passed two things that act like points" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Vector Constructor." ],
          "parameters" : {
            "a" : "a value.\n",
            "b" : "b value\n",
            "c" : "c value\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Vector object.\n",
          "types" : {
            "a" : "float\n",
            "b" : "float\n",
            "c" : "float\n"
          }
        },
        "end" : 39,
        "name" : "__init__",
        "start" : 14
      }, {
        "code" : [ "    def x(self): ", "        \"\"\" Returns the x-value of this vector. ", "", "            :result: x value.", "            :rtype: float", "        \"\"\"", "        return self._x", "    @x.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the x-value of this vector." ],
          "rtype" : "float",
          "rvalue" : "x value.\n"
        },
        "end" : 61,
        "name" : "x",
        "start" : 54
      }, {
        "code" : [ "    def x(self,value): self._x = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 63,
        "name" : "x",
        "start" : 62
      }, {
        "code" : [ "    def y(self): ", "        \"\"\" Returns the y-value of this vector. ", "", "            :result: y value.", "            :rtype: float", "        \"\"\"", "        return self._y", "    @y.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the y-value of this vector." ],
          "rtype" : "float",
          "rvalue" : "y value.\n"
        },
        "end" : 72,
        "name" : "y",
        "start" : 65
      }, {
        "code" : [ "    def y(self,value): self._y = value", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 74,
        "name" : "y",
        "start" : 73
      }, {
        "code" : [ "    def z(self): ", "        \"\"\" Returns the z-value of this vector. ", "", "            :result: z value.", "            :rtype: float", "        \"\"\"", "        return self._z", "    @z.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the z-value of this vector." ],
          "rtype" : "float",
          "rvalue" : "z value.\n"
        },
        "end" : 83,
        "name" : "z",
        "start" : 76
      }, {
        "code" : [ "    def z(self,value): self._z = value", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 85,
        "name" : "z",
        "start" : 84
      }, {
        "code" : [ "    def tup(self):", "        \"\"\" Returns x, y, and z values of a vector.", "            ", "            :result: x, y and z values.", "            :rtype: float", "        \"\"\"", "        return self._x,self._y,self._z", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns x, y, and z values of a vector." ],
          "rtype" : "float",
          "rvalue" : "x, y and z values.\n"
        },
        "end" : 95,
        "name" : "tup",
        "start" : 88
      }, {
        "code" : [ "        \"\"\"| Overloads the addition **(+)** operator. ", "           | Returns a new vector that results from adding this vector's world coordinates to the other vector's world coordinates.", "        ", "           :param vec: Vec to be added.", "           :type vec: Vec", "           :result: New Vec.", "           :rtype: Vec", "           ", "           ::", "           ", "                my_vec + vec_1", "        \"\"\"    ", "        return Vec(self.x+vec.x , self.y+vec.y, self.z+vec.z)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the addition **(+)** operator.", "| Returns a new vector that results from adding this vector's world coordinates to the other vector's world coordinates." ],
          "parameters" : {
            "vec" : "Vec to be added.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "New Vec.\n",
          "types" : {
            "vec" : "Vec\n"
          }
        },
        "end" : 110,
        "name" : "__add__",
        "start" : 97
      }, {
        "code" : [ "        \"\"\"| Overloads the subtraction **(-)** operator. ", "           | Returns a new vector that results from subtracting this vector's world coordinates from the other vector's world coordinates.", "        ", "           :param vec: Vec to be subtracted.", "           :type vec: Vec", "           :result: New Vec.", "           :rtype: Vec", "           ", "           ::", "           ", "                my_vec - vec_1          ", "        \"\"\"    ", "        return Vec(self.x-vec.x , self.y-vec.y, self.z-vec.z)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the subtraction **(-)** operator.", "| Returns a new vector that results from subtracting this vector's world coordinates from the other vector's world coordinates." ],
          "parameters" : {
            "vec" : "Vec to be subtracted.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "New Vec.\n",
          "types" : {
            "vec" : "Vec\n"
          }
        },
        "end" : 125,
        "name" : "__sub__",
        "start" : 112
      }, {
        "code" : [ "        return self.__div__(other)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 128,
        "name" : "__truediv__",
        "start" : 127
      }, {
        "code" : [ "        \"\"\"| Overloads the division **(/)** operator. ", "           | Returns a new vector that results from dividing this vector's world coordinates by a given scalar.", "        ", "           :param scalar: Number to divide by", "           :type scalar: float", "           :result: New Vec.", "           :rtype: Vec", "           ", "           ::", "           ", "                my_vec / 2           ", "        \"\"\"  ", "        return Vec(self.x/float(scalar), self.y/float(scalar), self.z/float(scalar))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the division **(/)** operator.", "| Returns a new vector that results from dividing this vector's world coordinates by a given scalar." ],
          "parameters" : {
            "scalar" : "Number to divide by\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "New Vec.\n",
          "types" : {
            "scalar" : "float\n"
          }
        },
        "end" : 143,
        "name" : "__div__",
        "start" : 130
      }, {
        "code" : [ "        \"\"\"| Overloads the inversion **(-vec)** operator. ", "           | Inverts the direction of the vector.", "           | Returns a new inverted vector.", "        ", "           :result: Inverted Vec.", "           :rtype: Vec", "           ", "           ::", "                ", "                my_vec.__invert__()", "                ", "        \"\"\"  ", "        return self.inverted()", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the inversion **(-vec)** operator.", "| Inverts the direction of the vector.", "| Returns a new inverted vector." ],
          "rtype" : "Vec\n\n",
          "rvalue" : "Inverted Vec.\n"
        },
        "end" : 158,
        "name" : "__invert__",
        "start" : 145
      }, {
        "code" : [ "        \"\"\"| Overloads the arithmetic negation **(-vec)** operator. ", "           | Inverts the direction of the vector.", "           | Returns a new inverted vector.", "        ", "           :result: Inverted Vec.", "           :rtype: Vec", "           ", "        \"\"\"  ", "        return self.inverted()", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the arithmetic negation **(-vec)** operator.", "| Inverts the direction of the vector.", "| Returns a new inverted vector." ],
          "rtype" : "Vec",
          "rvalue" : "Inverted Vec.\n"
        },
        "end" : 169,
        "name" : "__neg__",
        "start" : 160
      }, {
        "code" : [ "        \"\"\"| Overloads the multiplication **(*)** operator. ", "           | If given a scalar, returns a new vector that results from multiplying this vector by the scalar.", "           | If given a vector, returns the cross product of this vector and the other vector.", "        ", "           :param other: Scalar or Vec to be multiplied.", "           :type other: float or Vec", "           :result: New Vec.", "           :rtype: Vec", "           ", "           ::", "           ", "                my_vec * vec_1", "        \"\"\"  ", "        from .dc_xform import Xform", "        if isinstance(other, Xform) :", "            return other*self" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the multiplication **(*)** operator.", "| If given a scalar, returns a new vector that results from multiplying this vector by the scalar.", "| If given a vector, returns the cross product of this vector and the other vector." ],
          "parameters" : {
            "other" : "Scalar or Vec to be multiplied.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "New Vec.\n",
          "types" : {
            "other" : "float or Vec\n"
          }
        },
        "end" : 186,
        "name" : "__mul__",
        "start" : 171
      }, {
        "code" : [ "        return \"vec[{0},{1},{2}]\".format(self.x,self.y,self.z)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 194,
        "name" : "__repr__",
        "start" : 193
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the Vec components.", "        ", "            :result: Tuple of Vec values.", "            :rtype: tuple", "        \"\"\"  ", "        return (self.x,self.y,self.z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the Vec components." ],
          "rtype" : "tuple",
          "rvalue" : "Tuple of Vec values.\n"
        },
        "end" : 202,
        "name" : "to_tuple",
        "start" : 196
      }, {
        "code" : [ "        \"\"\" Overloads the less than **(<)** operator for vector length.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec < (vec_1)", "        \"\"\"", "        return self.length2 < other.length2", "    def __le__(self, other):" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the less than **(<)** operator for vector length." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 216,
        "name" : "__lt__",
        "start" : 204
      }, {
        "code" : [ "        \"\"\" Overloads the less than or equal to **(<=)** operator for vector length.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "        \"\"\"", "        return self.length2 <= other.length2", "    def __eq__(self, other):" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the less than or equal to **(<=)** operator for vector length." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 225,
        "name" : "__le__",
        "start" : 217
      }, {
        "code" : [ "        \"\"\" Overloads the equal **(==)** operator for vector identity.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"    ", "        return self.is_equal(other)", "    def __ne__(self, other): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the equal **(==)** operator for vector identity." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 235,
        "name" : "__eq__",
        "start" : 226
      }, {
        "code" : [ "        \"\"\" Overloads the not equal **(!=)** operator for vector length.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"", "        return not self.is_equal(other)", "    def __gt__(self, other): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the not equal **(!=)** operator for vector length." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 245,
        "name" : "__ne__",
        "start" : 236
      }, {
        "code" : [ "        \"\"\" Overloads the greater than **(>)** operator for vector length.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "        \"\"\"", "        return self.length2 > other.length2", "    def __ge__(self, other): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the greater than **(>)** operator for vector length." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 254,
        "name" : "__gt__",
        "start" : 246
      }, {
        "code" : [ "        \"\"\" Overloads the greater or equal **(>=)** operator for vector length.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :result: Boolean result of comparison.", "            :rtype: bool", "        \"\"\"", "        return self.length2 >= other.length2", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the greater or equal **(>=)** operator for vector length." ],
          "parameters" : {
            "other" : "Vec to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 263,
        "name" : "__ge__",
        "start" : 255
      }, {
        "code" : [ "    def is_equal(self,other,tol=None):" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 265,
        "name" : "is_identical",
        "start" : 265
      }, {
        "code" : [ "        \"\"\" Returns True if the vectors are equal.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :param tol: Tolerance of difference that does not correspond to an actual distance, but is treated as a separate numeric delta for x, y, and z coordinates.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec.is_equal(other_vec)", "        \"\"\"    ", "        if tol is None: tol = EPSILON", "        def apxeq(a, b): return abs(a - b) < tol", "        ", "        try:", "            return all([apxeq(self.x,other.x),apxeq(self.y,other.y),apxeq(self.z,other.z)])", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the vectors are equal." ],
          "parameters" : {
            "other" : "Vec to be compared.\n",
            "tol" : "Tolerance of difference that does not correspond to an actual distance, but is treated as a separate numeric delta for x, y, and z coordinates.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n",
            "tol" : "float\n"
          }
        },
        "end" : 284,
        "name" : "is_equal",
        "start" : 266
      }, {
        "code" : [ "        \"\"\" Returns True if the vectors have equal direction.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :param tol: Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type tol: float            ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec.is_coincident(other_vec)", "        \"\"\"   ", "        return self.normalized().is_equal( other.normalized() , tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the vectors have equal direction." ],
          "parameters" : {
            "other" : "Vec to be compared.\n",
            "tol" : "Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n",
            "tol" : "float            \n"
          }
        },
        "end" : 302,
        "name" : "is_coincident",
        "start" : 288
      }, {
        "code" : [ "        \"\"\" Returns True if the vectors point in the general same direction, in other words, if they are coincident within a given angular tolerance, the default of which is PI/2. Useful in determining if an inversion is required to bring the vectors into better alignment.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec    ", "            :param tol: Angular tolerance of difference in radians.       ", "            :type tol: float                ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::  ", "            ", "                my_vec.is_similar(other_vec)", "        \"\"\"   ", "        return self.angle(other) <= tol", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the vectors point in the general same direction, in other words, if they are coincident within a given angular tolerance, the default of which is PI/2. Useful in determining if an inversion is required to bring the vectors into better alignment." ],
          "parameters" : {
            "other" : "Vec to be compared.\n",
            "tol" : "Angular tolerance of difference in radians.       \n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec    \n",
            "tol" : "float                \n"
          }
        },
        "end" : 319,
        "name" : "is_similar",
        "start" : 305
      }, {
        "code" : [ "        \"\"\" Returns True if the vectors have equal or opposite direction.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :param tol: Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type tol: float              ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec.is_parallel(other_vec)", "        \"\"\"   ", "        return self.is_coincident(other, tol) or self.inverted().is_coincident(other, tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the vectors have equal or opposite direction." ],
          "parameters" : {
            "other" : "Vec to be compared.\n",
            "tol" : "Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n",
            "tol" : "float              \n"
          }
        },
        "end" : 335,
        "name" : "is_parallel",
        "start" : 321
      }, {
        "code" : [ "        \"\"\" Returns True if the vectors are perpendicular to one another.", "        ", "            :param other: Vec to be compared.", "            :type other: Vec", "            :param tol: Angular tolerance of difference in radians.       ", "            :type tol: float                   ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec.is_perpendicular(other_vec)", "        \"\"\"   ", "        if tol is None: return self.dot(other) == 0.0", "        return abs(math.pi/2 - self.angle(other)) <= tol", "   " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the vectors are perpendicular to one another." ],
          "parameters" : {
            "other" : "Vec to be compared.\n",
            "tol" : "Angular tolerance of difference in radians.       \n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Vec\n",
            "tol" : "float                   \n"
          }
        },
        "end" : 352,
        "name" : "is_perpendicular",
        "start" : 337
      }, {
        "code" : [ "    def is_2d(self): ", "        \"\"\" Returns True if the vector is 2d.", "        ", "            :result: True if 2d.", "            :rtype: bool", "            ", "            ::", "            ", "                my_vec.is_2d", "        \"\"\"   ", "        return True if (self.z==0) else False", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns True if the vector is 2d." ],
          "rtype" : "bool\n\n",
          "rvalue" : "True if 2d.\n"
        },
        "end" : 368,
        "name" : "is_2d",
        "start" : 357
      }, {
        "code" : [ "    def length(self): ", "        \"\"\" Returns the length of this vector. Use vec.length2 when possible, as it is cheaper to calculate.", "        ", "            :result: Length of the Vec.", "            :rtype: float", "            ", "            ::", "            ", "                my_vec.length", "        \"\"\"", "        return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the length of this vector. Use vec.length2 when possible, as it is cheaper to calculate." ],
          "rtype" : "float\n\n",
          "rvalue" : "Length of the Vec.\n"
        },
        "end" : 381,
        "name" : "length",
        "start" : 370
      }, {
        "code" : [ "    def length2(self):", "        \"\"\" Length squared. Cheaper to calculate than vec.length.", "        ", "            :result: Length of the Vec.", "            :rtype: float", "            ", "            ::", "            ", "                my_vec.length2", "        \"\"\"", "        return self.x ** 2 + self.y ** 2 + self.z ** 2", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Length squared. Cheaper to calculate than vec.length." ],
          "rtype" : "float\n\n",
          "rvalue" : "Length of the Vec.\n"
        },
        "end" : 394,
        "name" : "length2",
        "start" : 383
      }, {
        "code" : [ "    def length(self,value): ", "        \"\"\" Sets the length of this vector.", "        ", "            :param value: New length of vector.", "            :type values: float", "            :result: Sets the length of Vec.", "        \"\"\"", "        factor = value / self.length", "        self.x *= factor", "        self.y *= factor", "        self.z *= factor", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the length of this vector." ],
          "parameters" : {
            "value" : "New length of vector.\n"
          },
          "rvalue" : "Sets the length of Vec.",
          "types" : {
            "values" : "float\n"
          }
        },
        "end" : 407,
        "name" : "length",
        "start" : 396
      }, {
        "code" : [ "    def interpolate(v0,v1,t=0.5):", "        \"\"\" Interpolates between vectors v0 and v1 at param t.", "        ", "            :param v0: First Vec.", "            :type v0: Vec", "            :param v1: Second Vec.", "            :type v1: Vec", "            :param t: Parameter to interpolate at between the vectors.", "            :type t: float", "            :result: Interpolated vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                Vec.interpolate(vec_1, vec_2)", "        \"\"\"", "        x = (1-t) * v0.x + t * v1.x", "        y = (1-t) * v0.y + t * v1.y", "        z = (1-t) * v0.z + t * v1.z", "        return Vec(x,y,z)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Interpolates between vectors v0 and v1 at param t." ],
          "parameters" : {
            "t" : "Parameter to interpolate at between the vectors.\n",
            "v0" : "First Vec.\n",
            "v1" : "Second Vec.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Interpolated vector.\n",
          "types" : {
            "t" : "float\n",
            "v0" : "Vec\n",
            "v1" : "Vec\n"
          }
        },
        "end" : 429,
        "name" : "interpolate",
        "start" : 409
      }, {
        "code" : [ "    def random(interval = None,normalize=True,constrain2d=False):", "        \"\"\" Returns a random vector within a given interval.", "        ", "            :param interval: Interval to get the random values from.", "            :type interval: Interval", "            :param normalize: If True, unitizes the Vec.", "            :type normalize: bool", "            :param constrain2d: If True, the Vec is constrained to 2d space. ", "            :type constrain2d: bool", "            :result: Random vector.", "            :rtype: Vec", "            ", "            ::", "                            ", "                Vec.random(Interval(1,10))", "        \"\"\"", "        if interval is None:", "            interval = Interval(-1,1)", "        x = random.uniform(interval.a,interval.b)", "        y = random.uniform(interval.a,interval.b)", "        z = random.uniform(interval.a,interval.b)", "        v = Vec(x,y) if constrain2d else Vec(x,y,z)", "        if normalize : return v.normalized()", "        return v", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a random vector within a given interval." ],
          "parameters" : {
            "constrain2d" : "If True, the Vec is constrained to 2d space. \n",
            "interval" : "Interval to get the random values from.\n",
            "normalize" : "If True, unitizes the Vec.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Random vector.\n",
          "types" : {
            "constrain2d" : "bool\n",
            "interval" : "Interval\n",
            "normalize" : "bool\n"
          }
        },
        "end" : 455,
        "name" : "random",
        "start" : 431
      }, {
        "code" : [ "    def average(vecs):", "        \"\"\" Returns the average of a list of vectors.", "        ", "            :param vecs: List of vectors to average. ", "            :type vecs: list", "            :result: Averaged vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                Vec.average(my_vec, vec_1)", "        \"\"\"", "        return Vec( ", "            sum([float(v.x) for v in vecs])/len(vecs) , " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns the average of a list of vectors." ],
          "parameters" : {
            "vecs" : "List of vectors to average. \n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Averaged vector.\n",
          "types" : {
            "vecs" : "list\n"
          }
        },
        "end" : 470,
        "name" : "average",
        "start" : 457
      }, {
        "code" : [ "    def bisector(v0,v1): ", "        \"\"\" Returns the normalized bisector of two vectors.", "        ", "            :param v0: First vector to get the bisector from.", "            :type v0: Vec", "            :param v1: Second vector to get the bisector from.", "            :type v1: Vec", "            :result: Bisector vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                Vec.bisector(vec_1, vec_2)", "        \"\"\"", "        if v0.is_parallel(v1): raise GeometricError(\"Cannot find the bisector of parallel vectors\")", "        return Vec.average([v0.normalized(),v1.normalized()]).normalized()", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns the normalized bisector of two vectors." ],
          "parameters" : {
            "v0" : "First vector to get the bisector from.\n",
            "v1" : "Second vector to get the bisector from.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Bisector vector.\n",
          "types" : {
            "v0" : "Vec\n",
            "v1" : "Vec\n"
          }
        },
        "end" : 492,
        "name" : "bisector",
        "start" : 476
      }, {
        "code" : [ "    def bisectors(v0,v1): ", "        \"\"\" Returns all possible normalized bisectors that result from comparing inverted and non-inverted versions of the two vectors.", "        ", "            :param v0: First vector to get the bisector from.", "            :type v0: Vec", "            :param v1: Second vector to get the bisector from.", "            :type v1: Vec", "            :result: Bisector vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                Vec.bisectors(vec_1, vec_2)", "        \"\"\"", "        if v0.is_parallel(v1): raise GeometricError(\"Cannot find the bisector of parallel vectors\")", "        va, vb = v0.normalized(),v1.normalized()", "        return Vec.average([va,vb]).normalized(), Vec.average([-va,vb]).normalized(), Vec.average([-va,-vb]).normalized(), Vec.average([va,-vb]).normalized()", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns all possible normalized bisectors that result from comparing inverted and non-inverted versions of the two vectors." ],
          "parameters" : {
            "v0" : "First vector to get the bisector from.\n",
            "v1" : "Second vector to get the bisector from.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Bisector vector.\n",
          "types" : {
            "v0" : "Vec\n",
            "v1" : "Vec\n"
          }
        },
        "end" : 512,
        "name" : "bisectors",
        "start" : 495
      }, {
        "code" : [ "        return sorted(others,key=lambda v: self.angle(v))[0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 516,
        "name" : "best_match",
        "start" : 515
      }, {
        "code" : [ "        \"\"\" Return a new vector in the same direction, but given length (default 1.0).", "        ", "            :param length: New length for the Vec (default 1.0)", "            :type length: float", "            :result: Normalized vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec.normalized()", "        \"\"\"", "        if self.length == 0 : raise GeometricError(\"Cannot normalize a vector of length zero: %s\"%(self))", "        factor = length / self.length", "        return Vec(self.x * factor, self.y * factor, self.z * factor)        ", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Return a new vector in the same direction, but given length (default 1.0)." ],
          "parameters" : {
            "length" : "New length for the Vec (default 1.0)\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Normalized vector.\n",
          "types" : {
            "length" : "float\n"
          }
        },
        "end" : 533,
        "name" : "normalized",
        "start" : 519
      }, {
        "code" : [ "        \"\"\" Return a new vector pointing in the opposite direction.", "        ", "            :result: Inverted vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec.inverted()", "        \"\"\" ", "        return Vec(-self.x,-self.y,-self.z)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Return a new vector pointing in the opposite direction." ],
          "rtype" : "Vec\n\n",
          "rvalue" : "Inverted vector.\n"
        },
        "end" : 545,
        "name" : "inverted",
        "start" : 535
      }, {
        "code" : [ "        \"\"\" Returns a new vector with coords rounded to n-digits (defaults to 0 digits (nearest int). ", "        ", "            :param n: Number of digits to round the Vec's coordinates.", "            :type n: int", "            :result: Rounded vector. ", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec.rounded()", "        \"\"\"", "        return Vec(round(self.x,n),round(self.y,n),round(self.z,n))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new vector with coords rounded to n-digits (defaults to 0 digits (nearest int)." ],
          "parameters" : {
            "n" : "Number of digits to round the Vec's coordinates.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Rounded vector. \n",
          "types" : {
            "n" : "int\n"
          }
        },
        "end" : 559,
        "name" : "rounded",
        "start" : 547
      }, {
        "code" : [ "        \"\"\" Returns a new vector limited to a given length.", "        ", "            :param n: Value to limit the Vec's length.", "            :type n: float", "            :result: Limited vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec.limited()", "                ", "        \"\"\"", "        if self.length2 < n**2 : return Vec(self.x,self.y,self.z)", "        return self.normalized(n)    ", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new vector limited to a given length." ],
          "parameters" : {
            "n" : "Value to limit the Vec's length.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Limited vector.\n",
          "types" : {
            "n" : "float\n"
          }
        },
        "end" : 575,
        "name" : "limited",
        "start" : 561
      }, {
        "code" : [ "        \"\"\" Computes the dot product of this vector and the other vector.", "        ", "            :param other: Second vector to compute dot product.", "            :type other: Vec", "            :result: Dot product.", "            :rtype: float", "            ", "            ::", "            ", "                my_vec.dot(vec_2)", "            ", "        \"\"\"", "        return float(self.x * other.x + self.y * other.y + self.z * other.z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Computes the dot product of this vector and the other vector." ],
          "parameters" : {
            "other" : "Second vector to compute dot product.\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Dot product.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 590,
        "name" : "dot",
        "start" : 577
      }, {
        "code" : [ "        \"\"\" Returns the length of the vector which results from projecting a vector onto a destination vector.", "        ", "            :param other: Destination vector.", "            :type other: Vec", "            :result: Projected vector length.", "            :rtype: float", "            ", "            ::", "            ", "                my_vec.projected_length(vec_2)", "        \"\"\"", "        return self.dot(other.normalized())", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the length of the vector which results from projecting a vector onto a destination vector." ],
          "parameters" : {
            "other" : "Destination vector.\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Projected vector length.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 604,
        "name" : "projected_length",
        "start" : 592
      }, {
        "code" : [ "        \"\"\" Returns a new vector projected onto a destination vector.", "        ", "            :param other: Destination vector.", "            :type other: Vec", "            :result: Projected vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                my_vec.projected(vec_2)", "        \"\"\"", "        return other * ( self.dot(other) / other.dot(other) )", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new vector projected onto a destination vector." ],
          "parameters" : {
            "other" : "Destination vector.\n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "Projected vector.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 618,
        "name" : "projected",
        "start" : 606
      }, {
        "code" : [ "        \"\"\"| Return a new vector, the cross product.", "           | a x b = (a2b3 - a3b2, a3b1 - a1b3, a1b2 - a2b1)", "           | This will be at right angles to both self and other, with a length.", "        ", "           :param other: Second vector to calculate cross product. ", "           :type other: Vec", "           :result: New vector.", "           :rtype: Vec", "", "           ::", "            ", "                len(self) * len(other) * sin(angle_between_them)", "                ", "                my_vec.cross(vec_1)", "            ", "        \"\"\"", "        return Vec(", "                self.y * other.z - self.z * other.y," ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Return a new vector, the cross product.", "| a x b = (a2b3 - a3b2, a3b1 - a1b3, a1b2 - a2b1)", "| This will be at right angles to both self and other, with a length." ],
          "parameters" : {
            "other" : "Second vector to calculate cross product. \n"
          },
          "rtype" : "Vec\n\n",
          "rvalue" : "New vector.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 637,
        "name" : "cross",
        "start" : 620
      }, {
        "code" : [ "        \"\"\" Returns the angle in radians between this vector and the other vector. Return value is constrained to the range [0,PI].", "        ", "            :param other: Second vector for angle calculation.", "            :type other: Vec", "            :result: Angle in radians.", "            :rtype: float", "            ", "            ::", "            ", "                my_vec.angle(vec_1)", "        \"\"\"", "        vdot = self.dot(other) / (self.length * other.length)", "        if vdot>1.0 : vdot = 1.0", "        if vdot<-1.0 : vdot = -1.0", "        return math.acos(vdot)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the angle in radians between this vector and the other vector. Return value is constrained to the range [0,PI]." ],
          "parameters" : {
            "other" : "Second vector for angle calculation.\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Angle in radians.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 658,
        "name" : "angle",
        "start" : 643
      }, {
        "code" : [ "        \"\"\" Returns the angle in degrees between this vector and the other vector.", "        ", "            :param other: Second vector to for angle calculation.", "            :type other: Vec", "            :result: Angle in degrees.", "            :rtype: float", "        \"\"\"", "        return math.degrees(self.angle(other))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the angle in degrees between this vector and the other vector." ],
          "parameters" : {
            "other" : "Second vector to for angle calculation.\n"
          },
          "rtype" : "float",
          "rvalue" : "Angle in degrees.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 668,
        "name" : "angle_deg",
        "start" : 660
      }, {
        "code" : [ "        \"\"\" Returns a ray from a given point along this vector.", "            ", "            :param pt: Point along this vector.", "            :type pt: Point", "            :result: Ray from Point", "            :rtype: Ray", "            ", "            ::", "            ", "                my_vec.to_ray(Point(1,1,1))", "                ", "        \"\"\"", "        from .dc_line import Ray", "        from .dc_point import Point", "        if pt is None: pt = Point()", "        return Ray(pt,Vec(self))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a ray from a given point along this vector." ],
          "parameters" : {
            "pt" : "Point along this vector.\n"
          },
          "rtype" : "Ray\n\n",
          "rvalue" : "Ray from Point\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 686,
        "name" : "to_ray",
        "start" : 670
      }, {
        "code" : [ "        \"\"\" Returns a line from a given point along this vector.", "            ", "            :param pt: Point along this vector.", "            :type pt: Point", "            :result: Line from Point.", "            :rtype: Line", "            ", "            ::", "            ", "                my_vec.to_line(Point(1,1,1))", "        \"\"\"", "        from .dc_line import Line", "        from .dc_point import Point", "        if pt is None: pt = Point()", "        return Line(pt,Vec(self))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a line from a given point along this vector." ],
          "parameters" : {
            "pt" : "Point along this vector.\n"
          },
          "rtype" : "Line\n\n",
          "rvalue" : "Line from Point.\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 703,
        "name" : "to_line",
        "start" : 688
      }, {
        "code" : [ "    def ux(length=1.0):", "        \"\"\" Returns unit vector (length = 1.0) in the x-direction.", "        ", "            :result: Unit Vec in the x-axis.", "            :rtype: Vec", "        \"\"\"", "        return Vec(length,0,0)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns unit vector (length = 1.0) in the x-direction." ],
          "rtype" : "Vec",
          "rvalue" : "Unit Vec in the x-axis.\n"
        },
        "end" : 712,
        "name" : "ux",
        "start" : 705
      }, {
        "code" : [ "    def uy(length=1.0):", "        \"\"\" Returns unit vector (length = 1.0) in the y-direction.", "            ", "            :result: Unit Vec in the y-axis.", "            :rtype: Vec", "        \"\"\"", "        return Vec(0,length,0)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns unit vector (length = 1.0) in the y-direction." ],
          "rtype" : "Vec",
          "rvalue" : "Unit Vec in the y-axis.\n"
        },
        "end" : 721,
        "name" : "uy",
        "start" : 714
      }, {
        "code" : [ "    def uz(length=1.0):", "        \"\"\" Returns unit vector (length = 1.0) in the z-direction.", "        ", "            :result: Unit vec in the z-axis.", "            :rtype: Vec", "        \"\"\"", "        return Vec(0,0,length)" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns unit vector (length = 1.0) in the z-direction." ],
          "rtype" : "Vec",
          "rvalue" : "Unit vec in the z-axis.\n"
        },
        "end" : 730,
        "name" : "uz",
        "start" : 723
      } ],
      "documentation" : {
        "description" : [ "a simple vector class" ]
      },
      "end" : 730,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_vec.py",
      "name" : "Vec",
      "references" : {
        "classes" : {
          "EPSILON" : 1,
          "Geometry" : 1,
          "Interval" : 1,
          "Line" : 1,
          "Point" : 2,
          "Ray" : 1,
          "Vec" : 25,
          "Xform" : 1
        },
        "functions" : {
          "__add__" : 1,
          "__div__" : 1,
          "__eq__" : 1,
          "__ge__" : 1,
          "__gt__" : 1,
          "__init__" : 1,
          "__invert__" : 1,
          "__le__" : 1,
          "__lt__" : 1,
          "__mul__" : 1,
          "__ne__" : 1,
          "__neg__" : 1,
          "__repr__" : 1,
          "__sub__" : 1,
          "__truediv__" : 1,
          "angle" : 1,
          "angle_deg" : 1,
          "apxeq" : 1,
          "average" : 1,
          "best_match" : 1,
          "bisector" : 1,
          "bisectors" : 1,
          "cross" : 1,
          "dot" : 1,
          "interpolate" : 1,
          "inverted" : 1,
          "is_2d" : 1,
          "is_coincident" : 1,
          "is_equal" : 1,
          "is_identical" : 1,
          "is_parallel" : 1,
          "is_perpendicular" : 1,
          "is_similar" : 1,
          "length" : 2,
          "length2" : 1,
          "limited" : 1,
          "normalized" : 1,
          "projected" : 1,
          "projected_length" : 1,
          "random" : 1,
          "rounded" : 1,
          "to_line" : 1,
          "to_ray" : 1,
          "to_tuple" : 1,
          "tup" : 1,
          "ux" : 1,
          "uy" : 1,
          "uz" : 1,
          "x" : 2,
          "y" : 2,
          "z" : 2
        }
      },
      "start" : 9
    },
    "4daf6398-8a31-4d02-8592-b3b6ee8fe987" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#calculate mutual tangency for each pair of circles", "cir_ab, pt_ab, pt_ba = Circle.mutually_tangent(cir_a,cir_b,tan_off,True)", "cir_bc, pt_bc, pt_cb = Circle.mutually_tangent(cir_b,cir_c,tan_off,True)", "", "#calculate intersection points", "pt_a = cir_a.plane.origin + Vec(-1,1).normalized(cir_a.rad)", "pt_c = cir_c.plane.origin + Vec(1,1).normalized(cir_c.rad)", "", "# create a chain of Arcs", "arc_a = Arc.from_pts(cir_a.plane.origin,pt_a,pt_ab)", "arc_ab = Arc.from_pts(cir_ab.plane.origin,pt_ab,pt_ba)", "arc_b = Arc.from_pts(cir_b.plane.origin,pt_ba,pt_bc)", "arc_bc = Arc.from_pts(cir_bc.plane.origin,pt_bc,pt_cb)", "arc_c = Arc.from_pts(cir_c.plane.origin,pt_cb,pt_c)", "# store this chain of Arcs as a list", "arcs = [arc_a,arc_ab,arc_b,arc_bc,arc_c]", "", "# for every Arc in the list:", "for arc in arcs:", "    vec1 = Vec(1,0)", "    interv = Interval(math.pi/2-rot_w,math.pi/2+rot_w)", "    # create a RotationalSurface ", "    surf = RotationalSurface(arc, vec1, interv)", "", "    ", "" ],
          "end" : 45,
          "start" : 19
        },
        "description" : "\nSurface of Mutually Tangent Arcs\nFor every pair of given Circles, create an arc which is tangent to both of them. Chain the results together into a guide rail for a surface\n",
        "end" : 19,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "4.03.F01d", "For every pair of given Circles, create an arc which is tangent to both of them. Chain the results together into a guide rail for a surface" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Foster Pre-Rational Studies/4.03.F01d.py",
      "name" : "4.03.F01d.py",
      "references" : {
        "classes" : {
          "Arc" : 5,
          "Circle" : 2,
          "Interval" : 1,
          "RotationalSurface" : 1,
          "Vec" : 3
        }
      },
      "required" : [ "cir_a (Circle) First circle.", "cir_b (Circle) Second circle.", "cir_c (Circle) Third Circle.", "tan_off (float) Tangent offset value for the circles." ],
      "result" : [ "ret ([Arc]) List of Arcs." ]
    },
    "4db788fc-dcf7-40e3-bf3c-78c83066a515" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class Coord():", "    def __init__(self,u,v,on_edge=False):", "        self.u = u", "        self.v = v", "        self.on_edge = on_edge", "        self.pt = False", "        ", "    # evaluate a Surface, and get a Point    ", "    def to_pt(self,srf):", "        # if self.pt is not set:", "        if not self.pt:", "            # evaluate the Surface", "            self.pt = srf.eval(self.u,self.v).origin", "        return self.pt", "    \"\"\"", "    [noprint]", "    \"\"\"", "    # print the u, v coordinates", "    def __repr__(self): ", "        if self.on_edge: return \"coord[[{0},{1}]]\".format(self.u,self.v)", "        return \"coord[{0},{1}]\".format(self.u,self.v)", "" ],
          "end" : 38,
          "start" : 15
        },
        "description" : "\nMesh Coordinate Class\nCreates a coordinate object that stores its location on the Mesh.\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "", "def move_pt(crd,surface):", "    # verify that this is a valid point to move", "    if not crd or crd.on_edge : return False", "    u = crd.u", "    v = crd.v", "    # if so, get the curvature at that point", "    gauss = surface.eval_gauss(u,v)", "    ", "    # make sure that the step happens within reason", "    if gauss > ival_crv.b : ", "        print \"careful, you may want to reset ival_crv.b: \", gauss", "        gauss = ival_crv.b", "    ", "    # move the point according to the curvature", "    step = Interval.remap(gauss,ival_crv,ival_stp)", "    if go_positive: v += step", "    else : v -= step", "    if v > 1.0 : v = 1.0", "    if v < 0.0 : v = 0.0", "    return Coord( u , v , v==1.0 or v==0.0 )", "" ],
          "end" : 64,
          "start" : 42
        },
        "description" : "\nMove Point\nMethod that moves a point based on an evaluation of the gaussian curvature at the point\n",
        "end" : 42,
        "start" : 39
      }, {
        "code" : {
          "content" : [ "strip_divs = 20", "max_strips = 20", "ival_crv = Interval(0.0,5.0)# defines high and low curvature values", "ival_stp = Interval(0.1,0.005)# defines max and min strip widths in domain units", "go_positive = False # switch to evaluate the second half of the surface", "# create a 'seed' strip", "spine_crds = []", "v = 0.0", "# for every desired division in a strip:", "for u in Interval().divide(strip_divs,True):", "    # create a new Coord object", "    spine_crds.append(Coord(u,v))", "", "# initialize a list of strips, starting with the seed ", "strips = [spine_crds]", "# for every strip ", "for n in range(max_strips):", "    # initialize a container to hold the next set of Coords", "    nxt_crds = []", "    # for every coordinate in the previous strip:", "    for crd in strips[-1]:", "        # move the coordinate, and store it", "        nxt_crds.append(move_pt(crd,srf))", "    # if this strip has any coordinates, store it and move on", "    if any(nxt_crds): strips.append(nxt_crds)", "    else: break", "" ],
          "end" : 96,
          "start" : 69
        },
        "description" : "\nPlot Decomposed Coordinate Locations\nGiven a Surface, plot decomposed coordinate locations based on curvature. \n[pseudo]\n",
        "end" : 69,
        "start" : 65
      }, {
        "code" : {
          "content" : [ "mesh_strips = []", "# create a Mesh for each strip ", "for s in range(len(strips)-1):", "    # get the coordinates for this strip and the next", "    crds_a = strips[s]", "    crds_b = strips[s+1]", "    msh = Mesh()", "    # for every Point in each strip", "    for n in range(len(crds_a)-1):", "        # convert Coords to Points", "        pa0, pa1, pb0, pb1 = [False]*4", "        if crds_a[n]: pa0 = crds_a[n].to_pt(srf)", "        if crds_a[n+1]: pa1 = crds_a[n+1].to_pt(srf)", "        if crds_b[n]: pb0 = crds_b[n].to_pt(srf)", "        if crds_b[n+1]: pb1 = crds_b[n+1].to_pt(srf)", "        # if all four points were converted:", "        if all([pa0,pa1,pb0,pb1]): ", "            i = len(msh)", "            # mesh two triangle faces", "            msh.append([pa0,pa1,pb0,pb1])", "            msh.add_face(i,i+1,i+3)", "            msh.add_face(i+2,i,i+3)", "        # if all four points were not converted:", "        else:", "            #check if each point is missing. if so, mesh remaining triangle", "            if all([pa0,pa1,pb1]):", "                i = len(msh)", "                msh.append([pa0,pa1,pb1])", "                msh.add_face(i,i+1,i+2)", "            if all([pb0,pb1,pa0]):", "                i = len(msh)", "                msh.append([pb0,pb1,pa0])", "                msh.add_face(i,i+2,i+1)", "            if all([pa0,pa1,pb0]):", "                i = len(msh)", "                msh.append([pa0,pa1,pb0])", "                msh.add_face(i,i+1,i+2)", "            if all([pb0,pb1,pa1]):", "                i = len(msh)", "                msh.append([pb0,pb1,pa1])", "                msh.add_face(i,i+2,i+1)", "                ", "    # append this mesh strip to a list of strips", "    mesh_strips.append(msh)" ],
          "end" : 144,
          "start" : 101
        },
        "description" : "\nDraw Decomposed Mesh\nGiven a set of coordinate locations on a surface, weave a mesh\n[pseudo]\n",
        "end" : 101,
        "start" : 97
      } ],
      "documentation" : {
        "description" : [ "4.03.L03c", "Given a mesh, return a list of mesh strips representing the original mesh, and varying in width as a factor of their curvature." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Surface Decomposition based on Curvature/4.03.L03c.py",
      "name" : "4.03.L03c.py",
      "references" : {
        "classes" : {
          "Coord" : 3,
          "Interval" : 4,
          "Mesh" : 1
        }
      },
      "required" : [ "srf (Surface) A Surface to decompose." ],
      "result" : [ "mesh_strips ([Mesh]) A list of Meshes." ]
    },
    "4efdd3c9-ce90-4b5b-acb4-21cc6e6d6ee0" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "ival = Interval(0,pi*2)", "pt_count = 100", "pts = []", "for t in ival/pt_count:", "    x = (aa-bb)*cos(t) + bb*cos(t*((aa+bb)-1))", "    y = (aa-bb)*sin(t) + bb*sin(t*((aa+bb)-1))", "    pts.append(Point(x,y))", "\t" ],
          "end" : 26,
          "start" : 18
        },
        "description" : "\n",
        "end" : 18,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "def evaluate(t):", "    x = (aa-bb)*cos(t) + bb*cos(t*((aa+bb)-1))", "    y = (aa-bb)*sin(t) + bb*sin(t*((aa+bb)-1))", "    return Point(x,y)", "\t" ],
          "end" : 33,
          "start" : 28
        },
        "description" : "\n",
        "end" : 28,
        "start" : 27
      }, {
        "code" : {
          "content" : [ "pts = []", "ival = Interval(0,math.pi*2)", "for t in ival.divide(pt_count, include_last = True): ", "    pts.append(evaluate(t))", "" ],
          "end" : 39,
          "start" : 35
        },
        "description" : "\n",
        "end" : 35,
        "start" : 34
      } ],
      "documentation" : {
        "description" : [ "3.07.E01a", "Creates a \"curve\" defined by a mathematical function with inputs aa, bb and visualized by a polyline and pts along the curve" ],
        "images" : {
          "3&03&P01&png" : "caption number two\n",
          "3&03&P02&png" : "caption number two\n\nrequired"
        }
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Curve Basics/3.07.E01a.py",
      "name" : "3.07.E01a.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Point" : 2
        }
      },
      "required" : [ "aa and bb (float)", "pt_count (int)" ],
      "result" : [ "a polyline (Pline)", "points evaluated at evenly spaced values of t in the defining interval" ]
    },
    "5143ba72-3bd1-4019-bf4d-acd38197782c" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_line.py",
      "definitions" : [ {
        "code" : [ "    @property" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 287,
        "name" : "__repr__",
        "start" : 287
      }, {
        "code" : [ "    def pt(self): ", "        \"\"\" Returns the reference Point of a Line.", "", "            :result: the reference Point.", "            :rtype: Point", "        \"\"\"", "        return self._pt", "    @pt.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the reference Point of a Line." ],
          "rtype" : "Point",
          "rvalue" : "the reference Point.\n"
        },
        "end" : 295,
        "name" : "pt",
        "start" : 288
      }, {
        "code" : [ "    def pt(self, point): ", "        \"\"\" Sets the reference Point of a Line.", "", "            :param point: the the reference Point.", "            :type point: Point", "            :result: Sets a reference point.", "            :rtype: None", "        \"\"\"", "        self._pt = point", "        " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the reference Point of a Line." ],
          "parameters" : {
            "point" : "the the reference Point.\n"
          },
          "rtype" : "None",
          "rvalue" : "Sets a reference point.\n",
          "types" : {
            "point" : "Point\n"
          }
        },
        "end" : 305,
        "name" : "pt",
        "start" : 296
      }, {
        "code" : [ "        \"\"\" Returns True if the given Line shares the Point and coincident directions with this Line", "        ", "            :param other: Line to be compared.", "            :type other: Line", "            :param pos_tol: Tolerance of point distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_line.is_equal(other_line)", "        \"\"\"", "        return self.pt.is_equal(other.pt,pt_tol) and self.vec.is_coincident(other.vec,vec_tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Line shares the Point and coincident directions with this Line" ],
          "parameters" : {
            "other" : "Line to be compared.\n",
            "pos_tol" : "Tolerance of point distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Line\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float\n"
          }
        },
        "end" : 323,
        "name" : "is_equal",
        "start" : 307
      }, {
        "code" : [ "        \"\"\" Returns True if the Lines share any Point along their length and have parallel direction Vecs. Equivalent to LinearEntity.is_colinear()", "        ", "            :param other: Line to be compared.", "            :type other: Line", "            :param pos_tol: Tolerance of point distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.          ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_line.is_coincident(other_line)", "        \"\"\"", "        return self.is_collinear(other,pt_tol, vec_tol) and self.vec.is_coincident(other.vec,vec_tol)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the Lines share any Point along their length and have parallel direction Vecs. Equivalent to LinearEntity.is_colinear()" ],
          "parameters" : {
            "other" : "Line to be compared.\n",
            "pos_tol" : "Tolerance of point distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.          \n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Line\n",
            "pos_tol" : "float               \n"
          }
        },
        "end" : 340,
        "name" : "is_coincident",
        "start" : 325
      } ],
      "documentation" : {
        "description" : [ "A line in space." ]
      },
      "end" : 340,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_line.py",
      "name" : "Line",
      "references" : {
        "classes" : {
          "Line" : 1,
          "LinearEntity" : 1
        },
        "functions" : {
          "__repr__" : 1,
          "is_coincident" : 1,
          "is_equal" : 1,
          "pt" : 2
        }
      },
      "start" : 285
    },
    "5153aebb-c7d7-46fd-a66e-73daf79a6b82" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_pgon.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" PGon Constructor.", "        ", "            :param vertices: List of vertices to build the polygon.", "            :type vertices: list", "            :param basis: Plane basis for the PGon.", "            :type basis: Basis", "            :returns: PGon object. ", "            :rtype: PGon", "            ", "            ::", "            ", "                pts=[", "                    Point(0,0,0),", "                    Point(0,1,0),", "                    Point(1,1,0),", "                    Point(1,0,0)", "                    ]", "                    ", "                my_pgon=PGon(pts)", "        \"\"\" ", "        if basis is None and vertices is None : raise GeometricError(\"You must define either a basis or a list of vertices (or both) to construct a PGon\")", "        ", "        if basis is None:", "            #if i pass in vertices but no basis, try and figure out what the CS should be and project all points to the proper plane" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "PGon Constructor." ],
          "parameters" : {
            "basis" : "Plane basis for the PGon.\n",
            "vertices" : "List of vertices to build the polygon.\n"
          },
          "rtype" : "PGon\n\n",
          "types" : {
            "basis" : "Basis\n",
            "vertices" : "list\n"
          }
        },
        "end" : 38,
        "name" : "__init__",
        "start" : 15
      }, {
        "code" : [ "        \"\"\"| Appends the given Point to the PGon.", "           | Each Point is processed to ensure planarity.", "", "           :param pts: Point(s) to append.", "           :type pts: Point or [Point]", "           :result: Modifies this geometry by adding items to the stored list of points.", "           :rtype: None", "        \"\"\"", "        super(PGon,self).append(pts)", "        try:", "            for n in range(len(pts)): self._verts[-(n+1)].z = 0", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Appends the given Point to the PGon.", "| Each Point is processed to ensure planarity." ],
          "parameters" : {
            "pts" : "Point(s) to append.\n"
          },
          "rtype" : "None",
          "rvalue" : "Modifies this geometry by adding items to the stored list of points.\n",
          "types" : {
            "pts" : "Point or [Point]\n"
          }
        },
        "end" : 73,
        "name" : "append",
        "start" : 62
      }, {
        "code" : [ "        \"\"\"| Returns a segment of this Polygon as a Segment", "           | The returned line segment will contain a copy of the Points stored in the segment.", "        ", "           :param index: Index of the desired segment.", "           :type index: Int", "           :returns: Segment object. ", "           :rtype: Segment", "           ", "           ", "        \"\"\"", "        idx_a, idx_b = idx%(len(self)), (idx+1)%(len(self))", "        return Segment(self.pts[idx_a],self.pts[idx_b])", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a segment of this Polygon as a Segment", "| The returned line segment will contain a copy of the Points stored in the segment." ],
          "parameters" : {
            "index" : "Index of the desired segment.\n"
          },
          "rtype" : "Segment",
          "types" : {
            "index" : "Int\n"
          }
        },
        "end" : 89,
        "name" : "seg",
        "start" : 77
      }, {
        "code" : [ "        \"\"\"| Returns a corner of this Polygon as a pair of Rays", "        ", "           :param index: Index of the desired corner.", "           :type index: Int", "           :returns: A Pair of Rays. ", "           :rtype: (Ray)", "        \"\"\"", "        if index >= len(self) : raise IndexError()", "        i0, i1 = index - 1, index + 1", "        if i0<0 : i0 = len(self)-1", "        if i1> len(self)-1 : i1 = 0", "        ", "        return Ray(self.pts[index],Vec(self.pts[index],self.pts[i0])) , Ray(self.pts[index],Vec(self.pts[index],self.pts[i1]))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a corner of this Polygon as a pair of Rays" ],
          "parameters" : {
            "index" : "Index of the desired corner.\n"
          },
          "rtype" : "(Ray)",
          "types" : {
            "index" : "Int\n"
          }
        },
        "end" : 105,
        "name" : "cnr",
        "start" : 92
      }, {
        "code" : [ "        \"\"\" Overloads the containment **(in)** operator.", "        ", "            :param pts: Point to determine containment in this PGon.", "            :type pts: Point", "            :result: Boolean Value.", "            :rtype: bool", "            ", "        \"\"\"", "        return self.contains_pt(pt)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the containment **(in)** operator." ],
          "parameters" : {
            "pts" : "Point to determine containment in this PGon.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "pts" : "Point\n"
          }
        },
        "end" : 117,
        "name" : "__contains__",
        "start" : 108
      }, {
        "code" : [ "    def edges(self):", "        \"\"\" Returns the edges of a PGon.", "       ", "            :result: List of edges of a PGon", "            :rtype: [Segment]", "            ", "            ::", "            ", "                my_pgon.edges", "            ", "        \"\"\"", "        return [self.seg(n) for n in range(len(self))]", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the edges of a PGon." ],
          "rtype" : "[Segment]\n\n",
          "rvalue" : "List of edges of a PGon\n"
        },
        "end" : 131,
        "name" : "edges",
        "start" : 119
      }, {
        "code" : [ "    def area(self):", "        \"\"\" Returns the area of this PGon.", "        ", "            :result: Area of PGon.", "            :rtype: float", "            ", "            ::", "            ", "                my_pgon.area", "            ", "        \"\"\"", "        a = 0", "        for n in range(len(self._verts)): a += (self._verts[n-1].x + self._verts[n].x) * (self._verts[n-1].y - self._verts[n].y)", "        return abs(a / 2.0)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the area of this PGon." ],
          "rtype" : "float\n\n",
          "rvalue" : "Area of PGon.\n"
        },
        "end" : 147,
        "name" : "area",
        "start" : 133
      }, {
        "code" : [ "    def is_clockwise(self):", "        \"\"\" Determines if the verts of this PGon are more-or-less ordered clockwise or counter-clockwise relative to its basis.", "        ", "            :result: The clockwiseness of this PGon.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pgon.area", "            ", "        \"\"\"", "        a = 0", "        for n in range(len(self._verts)): a += (self._verts[n-1].x - self._verts[n].x) * (self._verts[n-1].y + self._verts[n].y)", "        return a > 0.0", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Determines if the verts of this PGon are more-or-less ordered clockwise or counter-clockwise relative to its basis." ],
          "rtype" : "bool\n\n",
          "rvalue" : "The clockwiseness of this PGon.\n"
        },
        "end" : 163,
        "name" : "is_clockwise",
        "start" : 149
      }, {
        "code" : [ "    def bounds(self):", "        \"\"\" Returns the bounding box of this polygon, aligned to the basis of this polygon.", "        ", "            :result: Bounding box of polygon.", "            :rtype: Bounds", "            ", "            ::", "            ", "                my_pgon.bounds", "            ", "        \"\"\"", "", "        xx = [vec.x for vec in self._verts]", "        yy = [vec.y for vec in self._verts]", "        ivx = Interval(min(xx),max(xx))", "        ivy = Interval(min(yy),max(yy))", "", "        return Bounds(ival_x = ivx, ival_y = ivy)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the bounding box of this polygon, aligned to the basis of this polygon." ],
          "rtype" : "Bounds\n\n",
          "rvalue" : "Bounding box of polygon.\n"
        },
        "end" : 184,
        "name" : "bounds",
        "start" : 166
      }, {
        "code" : [ "        \"\"\" Returns the bisector of one angle in a Polygon", "        ", "            :result: The Vector that bisects that angle, and the angle of the bisector", "            :rtype: (Vec, float)", "", "            ", "        \"\"\"", "        v0 = self.edges[index-1].vec", "        v1 = self.edges[index].vec", "        bisec =  Vec.bisector(v0,v1).cross(self._basis.z_axis)", "        return (bisec, bisec.angle(v1))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the bisector of one angle in a Polygon" ],
          "rtype" : "(Vec, float)",
          "rvalue" : "The Vector that bisects that angle, and the angle of the bisector\n"
        },
        "end" : 198,
        "name" : "angle_bisector",
        "start" : 187
      }, {
        "code" : [ "        \"\"\" Creates a copy of a polygon rotated to its best-fit bounding box.", "        ", "            :param divs: Number of divisions of rotation per level.", "            :type divs: int", "            :param levels: Number of iterations.", "            :type levels: int", "            :param min_a: Minimum angle of rotation.", "            :type min_a: float", "            :param max_a: Maximum angle of rotation", "            :type max_a: float", "            :result: Polygon rotated to minimum bounds.", "            :rtype: PGon", "            ", "            ", "        \"\"\"", "        from .dc_xform import Xform", "    ", "        delta_a = (max_a - min_a) / divs", "", "        t_list = []", "", "        # make a copy and rotate into initial position", "        t = copy.deepcopy(self)", "        xf = Xform.rotation(angle = (min_a - delta_a))", "        t._verts = [v * xf for v in t._verts]", "", "", "        # make transform for incremental rotations", "        xf = Xform.rotation(angle = delta_a)", "", "        for i in range(divs+1):", "            t._verts = [v * xf for v in t._verts]", "            b_area = t.bounds.dim_x * t.bounds.dim_y", "            t_list.append([min_a + i*delta_a,b_area])", "", "        min_vals = min(t_list, key=lambda s: (s[1]))", "#        print \"Iteration :\", levels", "#        print t_list", "#        print \"Minimum values : \",min_vals", "", "        if levels == 0 :", "            t = copy.deepcopy(self)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Creates a copy of a polygon rotated to its best-fit bounding box." ],
          "parameters" : {
            "divs" : "Number of divisions of rotation per level.\n",
            "levels" : "Number of iterations.\n",
            "max_a" : "Maximum angle of rotation\n",
            "min_a" : "Minimum angle of rotation.\n"
          },
          "rtype" : "PGon",
          "rvalue" : "Polygon rotated to minimum bounds.\n",
          "types" : {
            "divs" : "int\n",
            "levels" : "int\n",
            "max_a" : "float\n",
            "min_a" : "float\n"
          }
        },
        "end" : 243,
        "name" : "rotated_to_min_bounds",
        "start" : 202
      }, {
        "code" : [ "        \"\"\"| Evaluates this polygon at the specified parameter t.", "           | A t-value of 0 will result in a point coincident with PGon.pts[0].", "           | A t-value of 1 will result in a point coincident with PGon.pts[-1].", "           ", "           ", "           :param t: A decimal number between [0:1].", "           :type t: float", "           :result: Point on PGon.", "           :rtype: Point", "           ", "           ::", "           ", "                my_pgon.eval(0.5)", "                ", "        \"\"\"", "        if t > 1 : t = t%1.0", "        if t < 0 : t = 1.0 - abs(t)%1.0", "        if t == 0.0 or t == 1.0 : return self.pts[0]", "        for n, ival in enumerate(Interval()//len(self)):", "            if t in ival:", "                pa = self.pts[n]" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this polygon at the specified parameter t.", "| A t-value of 0 will result in a point coincident with PGon.pts[0].", "| A t-value of 1 will result in a point coincident with PGon.pts[-1]." ],
          "parameters" : {
            "t" : "A decimal number between [0"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Point on PGon.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 276,
        "name" : "eval",
        "start" : 256
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given PGon, the index of the closest segment and the distance from the Point to the near Point.", "       ", "            :param p: Point to look for a near Point on the PGon.", "            :type p: Point", "            :result: Nearest point on the PGon, index of the segment of this PGon on which this Point lies, the t-value along this segment, and the distance from the given Point.", "            :rtype: (Point, integer, float, float)", "            ", "            ::", "            ", "                my_pgon.near(Point(0,0,0))", "        \"\"\"", "        npts = [seg.near(p) for seg in self.edges]", "        npts = [(tup[0],tup[1],tup[2],n) for n,tup in enumerate(npts)] # add index", "        npts.sort(key=lambda tup: tup[2])", "        return (npts[0][0],npts[0][3],npts[0][1],npts[0][2])", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given PGon, the index of the closest segment and the distance from the Point to the near Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the PGon.\n"
          },
          "rtype" : "(Point, integer, float, float)\n\n",
          "rvalue" : "Nearest point on the PGon, index of the segment of this PGon on which this Point lies, the t-value along this segment, and the distance from the given Point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 300,
        "name" : "near",
        "start" : 285
      }, {
        "code" : [ "        \"\"\" Returns the closest point to a given PGon.", "       ", "            :param p: Point to look for a near Point on the PGon.", "            :type p: Point", "            :result: Near point on PGon.", "            :rtype: Point", "            ", "            ::", "            ", "                my_pgon.near_pt(Point(0,0,0))", "        \"\"\"", "        return self.near(p)[0]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point to a given PGon." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the PGon.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Near point on PGon.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 314,
        "name" : "near_pt",
        "start" : 302
      }, {
        "code" : [ "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 316,
        "name" : "__repr__",
        "start" : 316
      }, {
        "code" : [ "        \"\"\" Returns a new PGon with basis applied.", "        ", "            :result: PGon with basis applied.", "            :rtype: PGon", "            ", "        \"\"\"", "        ", "        clone = super(PGon,self).basis_applied()", "        clone.basis = CS()", "        return clone", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new PGon with basis applied." ],
          "rtype" : "PGon",
          "rvalue" : "PGon with basis applied.\n"
        },
        "end" : 328,
        "name" : "basis_applied",
        "start" : 318
      }, {
        "code" : [ "        \"\"\" Returns a new PGon with basis stripped.", "        ", "            :result: PGon with basis stripped.", "            :rtype: PGon", "            ", "        \"\"\"", "        ", "        clone = super(PGon,self).basis_stripped()", "        clone.basis = CS()", "        return clone", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new PGon with basis stripped." ],
          "rtype" : "PGon",
          "rvalue" : "PGon with basis stripped.\n"
        },
        "end" : 340,
        "name" : "basis_stripped",
        "start" : 330
      }, {
        "code" : [ "        \"\"\"| Returns a polygon inscribed inside this one.", "           | Each vertex of the returned polygon will lie on the midpoint of one of this polygon's edges.", "           | Optionally, you may set the t 0->1", "           ", "           :param t: A decimal number between [0:1].", "           :type t: float", "           :result: A polygon inscribed of this one.", "           :rtype: PGon", "           ", "           ::", "           ", "                my_pgon.inflate()", "        \"\"\"", "        ", "        ipts = [Vec.interpolate(self._verts[n],self._verts[n-1],t) for n in range(len(self._verts))]", "        return PGon(ipts,self._basis)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a polygon inscribed inside this one.", "| Each vertex of the returned polygon will lie on the midpoint of one of this polygon's edges.", "| Optionally, you may set the t 0->1" ],
          "parameters" : {
            "t" : "A decimal number between [0"
          },
          "rtype" : "PGon\n\n",
          "rvalue" : "A polygon inscribed of this one.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 359,
        "name" : "inflate",
        "start" : 343
      }, {
        "code" : [ "        \"\"\"| Returns a polygon offset from this one.", "           ", "           :param dist: A distance to offset the polygon.", "           :type dist: float", "           :result: A polygon offset from this one.", "           :rtype: PGon", "           ", "           ::", "           ", "                my_pgon.offset()", "        \"\"\"", "        from .dc_intersection import Intersector", "        ", "        segs = []", "        for i in range(len(self.pts)):", "        ", "            bisec, theta  = self.angle_bisector(i)", "            if theta < math.pi/2: off_len = dist/math.sin(theta)", "            else: off_len = dist/math.cos(theta-math.pi/2)", "", "            if not flip: segs.append(Segment(self.pts[i], self.pts[i] + bisec.normalized(off_len)))", "            else: segs.append(Segment(self.pts[i], self.pts[i] - bisec.normalized(off_len)))", "        ", "        xsec = Intersector()", "        for n in range(len(segs)):", "            if xsec.intersect(segs[n-1],segs[n]):", "                raise GeometricError(\"The offset value is to high\")", "                ", "        return PGon([self._basis.deval(seg.ept) for seg in segs],self._basis)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a polygon offset from this one." ],
          "parameters" : {
            "dist" : "A distance to offset the polygon.\n"
          },
          "rtype" : "PGon\n\n",
          "rvalue" : "A polygon offset from this one.\n",
          "types" : {
            "dist" : "float\n"
          }
        },
        "end" : 391,
        "name" : "offset",
        "start" : 362
      }, {
        "code" : [ "        \"\"\" Tests if this polygon contains the given point. The given point must lie on the plane of this polygon.", "        ", "            :param pt: Point to test containment in PGon.", "            :type pt: Point", "            :param tolerance: A decimal number.", "            :type tolerance: float", "            :result: Boolean Value.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pgon.constains_pt(Point(0,0,0))", "            ", "        \"\"\"", "        ", "        pt = Point(self._basis.deval(pt))", "        if abs(pt.z) > tolerance : ", "            warnings.warn(\"Given point does not lie on the same plane as this polygon.\")", "            return False", "        pt.z = 0", "        if not pt in self.bounds : return False", "", "        #TODO: maybe move this intersection routine to intersection class", "        ", "        for seg in self.edges:", "            ln = Segment(seg.spt,pt)", "            if ln.vec.length2 < tolerance: return True", "            if ln.vec.is_coincident(seg.vec) and ln.vec.length2 <= seg.vec.length2 : return True", "        ", "        icnt = 0", "        ray = Ray(pt,Vec(0,1))", "        for n in range(len(self._verts)):", "            try:", "                seg = Segment(Point(self._verts[n]),Point(self._verts[n+1]))", "            except:", "                seg = Segment(Point(self._verts[n]),Point(self._verts[0]))", "", "            if seg.is_parallel(ray) : continue", "            try:", "                slope = (seg.ept.y - seg.spt.y) / (seg.ept.x - seg.spt.x)", "                cond1 = (seg.spt.x <= pt.x) and (pt.x <= seg.ept.x)", "                cond2 = (seg.ept.x <= pt.x) and (pt.x <= seg.spt.x)", "                above = (pt.y < slope * (pt.x - seg.spt.x) + seg.spt.y)", "                if ((cond1 or cond2) and above ) : icnt += 1", "            except:", "                pass", "", "        return icnt%2!=0", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Tests if this polygon contains the given point. The given point must lie on the plane of this polygon." ],
          "parameters" : {
            "pt" : "Point to test containment in PGon.\n",
            "tolerance" : "A decimal number.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "pt" : "Point\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 443,
        "name" : "contains_pt",
        "start" : 395
      }, {
        "code" : [ "        \"\"\" Tests for overlap with another polygon. Returns true if these two polygons share a common plane, and if they overlap or if one is completely contained within another.", "        ", "            :param other: Another polygon,", "            :type other: PGon", "            :result: Boolean Value.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pgon2=PGon([Point(1,1,0), Point(1,2,0), Point(2,2,0), Point(2,1,0)])", "                ", "                my_pgon.overlaps(my_pgon2)", "            ", "        \"\"\"", "        if not self._basis.xy_plane.is_coplanar(other.basis.xy_plane): return False", "", "        for pt in other.pts: ", "            if self.contains_pt(pt) : return True", "", "        for pt in self.pts: ", "            if other.contains_pt(pt) : return True", "", "        return False", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Tests for overlap with another polygon. Returns true if these two polygons share a common plane, and if they overlap or if one is completely contained within another." ],
          "parameters" : {
            "other" : "Another polygon,\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "other" : "PGon\n"
          }
        },
        "end" : 468,
        "name" : "overlaps",
        "start" : 445
      }, {
        "code" : [ "    def triangle(pt_a,pt_b,pt_c):", "        \"\"\" Constructs a triangular polygon from three points. Resulting PGon will have a basis at the centroid of the three points, with the x_axis pointing toward pt_a.", "        ", "            :param pt_a: First Point.", "            :type pt_a: Point", "            :param pt_b: Second Point.", "            :type pt_b: Point", "            :param pt_c: Third Point.", "            :type pt_c: Point", "            :result: Triangular polygon.", "            :rtype: PGon", "            ", "            ::", "            ", "                PGon.triangle(Point(0,0,0), Point(1,2,3), Point(4,5,6))", "        ", "        \"\"\"", "        cen = Point.centroid([pt_a,pt_b,pt_c])", "        cs = CS(cen,Vec(cen,pt_a),Vec(cen,pt_b))", "        pts = [cs.deval(pt) for pt in [pt_a,pt_b,pt_c]]", "        return PGon(pts,cs)", "        #pln = Plane.from_pts(pt_a,pt_b,pt_c)" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a triangular polygon from three points. Resulting PGon will have a basis at the centroid of the three points, with the x_axis pointing toward pt_a." ],
          "parameters" : {
            "pt_a" : "First Point.\n",
            "pt_b" : "Second Point.\n",
            "pt_c" : "Third Point.\n"
          },
          "rtype" : "PGon\n\n",
          "rvalue" : "Triangular polygon.\n",
          "types" : {
            "pt_a" : "Point\n",
            "pt_b" : "Point\n",
            "pt_c" : "Point\n"
          }
        },
        "end" : 491,
        "name" : "triangle",
        "start" : 470
      }, {
        "code" : [ "    def rectangle(cpt, w, h):", "        \"\"\" Constructs a rectangle based on a center point, a width, and a height.", "        ", "            :param cpt: Center point of a rectangle.", "            :type cpt: Point", "            :param w: Width of a rectangle.", "            :type w: float", "            :param h: Height of a rectangle.", "            :type h: float", "            :returns: Rectangle (PGon object). ", "            :rtype: PGon", "            ", "            ::", "            ", "                PGon.rectangle(Point(0,0,0), 5, 10)", "        \"\"\" ", "        w2 = w/2.0", "        h2 = h/2.0", "        basis = CS(cpt)", "        return PGon([Point(-w2,-h2),Point(w2,-h2),Point(w2,h2),Point(-w2,h2)],basis)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a rectangle based on a center point, a width, and a height." ],
          "parameters" : {
            "cpt" : "Center point of a rectangle.\n",
            "h" : "Height of a rectangle.\n",
            "w" : "Width of a rectangle.\n"
          },
          "rtype" : "PGon\n\n",
          "types" : {
            "cpt" : "Point\n",
            "h" : "float\n",
            "w" : "float\n"
          }
        },
        "end" : 515,
        "name" : "rectangle",
        "start" : 495
      }, {
        "code" : [ "    def doughnut(cs,radius_interval,angle_interval=Interval(0,math.pi*2),res=20):", "        \"\"\" Constructs a doughnut based on a center point, two radii, and optionally a start angle, sweep angle, and resolution.", "        ", "            :param cpt: Center point of a rectangle.", "            :type cpt: Point", "            :param radius_interval: Radii interval.", "            :type radius_interval: Interval", "            :param angle_interval: Angle interval.", "            :type angle_interval: Interval", "            :param res: Doughnut resolution.", "            :type res: float", "            :returns: Doughnut object. ", "            :rtype: PGon", "            ", "        \"\"\" ", "        try:", "            cs.eval(0,0)", "        except:", "            cs = CS(cs)", "        pts = []", "        rad_a = radius_interval.a", "        rad_b = radius_interval.b", "        if rad_a == 0 : rad_a = EPSILON", "        if rad_b == 0 : rad_b = EPSILON", "        if rad_a == rad_b : rad_b += EPSILON", "        for t in angle_interval.divide(res,True):pts.append(cs.eval_cyl(rad_a,t))", "        for t in angle_interval.invert().divide(res,True):pts.append(cs.eval_cyl(rad_b,t))", "        return PGon(pts)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a doughnut based on a center point, two radii, and optionally a start angle, sweep angle, and resolution." ],
          "parameters" : {
            "angle_interval" : "Angle interval.\n",
            "cpt" : "Center point of a rectangle.\n",
            "radius_interval" : "Radii interval.\n",
            "res" : "Doughnut resolution.\n"
          },
          "rtype" : "PGon",
          "types" : {
            "angle_interval" : "Interval\n",
            "cpt" : "Point\n",
            "radius_interval" : "Interval\n",
            "res" : "float\n"
          }
        },
        "end" : 545,
        "name" : "doughnut",
        "start" : 517
      } ],
      "documentation" : {
        "description" : [ "A very simple 2d polygon class", "Polygons limit their vertices to x and y dimensions, and enforce that they employ a basis.    Transformations of a polygon should generally be applied to the basis.    Any tranfromations of the underlying vertices should ensure that the returned vectors are limited to x and y dimensions" ]
      },
      "end" : 545,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_pgon.py",
      "name" : "PGon",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "CS" : 7,
          "EPSILON" : 6,
          "HasPts" : 1,
          "Intersector" : 1,
          "Interval" : 4,
          "PGon" : 12,
          "Plane" : 1,
          "Point" : 13,
          "Ray" : 3,
          "Segment" : 6,
          "Vec" : 14,
          "Xform" : 3
        },
        "functions" : {
          "__contains__" : 1,
          "__init__" : 1,
          "__repr__" : 1,
          "angle_bisector" : 1,
          "append" : 1,
          "appx_eq" : 1,
          "area" : 1,
          "basis_applied" : 1,
          "basis_stripped" : 1,
          "bounds" : 1,
          "cnr" : 1,
          "contains_pt" : 1,
          "doughnut" : 1,
          "edges" : 1,
          "eval" : 1,
          "inflate" : 1,
          "is_clockwise" : 1,
          "near" : 1,
          "near_pt" : 1,
          "offset" : 1,
          "overlaps" : 1,
          "rectangle" : 1,
          "rotated_to_min_bounds" : 1,
          "seg" : 1,
          "triangle" : 1
        }
      },
      "start" : 8
    },
    "51d4683b-ef3b-4cad-bf1c-8bc4a6e65860" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "print range(3)", "print range(4)", "", "" ],
          "end" : 19,
          "start" : 15
        },
        "description" : "\nCalling the built-in \"range\" function.\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "import math", "print math.sin(0), \"is smaller than\", math.cos(0)" ],
          "end" : 23,
          "start" : 22
        },
        "description" : "\nImporting the math module.\n",
        "end" : 22,
        "start" : 20
      } ],
      "documentation" : {
        "description" : [ "2.01.E01a", "While the functionality available to us when working in Python offers much of what the examples in this text require, there are times when we may want to supplement these \"native\" functions with more specialized ones." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01a.py",
      "name" : "2.01.E01a.py",
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "55e8acc2-c202-43cb-926b-b8d64b865f68" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pt_a = Point(2,3)", "pt_b = Point(10,20,30)", "#prints \"pt[2,3]\"", "print pt_a", "print pt_b", "" ],
          "end" : 21,
          "start" : 15
        },
        "description" : "\npoint construction\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "pt_a.x = 3", "print pt_a" ],
          "end" : 25,
          "start" : 24
        },
        "description" : "\npoint manipulation\n",
        "end" : 24,
        "start" : 22
      } ],
      "documentation" : {
        "description" : [ "2.01.E01b", "Points carry information about the x,y, and z coordinates of a position in Cartesian space" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01b.py",
      "name" : "2.01.E01b.py",
      "references" : {
        "classes" : {
          "Point" : 2
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "56b2646b-aae4-4b61-8c2b-97808a5f3c1e" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_point.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Point Constructor.", "", "            :param a: a value", "            :type a: float", "            :param b: b value", "            :type b: float", "            :param c: c value", "            :type c: float", "            :result: Point object", "            :rtype: Point", "            ", "            ", "            ::", "            ", "                pt_a=Point()", "                ", "                pt_b=Point(1,1)", "                ", "                pt_c=Point(1,1,1)", "                ", "                pts=[Point(i,i,i) for i in range(10)]", "                ", "            ", "        \"\"\"", "        super(Point,self).__init__(a,b,c)", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Point Constructor." ],
          "parameters" : {
            "a" : "a value\n",
            "b" : "b value\n",
            "c" : "c value\n"
          },
          "rtype" : "Point\n\n\n",
          "rvalue" : "Point object\n",
          "types" : {
            "a" : "float\n",
            "b" : "float\n",
            "c" : "float\n"
          }
        },
        "end" : 44,
        "name" : "__init__",
        "start" : 19
      }, {
        "code" : [ "        \"\"\"| Overloads the multiplication **(*)** operator.", "           | If a transformation is provided, applies the transformation to this point in a way equivalent to the expression ``other * self``.", "           | Otherwise, returns a new point that results from multiplying each of the point's coordinates by the value provided.", "        ", "           :param other: Number to multiply Point by.", "           :type other: float or Xform", "           :result: New point", "           :rtype: Point", "           ", "           ::", "           ", "                pt_a * 5", "        \"\"\"", "        from .dc_xform import Xform", "        if isinstance(other, Xform) : return other*self", "        else : " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the multiplication **(*)** operator.", "| If a transformation is provided, applies the transformation to this point in a way equivalent to the expression ``other * self``.", "| Otherwise, returns a new point that results from multiplying each of the point's coordinates by the value provided." ],
          "parameters" : {
            "other" : "Number to multiply Point by.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "New point\n",
          "types" : {
            "other" : "float or Xform\n"
          }
        },
        "end" : 61,
        "name" : "__mul__",
        "start" : 46
      }, {
        "code" : [ "        \"\"\"| Overloads the addition **(+)** operator. ", "           | Returns a new point that results from adding this point's world coordinates to the other point's (or vector's) world coordinates.", "           | No matter the basis of the inputs, the resulting point will have no basis.", "        ", "           :param other: Point or Vec to be added", "           :type other: Point or Vec", "           :result: New point.", "           :rtype: Point", "           ", "           ::", "                ", "                pt_a + pt_b", "        \"\"\"", "        return Point(self.x+other.x , self.y+other.y, self.z+other.z)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the addition **(+)** operator.", "| Returns a new point that results from adding this point's world coordinates to the other point's (or vector's) world coordinates.", "| No matter the basis of the inputs, the resulting point will have no basis." ],
          "parameters" : {
            "other" : "Point or Vec to be added\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "New point.\n",
          "types" : {
            "other" : "Point or Vec\n"
          }
        },
        "end" : 79,
        "name" : "__add__",
        "start" : 65
      }, {
        "code" : [ "        \"\"\"| Overloads the subtraction **(-)** operator", "           | Returns a new point that results from subtracting the other point's (or vector's) world coordinates from this point's world coordinates.", "           | No matter the basis of the inputs, the resulting point will have no basis.", "", "           :param other: Point or Vec to be subtracted", "           :type other: Point or Vec", "           :result: New point.", "           :rtype: Point", "           ", "           ::", "           ", "                pt_a - pt_b", "        \"\"\"", "        return Point(self.x-other.x , self.y-other.y, self.z-other.z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the subtraction **(-)** operator", "| Returns a new point that results from subtracting the other point's (or vector's) world coordinates from this point's world coordinates.", "| No matter the basis of the inputs, the resulting point will have no basis." ],
          "parameters" : {
            "other" : "Point or Vec to be subtracted\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "New point.\n",
          "types" : {
            "other" : "Point or Vec\n"
          }
        },
        "end" : 95,
        "name" : "__sub__",
        "start" : 81
      }, {
        "code" : [ "    def __div__(self, other): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 97,
        "name" : "__truediv__",
        "start" : 97
      }, {
        "code" : [ "        \"\"\"| Overloads the division **(/)** operator", "           | Returns a new point that results from dividing each of this point's world coordinates by the value provided.", "           | No matter the basis of the inputs, the resulting point will have no basis.", "        ", "           :param other: Number to divide Point by.", "           :type other: float.", "           :result: New point", "           :rtype: Point", "           ", "           ::", "           ", "                pt_a / 5", "        \"\"\"", "        return Point(self.x/float(other), self.y/float(other), self.z/float(other))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the division **(/)** operator", "| Returns a new point that results from dividing each of this point's world coordinates by the value provided.", "| No matter the basis of the inputs, the resulting point will have no basis." ],
          "parameters" : {
            "other" : "Number to divide Point by.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "New point\n",
          "types" : {
            "other" : "float.\n"
          }
        },
        "end" : 112,
        "name" : "__div__",
        "start" : 98
      }, {
        "code" : [ "        return \"pt[{0},{1},{2}]\".format(self.x,self.y,self.z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 115,
        "name" : "__repr__",
        "start" : 114
      }, {
        "code" : [ "        \"\"\" Overloads the less than **(<)** operator.", "        ", "            :param other: Point to be compared", "            :type other: Point", "            :result: Boolean result of comparison", "            :rtype: bool", "            ", "            ::", "            ", "                pt_a < pt_b", "        \"\"\"", "        try:", "            if self.z < other.z : return True", "            if self.z == other.z and self.y < other.y : return True", "            if self.z == other.z and self.y == other.y and self.x < other.x : return True", "            return False", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the less than **(<)** operator." ],
          "parameters" : {
            "other" : "Point to be compared\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 133,
        "name" : "__lt__",
        "start" : 117
      }, {
        "code" : [ "        \"\"\" Overloads the greater than **(>)** operator.", "        ", "            :param other: Point to be compared", "            :type other: Point", "            :result: Boolean result of comparison", "            :rtype: bool", "        \"\"\"", "        try:", "            if self.z > other.z : return True", "            if self.z == other.z and self.y > other.y : return True", "            if self.z == other.z and self.y == other.y and self.x > other.x : return True", "            return False", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the greater than **(>)** operator." ],
          "parameters" : {
            "other" : "Point to be compared\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 149,
        "name" : "__gt__",
        "start" : 137
      }, {
        "code" : [ "        \"\"\" Overloads the less than or equal to **(<=)** operator.", "        ", "            :param other: Point to be compared", "            :type other: Point", "            :result: Boolean result of comparison", "            :rtype: bool", "        \"\"\"", "        return True if (self < other or self == other) else False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the less than or equal to **(<=)** operator." ],
          "parameters" : {
            "other" : "Point to be compared\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 161,
        "name" : "__le__",
        "start" : 153
      }, {
        "code" : [ "        \"\"\" Overloads the greater than or equal to **(>=)** operator.", "        ", "            :param other: Point to be compared", "            :type other: Point", "            :result: Boolean result of comparison", "            :rtype: bool", "        \"\"\"", "        return True if (self > other or self == other) else False ", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the greater than or equal to **(>=)** operator." ],
          "parameters" : {
            "other" : "Point to be compared\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 171,
        "name" : "__ge__",
        "start" : 163
      }, {
        "code" : [ "        \"\"\" Returns the distance squared between this point and the other point in local space. Both points must use the same basis.", "        ", "            :param other: Point to calculate the distance from", "            :type other: Point", "            :result: Distance squared between points", "            :rtype: float", "            ", "            ::", "            ", "                pt_a.distance2(pt_b)", "        \"\"\"", "        return Vec(self,other).length2", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the distance squared between this point and the other point in local space. Both points must use the same basis." ],
          "parameters" : {
            "other" : "Point to calculate the distance from\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Distance squared between points\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 189,
        "name" : "distance2",
        "start" : 177
      }, {
        "code" : [ "        \"\"\" Returns the distance between this point and the other point in local space. Both points must use the same basis.", "        ", "            :param other: Point to calculate the distance from", "            :type other: Point", "            :result: Distance between points", "            :rtype: float", "            ", "            ::", "            ", "                pt_a.distance(pt_b)", "        \"\"\"", "        return Vec(self,other).length", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the distance between this point and the other point in local space. Both points must use the same basis." ],
          "parameters" : {
            "other" : "Point to calculate the distance from\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Distance between points\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 203,
        "name" : "distance",
        "start" : 191
      }, {
        "code" : [ "        \"\"\" Returns the distance squared between this point and the other point in local space. Both points must use the same basis.", "        ", "            :param other: Point to calculate the distance from", "            :type other: Point", "            :result: Distance squared between points", "            :rtype: float", "            ", "            ::", "            ", "                pt_a.distance2(pt_b)", "        \"\"\"", "        return Vec(self,other).length2", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the distance squared between this point and the other point in local space. Both points must use the same basis." ],
          "parameters" : {
            "other" : "Point to calculate the distance from\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Distance squared between points\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 217,
        "name" : "dist2",
        "start" : 205
      }, {
        "code" : [ "        \"\"\" Returns the distance between this point and the other point in local space. Both points must use the same basis.", "        ", "            :param other: Point to calculate the distance from", "            :type other: Point", "            :result: Distance between points", "            :rtype: float", "            ", "            ::", "            ", "                pt_a.distance(pt_b)", "        \"\"\"", "        return Vec(self,other).length", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the distance between this point and the other point in local space. Both points must use the same basis." ],
          "parameters" : {
            "other" : "Point to calculate the distance from\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Distance between points\n",
          "types" : {
            "other" : "Point\n"
          }
        },
        "end" : 231,
        "name" : "dist",
        "start" : 219
      }, {
        "code" : [ "        \"\"\" Returns a new point projected onto a destination vector", "        ", "            :param other: Destination vector", "            :type other: Vec", "            :result: A point projected onto a Vector", "            :rtype: Point", "            ", "            ::", "            ", "                pt_a.projected(Vec(1,1,1))", "        \"\"\"", "        return Point( Vec(self.x,self.y,self.z).projected(other) )", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new point projected onto a destination vector" ],
          "parameters" : {
            "other" : "Destination vector\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "A point projected onto a Vector\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 247,
        "name" : "projected",
        "start" : 235
      }, {
        "code" : [ "    def sorted_by_distance(pts,pt):", "        return [tup[1] for tup in sorted( [(p.dist2(pt),p) for p in pts] )]", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 251,
        "name" : "sorted_by_distance",
        "start" : 249
      }, {
        "code" : [ "    def near(pt, pts):", "        \"\"\" Returns a point from the given list of points which is nearest to the source point.", "", "            :param pt: Source point", "            :type pt: Point", "            :param pts: A list of points through which to search", "            :type pts: Point", "            :result: A point from the list which is nearest to the source point", "            :rtype: Point", "            ", "            ::", "            ", "                Point.near(pt_a,pts)", "        \"\"\"", "        return pts[Point.near_index(pt,pts)]", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a point from the given list of points which is nearest to the source point." ],
          "parameters" : {
            "pt" : "Source point\n",
            "pts" : "A list of points through which to search\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "A point from the list which is nearest to the source point\n",
          "types" : {
            "pt" : "Point\n",
            "pts" : "Point\n"
          }
        },
        "end" : 268,
        "name" : "near",
        "start" : 253
      }, {
        "code" : [ "    def near_index(pt, pts):", "        \"\"\" Returns the index of the point within the given list of points which is nearest to the source point.", "", "            :param pt: Source point", "            :type pt: Point", "            :param pts: A list of points through which to search", "            :type pts: Point", "            :result: The index of the nearest point", "            :rtype: int", "            ", "            ::", "            ", "                Point.near_index(pt_a, pts)", "                ", "        \"\"\"", "        dists = [pt.distance2(p) for p in pts]", "        return dists.index(min(dists))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns the index of the point within the given list of points which is nearest to the source point." ],
          "parameters" : {
            "pt" : "Source point\n",
            "pts" : "A list of points through which to search\n"
          },
          "rtype" : "int\n\n",
          "rvalue" : "The index of the nearest point\n",
          "types" : {
            "pt" : "Point\n",
            "pts" : "Point\n"
          }
        },
        "end" : 287,
        "name" : "near_index",
        "start" : 270
      }, {
        "code" : [ "    def far(pt, pts):", "        \"\"\" Returns a point from the given list of points which is furthest from the source point.", "", "            :param pt: Source point", "            :type pt: Point", "            :param pts: A list of points through which to search", "            :type pts: Point", "            :result: A point from the list which is furthest from the source point", "            :rtype: Point", "            ", "            ::", "            ", "                Point.far(pt_a, pts)", "        \"\"\"", "        return pts[Point.far_index(pt,pts)]", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a point from the given list of points which is furthest from the source point." ],
          "parameters" : {
            "pt" : "Source point\n",
            "pts" : "A list of points through which to search\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "A point from the list which is furthest from the source point\n",
          "types" : {
            "pt" : "Point\n",
            "pts" : "Point\n"
          }
        },
        "end" : 304,
        "name" : "far",
        "start" : 289
      }, {
        "code" : [ "    def far_index(pt, pts):", "        \"\"\" Returns the index of the point within the given list of points which is furthest from the source point.", "", "            :param pt: Source point", "            :type pt: Point", "            :param pts: A list of points through which to search", "            :type pts: Point", "            :result: The index of the furthest point", "            :rtype: int", "            ", "            ::", "            ", "                Point.far_index(pt_a, pts)", "        \"\"\"", "        dists = [pt.distance2(p) for p in pts]", "        return dists.index(max(dists))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns the index of the point within the given list of points which is furthest from the source point." ],
          "parameters" : {
            "pt" : "Source point\n",
            "pts" : "A list of points through which to search\n"
          },
          "rtype" : "int\n\n",
          "rvalue" : "The index of the furthest point\n",
          "types" : {
            "pt" : "Point\n",
            "pts" : "Point\n"
          }
        },
        "end" : 322,
        "name" : "far_index",
        "start" : 306
      }, {
        "code" : [ "    def interpolate(p0,p1,t=0.5): ", "        \"\"\" Returns a new point which is the result of an interpolation between the two given points at the given t-value.", "        ", "            :param p0: First point to interpolate", "            :type p0: Point", "            :param p1: Second point to interpolate", "            :type p1: Point", "            :param t: t-value of interpolation", "            :type t: float", "            :result: Interpolated point", "            :rtype: Point", "            ", "            ::", "            ", "                Point.interpolate(pt_a, pt_b)", "        \"\"\"", "        v = Vec.interpolate(p0,p1,t)", "        return Point(v.x,v.y,v.z)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a new point which is the result of an interpolation between the two given points at the given t-value." ],
          "parameters" : {
            "p0" : "First point to interpolate\n",
            "p1" : "Second point to interpolate\n",
            "t" : "t-value of interpolation\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Interpolated point\n",
          "types" : {
            "p0" : "Point\n",
            "p1" : "Point\n",
            "t" : "float\n"
          }
        },
        "end" : 342,
        "name" : "interpolate",
        "start" : 324
      }, {
        "code" : [ "    def centroid(points): ", "        \"\"\" Returns the centroid of a point cloud.", "        ", "            :param points: Point cloud", "            :type points: [Point]", "            :result: Centroid of point cloud.", "            :rtype: Point", "            ", "            ::", "            ", "                Point.centroid(pts)", "        \"\"\"", "        return Point( Vec.average(points) )", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns the centroid of a point cloud." ],
          "parameters" : {
            "points" : "Point cloud\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Centroid of point cloud.\n",
          "types" : {
            "points" : "[Point]\n"
          }
        },
        "end" : 357,
        "name" : "centroid",
        "start" : 344
      }, {
        "code" : [ "    def random(interval=None,constrain2d=False):", "        \"\"\" Returns a random point within the given (optional) range.", "        ", "            :param interval: Range to get the random value from.", "            :type interval: Interval", "            :param constrain2d: Constrain the point to 2d space.", "            :type constrain2d: bool", "            :result: Random point", "            :rtype: Point", "            ", "            ::", "            ", "                Point.random(Interval(0,10))", "        \"\"\"", "        if interval is None:", "            interval = Interval(-1.0,1.0)", "        x = random.uniform(interval.a,interval.b)", "        y = random.uniform(interval.a,interval.b)", "        z = random.uniform(interval.a,interval.b)", "        p = Point(x,y) if constrain2d else Point(x,y,z)", "        return p", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a random point within the given (optional) range." ],
          "parameters" : {
            "constrain2d" : "Constrain the point to 2d space.\n",
            "interval" : "Range to get the random value from.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Random point\n",
          "types" : {
            "constrain2d" : "bool\n",
            "interval" : "Interval\n"
          }
        },
        "end" : 380,
        "name" : "random",
        "start" : 359
      }, {
        "code" : [ "    def cull_duplicates(pts, threshold = EPSILON):", "        \"\"\" Discards duplicate points from a list of points.", "        ", "            :param pts: A list of points", "            :type pts: list", "            :param threshold: Tolerance of difference between points", "            :type threshold: float", "            :result: List of points without duplicates", "            :rtype: List", "            ", "            ::", "            ", "                Point.cull_duplicates(pts)", "        \"\"\"", "        if len(pts)==0: return pts", "        if threshold == None:", "            culled_pts = []" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Discards duplicate points from a list of points." ],
          "parameters" : {
            "pts" : "A list of points\n",
            "threshold" : "Tolerance of difference between points\n"
          },
          "rtype" : "List\n\n",
          "rvalue" : "List of points without duplicates\n",
          "types" : {
            "pts" : "list\n",
            "threshold" : "float\n"
          }
        },
        "end" : 398,
        "name" : "cull_duplicates",
        "start" : 382
      } ],
      "documentation" : {
        "description" : [ "a simple point class" ]
      },
      "end" : 398,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_point.py",
      "name" : "Point",
      "references" : {
        "classes" : {
          "EPSILON" : 1,
          "Interval" : 1,
          "Point" : 11,
          "Vec" : 8,
          "Xform" : 1
        },
        "functions" : {
          "__add__" : 1,
          "__div__" : 1,
          "__ge__" : 1,
          "__gt__" : 1,
          "__init__" : 1,
          "__le__" : 1,
          "__lt__" : 1,
          "__mul__" : 1,
          "__repr__" : 1,
          "__sub__" : 1,
          "__truediv__" : 1,
          "centroid" : 1,
          "cull_duplicates" : 1,
          "dist" : 1,
          "dist2" : 1,
          "distance" : 1,
          "distance2" : 1,
          "far" : 1,
          "far_index" : 1,
          "interpolate" : 1,
          "near" : 1,
          "near_index" : 1,
          "projected" : 1,
          "random" : 1,
          "sorted_by_distance" : 1
        }
      },
      "start" : 14
    },
    "56db18c2-638e-40ff-80aa-dabecc7bf332" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def func(u,v):", "    r = v", "    theta = u", "    z = sqrt(3)*v", "    return CS().eval_cyl(r,theta,z)", "    ", "ival_u = Interval.twopi()", "ival_v = Interval(0,h/sqrt(3))", "" ],
          "end" : 25,
          "start" : 16
        },
        "description" : " \nIce-cream Cone\nParametrized using cylindrical coordinates\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "def func(u,v):", "    phi = pi/6", "    rho = v   ", "    theta = u", "    return CS().eval_sph(rho,phi,theta)", "", "ival_u = Interval.twopi()", "ival_v = Interval(0,2*h/sqrt(3))   ", "" ],
          "end" : 38,
          "start" : 29
        },
        "description" : "\nIce-cream Cone \nParametrized using spherical coordinates\n",
        "end" : 29,
        "start" : 26
      }, {
        "code" : {
          "content" : [ "pts_domain = [Point(len_top*two_pi, 1), Point(len_mid*two_pi, mid), Point(len_bot*two_pi, 0)]", "crv_domain = Curve.bezier(pts_domain)", "", "def func_crv_cone(t):", "    pt_domain = crv_domain.eval(t)", "    u = pt_domain.x", "    v = pt_domain.y", "    return func_cone(u,v)    ", "    ", "crv = Curve(func_crv_cone, Interval())" ],
          "end" : 51,
          "start" : 41
        },
        "description" : "\nFreeform Curves on Cone\n",
        "end" : 41,
        "start" : 39
      }, {
        "code" : {
          "content" : [ "def func(u,v):", "    xf = Xform.rotation(axis=Vec(0,0,1),angle=u,center=Point() )", "    return crv_rot.eval(v)*xf", "", "ival_u = Interval.twopi()", "ival_v = Interval(0,1)", "" ],
          "end" : 61,
          "start" : 55
        },
        "description" : "\nIce-cream Cone\nConstructed as a rotation of a curve profile\n",
        "end" : 55,
        "start" : 52
      } ],
      "documentation" : {
        "description" : [ "3.09.E01c", "Cone (Parametrized) 3 ways", "Demonstrates the non-uniqueness of parametrizations" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Surface Basics/3.09.E01c.py",
      "name" : "3.09.E01c.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Curve" : 2,
          "Interval" : 7,
          "Point" : 4,
          "Vec" : 1,
          "Xform" : 1
        }
      },
      "result" : [ "function" ]
    },
    "5be1e51d-9df7-4d88-a4a5-34bf0d899942" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# create an empty list", "neighbors = []", "# for every index in the given Mesh vertices:", "for pi in range(len(msh.pts)):", "    # if its index is not the intended Point index:", "    if not pi == index: ", "        # add the Point to the list of neighbors", "        neighbors.append(msh.pts[pi]) ", "", "# a new Mesh using that uses the relaxed point", "new_msh = Mesh()", "# insert the the centroid of the neighbors ", "neighbors.insert(index,Point.centroid(neighbors))", "# rebuild this new mesh in the image of the old mesh", "new_msh.append(neighbors)", "for face in msh.faces:", "    new_msh.add_face(face[0], face[1], face[2], face[3])" ],
          "end" : 33,
          "start" : 17
        },
        "description" : "\nTwo-Dimensional Mesh Relaxation\nAdd all Points not being relaxed to a list, and then finds the centroid of that list\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.07.L05a", "Relaxes a two-dimensional Mesh.  Given a Mesh and the index of a Point to modify, produces a Mesh whose vertex at the given index has been moved to an optimal relaxed location." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Mesh Relaxation/4.07.L05a.py",
      "name" : "4.07.L05a.py",
      "references" : {
        "classes" : {
          "Mesh" : 1,
          "Point" : 1
        }
      },
      "required" : [ "msh (Mesh) The mesh to relax", "index (int) The index of the point to move" ],
      "result" : [ "new_msh (Mesh) The relaxed mesh" ]
    },
    "5f383857-9a57-46da-bc5e-684d607e548a" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def cluster(edge):", "    # create two triangles from a given edge", "    tri_a = RGon.from_edge(edge,3)", "    tri_b = RGon.from_edge(edge.inverted(),3)", "    # create two squares from two triangle edges", "    sq_a = RGon.from_edge(tri_a.edges[0],4)", "    sq_b = RGon.from_edge(tri_b.edges[1],4)", "    # create two triangles from two square edges", "    tri_c = RGon.from_edge(sq_a.edges[0],3)", "    tri_d = RGon.from_edge(sq_a.edges[2],3)", "    return [tri_a,tri_b,sq_a,sq_b,tri_c,tri_d]", "" ],
          "end" : 29,
          "start" : 17
        },
        "description" : "\nCluster Function\nDefines the cell consisting of a cluster of Rgons\n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "def xf_x():", "    # set the direction of the translation vector", "    vec = seed_edge.vec.cross(Vec(0,0,1))", "    # set the magnitude of the translation vector", "    vec = vec.normalized((1+sqrt(3))*seed_edge.length)    ", "    return Xform.translation(vec)", "" ],
          "end" : 40,
          "start" : 33
        },
        "description" : "\nX-Translate Function\nDefines the transformation for the \"x\"-translation, in direction perpendicular to seed edge\n",
        "end" : 33,
        "start" : 30
      }, {
        "code" : {
          "content" : [ "def xf_y(is_odd):", "    # first set the translation in the direction of the seed edge", "    vec = seed_edge.vec", "    vec = vec.normalized( 0.5 * (1 + sqrt(3))*seed_edge.length )", "    # add to this vector the shift in the \"x\"-directon", "    dx = 0.5 * (1 + sqrt(3))*seed_edge.length", "    if is_odd : dx *=-1", "    vec += vec.cross(Vec(0,0,1)).normalized(dx)", "    return Xform.translation(vec)", "" ],
          "end" : 55,
          "start" : 45
        },
        "description" : "\nY-Translate Function\nDefines the transformation for the \"y\"-translation, which shifts according to the cluster row\n[pseudo]\n",
        "end" : 45,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "# make sure seed edge is 2d", "seed_edge._pt.z = 0", "seed_edge._vec.z = 0", "", "# create a bin for the geometry clusters", "clusters = []", "for v in range(4):", "    row_clusters = []", "    # make sure the given edge is a segment, create a new edge with it", "    edge = Segment(seed_edge.spt,seed_edge.ept)", "    for u in range(4):", "        # create a cluster with the edge", "        new_cluster = cluster(edge)", "        row_clusters.append(new_cluster)", "        # translate the edge in X", "        edge *= xf_x()", "    clusters.append(row_clusters)", "    # translate the seed edge in y", "    seed_edge *= xf_y(v%2==0)", "" ],
          "end" : 79,
          "start" : 60
        },
        "description" : "\nCreate Clusters Routine\nCreates and aggregates a number of clusters starting from a seed edge\n[noprint]\n",
        "end" : 60,
        "start" : 56
      } ],
      "documentation" : {
        "description" : [ "4.01.L01a", "Given a \"seed edge\" line, create a snub square tiling pattern by cell.", "This includes methods for creating clusters of RGons that may be repeated to create", "repeated pattern, and for defining the x- and y- transformations of each of these clusters." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Regular Tiling/4.01.L01a.py",
      "name" : "4.01.L01a.py",
      "references" : {
        "classes" : {
          "RGon" : 6,
          "Segment" : 1,
          "Vec" : 2,
          "Xform" : 2
        }
      },
      "required" : [ "seed_edge (Segment) The edge from which the tiling pattern will start." ],
      "result" : [ "ret ([RGon]) Regular Polygons arranged in a snub square pattern." ]
    },
    "5fabe81b-2e67-4009-a807-e7a0518f9824" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def sort_polygons(shapes_in = []):", "        # first, rotate into minimum bounds", "        shapes = [s.rotated_to_min_bounds() for s in shapes_in]", "        ", "        # for every shape in shapes:", "        for i,s in enumerate(shapes):", "           # create a value field", "           s.val = s.bounds.dim_x * s.bounds.dim_y", "        # sort list", "        shapes.sort(key=lambda s: (s.val), reverse=True)", "        return shapes", "" ],
          "end" : 33,
          "start" : 20
        },
        "description" : "\nSort Polygon Method\nMethod to sort given PGons by area.\n[noprint]\n",
        "end" : 20,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "", "def bin_polygons(shapes = [], sheet_size = Interval(100,100)):", "        # construct a Bin with a given width and height", "        sheets = [Bin(Point(0,0), sheet_size.a, sheet_size.b)]", "        # start with one sheet", "        no_sheets = 1", "        ", "        # for every shape in shapes:", "        for i, r in enumerate(shapes):", "            # see if rectangle fits into one of the sheets", "            flag = False", "            # for every sheet in sheets:", "            for j, s in enumerate(sheets):", "                # see if the shape can fit in the sheet", "                test_bin = s.can_fit(r)", "                if test_bin <> None:", "                    # place the item onto the Bin", "                    test_bin.put_item(r)", "                    flag = True", "                    break", "            if not flag:", "                # create a new Bin", "                sheets.append(Bin(Point(0,0), sheet_size.a, sheet_size.b))", "                # add a new Sheet to the count", "                no_sheets += 1", "                # place the item onto the new sheet", "                sheets[no_sheets-1].put_item(r)", "        return sheets", "", "" ],
          "end" : 66,
          "start" : 37
        },
        "description" : "\nBin Polygons\nMethod to place sorted PGons onto Bins.\n",
        "end" : 37,
        "start" : 34
      } ],
      "documentation" : {
        "description" : [ "4.05.L01d", "Given a set of rectangles of random sizes, fit them onto Bins with a standard size." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01d.py",
      "name" : "4.05.L01d.py",
      "references" : {
        "classes" : {
          "Bin" : 2,
          "Interval" : 1,
          "Point" : 2
        }
      },
      "required" : [ "Bin (Bin) Bin class for packing", "w (float) Width of the Bin", "h (float) Height of the Bin", "rec     ([PGon]) List of rectangles to be placed onto the sheets." ],
      "result" : [ "new_sheet (PGon) Sheet PGon.", "packed_item (PGon) PGon placed onto the sheets." ]
    },
    "608ea6d5-6256-4f30-a57f-075ed5fcb9b8" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create a TileC and inflate it once", "tiles = AmmannA3TileC().inflate()", "", "# for every desired generation of Ammann tiles:", "for n in range(iter):", "    # create a container to hold inflated tiles", "    nxt_tiles = []", "    #inflate each tile in the current generation, and store", "    for tile in tiles: nxt_tiles.extend(tile.inflate())", "    # set things up for the next generation of inflation", "    tiles = nxt_tiles", "" ],
          "end" : 28,
          "start" : 16
        },
        "description" : " \nAmmann A3 Tiling Routine\nCreates and recursively inflates an Ammann A3 Tile\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.01.L04d", "Create a Ammann tile object and inflate the tile." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Tiling by Inflation/4.01.L04d.py",
      "name" : "4.01.L04d.py",
      "references" : {
        "classes" : {
          "AmmannA3TileC" : 1
        }
      },
      "required" : [ "tileC (PinwheelTile) Ammann Tile C Class.", "iter (int) Number of recursions." ],
      "result" : [ "ret ([PGon]) Ammann tiles." ]
    },
    "60f2e021-3164-47a5-af4e-795567d842de" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# initialize a single instance of the Guy class", "debord = Guy(start_pt,start_vel)", "path_pts = []", "for n in range(count):", "    # record the Guy's position", "    path_pts.append(debord.pos)", "    # update the Guy's position and velocity", "    debord.step()", "", "# create a path representing this Guy's journey", "path_line = PLine(path_pts)", "" ],
          "end" : 32,
          "start" : 20
        },
        "description" : "\nSimple Walker Routine\nCreates a Guy and lets it wander, then creates a PLine that describe the path it took\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.02.L04b", "Make an instance of the Guy class and make it wander around." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04b.py",
      "name" : "4.02.L04b.py",
      "references" : {
        "classes" : {
          "Guy" : 1,
          "PLine" : 1
        }
      },
      "required" : [ "Guy (class) A class of walker", "start_pt (Point) Initial point of the wandering Guy", "start_vel (Vec) Initial velocity of the the wandering Guy", "count (int) Amount of time for Guy to wander" ],
      "result" : [ "path_pts ([Point]) Position of the wandering Guy at each time step", "path_line (Pline) Path of the wandering Guy" ]
    },
    "6230a0c6-1b57-47cf-a0d9-9dd24770038d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class Bin():", "    def __init__(self, cpt, w, h, filled = False, div_type = 'a'):", "        # corner Point of the Bin", "        self.cpt = cpt", "        # width of Bin", "        self.w = w", "        # height of Bin", "        self.h = h", "        # is this Bin currently filled?", "        self.filled = filled", "        # method to divide the Bin", "        self.div = div_type", "        cpt_b = Point(cpt.x+w/2.0, cpt.y+h/2.0)", "        # boundary of the Bin", "        self.boundary = Bounds(center = cpt_b, dim_x =w, dim_y = h)", "        self.filling = []", "", "    \"\"\"", "    Put Item in Bin", "    Puts items in a new Bin container, based on different packing methods. ", "    [pseudo]", "    \"\"\"", "    ", "    def put_item(self, shape): ", "        # create a CS on the corner Point of the bin", "        c = CS(self.cpt - shape.bounds.corners[0])", "        # assign a new basis to the shape", "        shape.basis = c  ", "        xbin = shape.bounds.dim_x", "        ybin = shape.bounds.dim_y", "        # start a new list to add the packed Bins ", "        result = [Bin(self.cpt, xbin, ybin, filled = shape)]", "        # get the empty value in x", "        rem_x = self.boundary.dim_x - shape.bounds.dim_x", "        # get the empty value in y", "        rem_y = self.boundary.dim_y - shape.bounds.dim_y", "        # if the remaining value in x is smaller than 0:", "        if rem_x <= 0: ", "            # if the remaining value in y is larger than 0:", "            if rem_y > 0:", "                # the corner Point of the Bin is at the current y value", "                npt = self.cpt + Vec(0,shape.bounds.dim_y)", "                # create a new Bin", "                result.append(Bin(npt, self.boundary.dim_x, rem_y))", "        # elif the remaining value in y is smaller than 0:", "        elif rem_y <= 0: ", "            # the corner Point of the Bin is at the current x value", "            npt = self.cpt + Vec(shape.bounds.dim_x,0)", "            # create a new Bin", "            result.append(Bin(npt, rem_x, self.boundary.dim_y))", "        else:", "            divide_w = False", "            divide_h = False", "            # if the divide method is width: set divide_w to True", "            if self.div == 'w' : divide_w = True", "            # if the divide method is height: set divide_h to True", "            if self.div == 'h' : divide_h = True", "            # if the divide method is area:", "            if self.div == 'a' :", "                # do minimum area divide method", "                val_a = (self.boundary.dim_x * rem_y)", "                val_b = (rem_x * self.boundary.dim_y)", "                divide_w = (val_a > val_b)", "                divide_h = not(divide_w)", "            # if the divide method is minimum", "            if self.div == 'n':", "                # do minimum divide method", "                val_a = (self.boundary.dim_x / rem_y)", "                val_b = (self.boundary.dim_y / rem_x)", "                divide_w = (val_a < val_b)", "                divide_h = not(divide_w)", "            # if the divide method is maximum", "            if self.div == 'x':", "                # do maximum divide method", "                val_a = (self.boundary.dim_x / rem_y)", "                val_b = (self.boundary.dim_y / rem_x)", "                divide_w = (val_a > val_b)", "                divide_h = not(divide_w)", "            # if there is a divide_w:", "            if divide_w :", "                pt_a = self.cpt + Vec(shape.bounds.dim_x,0)", "                # create a Bin with the remaining", "                result.append(Bin(pt_a, rem_x, shape.bounds.dim_y))", "                pt_b = self.cpt + Vec(0,shape.bounds.dim_y)", "                # add the item to the Bin", "                result.append(Bin(pt_b, self.boundary.dim_x, rem_y))", "            # if there is a divide_h:", "            if divide_h :", "                pt_a = self.cpt + Vec(shape.bounds.dim_x,0)", "                # create a Bin with the remaining ", "                result.append(Bin(pt_a, rem_x, self.boundary.dim_y))", "                pt_b = self.cpt + Vec(0,shape.bounds.dim_y)", "                # add the item to the Bin", "                result.append(Bin(pt_b, shape.bounds.dim_x, rem_y))", "        ", "        # set filling member to the packing result", "        self.filling = result", "", "    \"\"\"", "    Query Methods", "    Method that returns a bool value whether or not an item can fit in a container. Method to Bin PGons. ", "    \"\"\"", "    # decides if an item fits in a Bin", "    def can_fit(self, shape):", "        # if there are no other items in the Bin:", "        if len(self.filling) == 0:", "            # if the item fits in the container:", "            if (shape.bounds.dim_x <=self.w) and (shape.bounds.dim_y <=self.h): ", "                return self", "        else:", "            # for every index in the indexes from the second element:", "            for i in range(1,len(self.filling)) :", "                # decide if the item can fit in the Bin", "                result = self.filling[i].can_fit(shape)", "                if  result<> None : return result", "        return None", "    ", "    # Bins PGons", "    def get_polygons(self, bin_filled = Color(1), bin_edges = Color(.5)):", "        print \"binning a polygon!\"", "        # if the item is a PGon:", "        if isinstance(self.filled, PGon):", "            poly = self.filled", "            # set the Color of the PGon", "            poly.set_color(bin_filled)", "            return [poly]", "        p_list = []", "        # for every index in the list of Bins:", "        for j in range(len(self.filling)):", "            # get the PGons", "            p = self.filling[j].get_polygons(bin_filled, bin_edges)", "            if p is not None: p_list.extend(p)", "        return p_list" ],
          "end" : 155,
          "start" : 22
        },
        "description" : "\n2D Packing Bin Class\nConstruct a Bin object which can be filled with sub-bins and open areas.\n",
        "end" : 22,
        "start" : 19
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01c.py",
      "name" : "4.05.L01c.py",
      "references" : {
        "classes" : {
          "Bin" : 8,
          "Bounds" : 1,
          "CS" : 1,
          "Color" : 2,
          "PGon" : 1,
          "Point" : 1,
          "Vec" : 6
        }
      }
    },
    "62b67a70-470a-42a0-a0d6-915f7f07a384" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# create 2 rays with a Point and 2 Vecs", "ray1 = Ray(pt,vec1)", "ray2 = Ray(pt,vec2)", "# get the angle between the 2 Vecs", "ang = vec1.angle(vec2)", "# get the bisector of the 2 Vecs", "bisec = Vec.bisector(vec1, vec2)", "# set the length of the bisector to the hypotenuse ", "bisec.length = ri/math.sin(ang/2)", "# set the origin for the CS", "pt_a = pt + bisec", "", "# set the length of vec1 to the adjacent side ", "vec1.length = ri/math.tan(ang/2)", "# set a Point on ray1", "pt_b = pt + vec1", "# set the vec_a to create the CS for the Arc", "vec_a = Vec(pt_a,pt_b)", "# create the CS for the Arc", "cs = CS(pt_a, vec_a, Vec(pt_a,pt))", "# make the first Arc", "arc = Arc(cs,ri,ang)", "" ],
          "end" : 44,
          "start" : 21
        },
        "description" : "\nOriginal Arc\nGiven a Point, 2 Vecs, an initial radius and a panel dimension, create an Arc within 2 Rays created\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "# set the new radius as a rounded number of planels", "new_rad = round(arc.length / panel_dim) * panel_dim", "# move the origin of the CS according to the new radius", "bisec.length = new_rad/math.sin(ang/2)", "# set the origin for the CS", "pt_a2 = pt + bisec", "", "# set the length of vec1 to the adjacent side ", "vec1.length = new_rad/math.tan(ang/2)", "# set a Point on ray1", "pt_b2 = pt + vec1", "# set the vec_a2 to create the CS for the Arc", "vec_a2 = Vec(pt_a2,pt_b2)", "# create the CS for the Arc", "cs2 = CS(pt_a2, vec_a2, Vec(pt_a2,pt))", "# make the adjusted Arc", "arc2 = Arc(cs2,new_rad,ang)" ],
          "end" : 64,
          "start" : 48
        },
        "description" : "\nAdjusted Arc\nReadjust the radius to have rounded number of panels\n",
        "end" : 48,
        "start" : 45
      } ],
      "documentation" : {
        "description" : [ "4.05.L01f", "Given a Point, 2 Vecs, an initial radius and a panel dimension, create an Arc within 2 Rays created. Readjust the radius according to a panel dimension." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01f.py",
      "name" : "4.05.L01f.py",
      "references" : {
        "classes" : {
          "Arc" : 2,
          "CS" : 2,
          "Ray" : 2,
          "Vec" : 5
        }
      },
      "required" : [ "pt (Point) Starting Point for the Rays", "vec1 (Vec) First Vec for ray1", "vec2 (Vec) Second Vec for ray2", "ri (float) Value for initial Arc radius.", "panel_dim (float) Size of panels." ],
      "result" : [ "arc (Arc) Original Arc.", "arc2 (Arc) Readjusted Arc." ]
    },
    "639c8e3f-2300-4eb9-b4be-3fb4716702b5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "import math", "# define constants", "SQRT2_3 = (2/3)**0.5", "SQRT3_3 = (3**0.5)/3", "" ],
          "end" : 20,
          "start" : 15
        },
        "description" : "\n[noprint]\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "# Define constants", "diagonal = (3**0.5) # diagonal length of bounds", "height = diagonal/2 # vertical height of one TruncTet ", "length = height/SQRT2_3 # length of one TuncTet", "rad = length*SQRT3_3 # radius of one TruncTet", "", "def make_tructet_pair(bounds, trunc = 2/3):", "    # Create a CS oriented to a diagonal of the bounds", "    nrml = Vec(bounds.cpt, bounds.corners[6])", "    pln = Plane(bounds.cpt, nrml)", "    proj_pt = pln.near_pt(bounds.corners[4])", "    x_vec = Vec(bounds.cpt, proj_pt)", "    y_vec = nrml.cross(x_vec)", "    ", "    # create the first TruncTet in the direction of the x_vector", "    cs = CS(bounds.cpt, x_vec, y_vec)", "    tet1 = TruncTet(Tetrahedron.from_face_center(cs, rad), trunc)", "    # create the second TruncTet by flipping the x_vector", "    cs = CS(bounds.cpt, -x_vec, y_vec)", "    tet2 = TruncTet(Tetrahedron.from_face_center(cs, rad),trunc)", "    ", "    return tet1, tet2", "" ],
          "end" : 47,
          "start" : 24
        },
        "description" : "\nMake Pair Method\nCreates a pair of truncated Tetrahedra given a bounding box they are to occupy. The default truncation value of 2/3 is appropriate for a space-filling packing routine\n",
        "end" : 24,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "tets = []", "ijk_grid = [(i,j,k) for i in range(3) for j in range(3) for k in range(3)]", "for i,j,k in ijk_grid:", "    # construct a bounds for this pair of tets", "    ctr = Point(i/2+j/2, j/2+k/2, i/2+k/2)", "    pair_bounds = Bounds(center = ctr,dim_x=1.0,dim_y=1.0,dim_z=1.0)", "    # make two TruncTets", "    tets.extend(make_tructet_pair(pair_bounds))", "            " ],
          "end" : 60,
          "start" : 52
        },
        "description" : "\nSpace Filling Routine\nMakes an 3 x 3 x 3 array of space filling truncated tetrahedra, constructed in pairs that each occupy \na 1 x 1 x 1 bounding box\n",
        "end" : 52,
        "start" : 48
      } ],
      "documentation" : {
        "description" : [ "4.01.F01c", "A Space-Filling Aggregation of TruncTets" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Aranda Lasch Fractal/4.01.F01c.py",
      "name" : "4.01.F01c.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "CS" : 2,
          "Plane" : 1,
          "Point" : 1,
          "SQRT2_3" : 2,
          "SQRT3_3" : 2,
          "Tetrahedron" : 2,
          "TruncTet" : 2,
          "Vec" : 2
        }
      },
      "required" : [ "Tetrahedron (Class) A tetrahedron class.", "TruncTet (Class) A truncated tetrahedron class ." ],
      "result" : [ "tets ([(TruncTet,TruncTet)]) A list of tuples of TruncTets." ]
    },
    "649d7a37-f31c-4119-a956-65cf6b998eca" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 10,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "BasisError",
      "references" : {
        "classes" : {
          "BasisError" : 1,
          "GeometricError" : 1
        }
      },
      "start" : 10
    },
    "657c2d72-4d9e-4188-bcb8-7d8ad9fbeca9" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/poisson_sampling.py",
      "definitions" : [ {
        "code" : [ "        ", "        self.r = r", "        self.r_sqr = r*r", "        self.cell_size = r/m.sqrt(2)", "        self.dom_x, self.dom_y = bds.ival_x, bds.ival_y", "        self.len_row = int(m.ceil(self.dom_x.b/self.cell_size))", "        self.len_col = int(m.ceil(self.dom_y.b/self.cell_size))", "        self.cells = {}", "        self.graph = Graph()", "        ", "        for xi in range(self.len_row):", "            for yi in range(self.len_col):", "                self.cells[(xi,yi)] = []", "        ", "        for cell in self.cells:", "            if cell[0]<self.len_row and cell[1]<self.len_col:", "                self.graph.add_edge(cell, (cell[0], cell[1]+1))", "                self.graph.add_edge(cell, (cell[0]+1, cell[1]+1))", "                self.graph.add_edge(cell, (cell[0]+1, cell[1]))", "            if 0<cell[0]: self.graph.add_edge(cell, (cell[0]-1, cell[1]+1))", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 28,
        "name" : "__init__",
        "start" : 8
      }, {
        "code" : [ "        return (int(m.floor(p.x/self.cell_size)), int(m.floor(p.y/self.cell_size)))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 32,
        "name" : "grid_coord",
        "start" : 31
      }, {
        "code" : [ "        return p.x in self.dom_x and p.y in self.dom_y", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 36,
        "name" : "in_bds",
        "start" : 35
      }, {
        "code" : [ "        index = self.grid_coord(p)", "        if len(self.cells[index]):return True", "        for ci in self.graph.edges[index]:", "            if ci in self.cells:", "                for pt in self.cells[ci]:", "                    if p.distance2(pt) <= self.r_sqr:", "                        return True", "        return False", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 47,
        "name" : "in_nbd",
        "start" : 39
      }, {
        "code" : [ "        ", "        def put_point(p):", "            process_list.append(p)", "            sample_points.append(p)", "            self.cells[self.grid_coord(p)].append(p)", "        ", "        def gen_random(p, r):", "            rr = random.uniform(r, 2*r)", "            rt = random.uniform(0, 2*m.pi)", "            return Point(p.x+rr*m.sin(rt), p.y+rr*m.cos(rt))", "        ", "        process_list = []", "        sample_points = []", "        ", "        x0 = Point(self.dom_x.eval(random.random()), self.dom_y.eval(random.random()))", "        put_point(x0)", "        ", "        cycles = 0", "        while len(process_list):", "            ", "            process_pt =random.choice(process_list)", "            process_list.remove(process_pt)", "            coord = self.grid_coord(process_pt)", "            ", "            for i in range(k):", "                check_pt = gen_random(process_pt, self.r)", "                if self.in_bds(check_pt) and not self.in_nbd(check_pt) :", "                    put_point(check_pt)", "                ", "            cycles+=1", "            if cycles > max_cycles:", "                print 'stopped after {} cycles'.format(max_cycles)", "                break", "        ", "        return sample_points" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 85,
        "name" : "run",
        "start" : 50
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 85,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/poisson_sampling.py",
      "name" : "Poisson_Sampler",
      "references" : {
        "classes" : {
          "Graph" : 1,
          "Point" : 2,
          "Poisson_Sampler" : 1
        },
        "functions" : {
          "__init__" : 1,
          "gen_random" : 1,
          "grid_coord" : 1,
          "in_bds" : 1,
          "in_nbd" : 1,
          "put_point" : 1,
          "run" : 1
        }
      },
      "start" : 6
    },
    "668c9a36-37b4-44c1-a106-83c33862029c" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_2d.py",
      "definitions" : [ {
        "code" : [ "        # Assign lineage to object", "        self.lineage = lineage", "        # Assign a xform to the object", "        self.xf = xf", "        #the amount to scale down at each inflation = 0.618033989", "        self._xf_scale = Xform.scale(1/tau) ", "        self.scale = scale", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 121,
        "name" : "__init__",
        "start" : 114
      }, {
        "code" : [ "        \"\"\"", "        Returns a CS oriented to an idealized tile's base points.  ", "        Multiply result by this_tile.xf and you'll get a coordinate system oriented to the postition of this tile in the world", "        pt_0: index of origin point", "        pt_x: index of a point on the desired x-axis", "        pt_y: index of a point on the desired y-axis", "        \"\"\"", "        return CS(self._base_pts[pt_o],self._base_pts[pt_x]-self._base_pts[pt_o],self._base_pts[pt_y]-self._base_pts[pt_o])", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a CS oriented to an idealized tile's base points.", "Multiply result by this_tile.xf and you'll get a coordinate system oriented to the postition of this tile in the world", "pt_0: index of origin point", "pt_x: index of a point on the desired x-axis", "pt_y: index of a point on the desired y-axis" ]
        },
        "end" : 131,
        "name" : "_cs_from_base_pts",
        "start" : 123
      }, {
        "code" : [ "    def base_pts(self):", "        \"\"\"", "        world base points for this tile", "        returns the ideal Ammann Tile's base points transformed by this tile's xform", "        \"\"\"", "        return [p*self.xf for p in self._base_pts]", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "world base points for this tile", "returns the ideal Ammann Tile's base points transformed by this tile's xform" ]
        },
        "end" : 139,
        "name" : "base_pts",
        "start" : 133
      } ],
      "documentation" : {
        "description" : [ "Ammann A3", "http://tilings.math.uni-bielefeld.de/substitution_rules/ammann_a3" ]
      },
      "end" : 139,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_2d.py",
      "name" : "AmmannA3Tile",
      "references" : {
        "classes" : {
          "AmmannA3Tile" : 1,
          "CS" : 1,
          "Xform" : 2
        },
        "functions" : {
          "__init__" : 1,
          "_cs_from_base_pts" : 1,
          "base_pts" : 1
        }
      },
      "start" : 107
    },
    "684dbcf9-673b-4e33-92e0-46596aa5dcee" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def perp_vec(vec1,vec2,pt):", "    # get the bisector of vec1 and vec2", "    bisecs = Vec.bisector(-vec1,vec2)", "    # get the perpendicular Vec to the bisector", "    return bisecs.cross(CS(pt, bisecs, Vec(0,0,1)).z_axis).normalized()", "" ],
          "end" : 25,
          "start" : 19
        },
        "description" : "\nMethod to get a perpendicular vector\n[noprint]\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def divide_crv(pt_a,pt_b,vec):", "    tan = vec * rad", "    # move the Point with the tan Vec", "    new_pt = pt_a + tan", "    # find the tangent Point on a Circle from a given Point", "    pt = Segment(new_pt, pt_b).eval(0.5)", "    cir1 = Circle(Plane(new_pt, CS(new_pt,tan,Vec(0,0,-1)).z_axis),rad)", "    cir2 = Circle(Plane(pt, CS(pt,tan,Vec(0,0,-1)).z_axis),pt.distance(new_pt))", "    # get the intersections between the Circles ", "    xsec = Intersector()", "    # if there is an intersection:", "    if xsec.of(cir1,cir2):", "        # get the intersection", "        inters = xsec._geom", "    # if there is more than one intersection:", "    if len(inters)>1:", "        # keep the intersection Point closer to the original Point", "        segs = [Segment(pt_a,inter) for inter in inters]", "        segs.sort(key=lambda seg: seg.length)   ", "        inters = segs[0].ept", "    # create a straight Segment", "    ln = Segment(inters, pt_b)", "    # get the angle between the tan and a new Vec ", "    angle = tan.angle(Vec(inters,new_pt))", "    # get the cross Vec to translate the mid Point", "    cross_vec = tan.cross(CS(new_pt,tan,Vec(new_pt,pt_b)).z_axis).inverted()", "    # create the arc", "    arc = Arc(CS(new_pt,-tan,cross_vec), rad, angle)", "    return  arc, ln", "" ],
          "end" : 59,
          "start" : 29
        },
        "description" : "\nTangent Arc-Segment\nMethod to construct a Segment and an Arc whose start and end point lie on the given points, and that maintain tangency with the given vector\n",
        "end" : 29,
        "start" : 26
      }, {
        "code" : {
          "content" : [ "", "# for every index and Curve in the list of Curves:", "for i, crv in enumerate(crvs):", "    # get a list of t values to evaluate the Curve", "    ints = Interval().divide(divs)[1:]", "    # get the Curve starting Point", "    pts = [crv.eval(0)]", "    # for every t in the t values:", "    for t in ints:", "        # evaluate the Curves in t ", "        pts.append(crvs[i].eval(t))", "    # get the Curve ept", "    pts.append(crv.eval(1))", "", "    new_perp_vec = perp_vec(Vec(0,0,-1),Vec(pts[0],pts[1]),pts[0])", "    # get the first Segment and Arc", "    new_crvs = [divide_crv(pts[0],pts[1],new_perp_vec)]", "    # for every index in the Points - 1:", "    for n in range(1,len(pts)-1):", "        new_cs = CS(pts[n],-new_crvs[n-1][1].vec,Vec(0,0,1))", "        # get the last Segment of the list and get a new Vec", "        vec = -new_crvs[n-1][1].vec.cross(new_cs.z_axis).normalized()", "        # construct more Arcs and Segments", "        new_crvs.append(divide_crv(pts[n],pts[n+1],vec))" ],
          "end" : 86,
          "start" : 63
        },
        "description" : "\nBeziers to Tangent Arc-Segments\nGiven a list of bezier Curves, subdivide them into a number of Points, and use every pair of Points to create a tangent arc-segment pair. \n",
        "end" : 63,
        "start" : 60
      } ],
      "documentation" : {
        "description" : [ "4.05.F01b", "Given a number of Curves, subidivide them, create an Arc with a given radius and get the tangent Points of the current Circle with the previous Point to create straight Segments." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Bending Active/4.05.F01b.py",
      "name" : "4.05.F01b.py",
      "references" : {
        "classes" : {
          "Arc" : 1,
          "CS" : 6,
          "Circle" : 2,
          "Intersector" : 1,
          "Interval" : 1,
          "Plane" : 2,
          "Segment" : 3,
          "Vec" : 9
        }
      },
      "required" : [ "crvs ([Cuve]) Given Curves to subdivide.", "rad (float) Radius for the Arcs.", "divs (int) Number of divisions for the curves" ],
      "result" : [ "pts ([Point]) List of starting Points for the new Curves.", "new_crvs ([Arc and Segment]) Arcs and Segments created from the bezier Curves." ]
    },
    "68662f7f-8359-4dc1-9c73-9048e802b9e0" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_2d.py",
      "definitions" : [ {
        "code" : [ "        self.lineage = lineage", "        self.xf = xf", "", "        self._xf_scale = Xform.scale(1/math.sqrt(5)) #the amount to scale down at each inflation = 0.447213595", "        ", "        # the idealized base points for all pinwheel tiles", "        self._base_pts= [", "            Point(),", "            Point(2.0, 0.0),", "            Point(0.0, 1.0),", "            Point(0.2, 0.4),", "            Point(1.2, 0.4),", "            Point(0.4, 0.8),", "            Point(1.0, 0.0),", "        ]", "", "        # sets base colors for pinwheeel tiles", "        self._colors=[", "                      Color(0.41,0.34,0.13)," ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 32,
        "name" : "__init__",
        "start" : 14
      }, {
        "code" : [ "    def base_pts(self):", "        '''", "        world base points for this tile", "        returns the ideal Pinwheel Tile's base points transformed by this tile's xform", "        '''", "        return [p*self.xf for p in self._base_pts]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "world base points for this tile", "returns the ideal Pinwheel Tile's base points transformed by this tile's xform" ]
        },
        "end" : 46,
        "name" : "base_pts",
        "start" : 40
      }, {
        "code" : [ "        '''", "        Returns a CS oriented to an idealized tile's base points.  ", "        Multiply result by this_tile.xf and you'll get a coordinate system oriented to the postition of this tile in the world", "        pt_0: index of origin point", "        pt_x: index of a point on the desired x-axis", "        pt_y: index of a point on the desired y-axis", "        '''", "        return CS(self._base_pts[pt_o],self._base_pts[pt_x]-self._base_pts[pt_o],self._base_pts[pt_y]-self._base_pts[pt_o])", "            " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a CS oriented to an idealized tile's base points.", "Multiply result by this_tile.xf and you'll get a coordinate system oriented to the postition of this tile in the world", "pt_0: index of origin point", "pt_x: index of a point on the desired x-axis", "pt_y: index of a point on the desired y-axis" ]
        },
        "end" : 57,
        "name" : "_cs_from_base_pts",
        "start" : 49
      }, {
        "code" : [ "        if color is None : ", "            clr_list = self._lineage_to_colors()", "            try:", "                clr_list.reverse()", "                color = clr_list[0]", "                for parent_color in clr_list[1:]:", "                    color = Color.interpolate(color,parent_color,parent_color_inheritance)", "            except:", "                color = clr_list", "", "        msh = Mesh()", "        msh.append(self._base_pts[0] * self.xf)", "        msh.append(self._base_pts[1] * self.xf)", "        msh.append(self._base_pts[2] * self.xf)", "        msh.add_face(0,1,2)", "        msh.set_name(self.lineage)", "        msh.set_color(color)", "        return msh", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 77,
        "name" : "to_mesh",
        "start" : 59
      }, {
        "code" : [ "        lin = self.lineage.split(',')", "        if len(lin)==0 : return Color()", "        return [self._colors[int(str)] for str in lin[1:]]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 82,
        "name" : "_lineage_to_colors",
        "start" : 79
      }, {
        "code" : [ "    def centroid(self): return Point.centroid(self.base_pts)", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 85,
        "name" : "centroid",
        "start" : 84
      }, {
        "code" : [ "        cs = self._cs_from_base_pts(3,6,5)", "        tile0 = PinwheelTile(self.xf * cs.xform * self._xf_scale,self.lineage+\",0\")", "                                                                                                                                                                                     ", "        cs = self._cs_from_base_pts(4,5,6)                                                                                                                ", "        tile1 = PinwheelTile(self.xf * cs.xform * self._xf_scale,self.lineage+\",1\")", "                                                                                                                                                                                     ", "        cs = self._cs_from_base_pts(3,6,0)                                                                                                                ", "        tile2 = PinwheelTile(self.xf * cs.xform * self._xf_scale,self.lineage+\",2\" )", "                                                                                                                                                                                     ", "        cs = self._cs_from_base_pts(5,0,2)                                                                                                                ", "        tile3 = PinwheelTile(self.xf * cs.xform * self._xf_scale,self.lineage+\",3\")", "        ", "        cs = self._cs_from_base_pts(4,1,6)", "        tile4 = PinwheelTile(self.xf * cs.xform * self._xf_scale , self.lineage+\",4\")", "        ", "        return [tile0,tile1,tile2,tile3,tile4]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 103,
        "name" : "inflate",
        "start" : 87
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 103,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_2d.py",
      "name" : "PinwheelTile",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Color" : 7,
          "Mesh" : 1,
          "PinwheelTile" : 6,
          "Point" : 8,
          "Xform" : 2
        },
        "functions" : {
          "__init__" : 1,
          "_cs_from_base_pts" : 1,
          "_lineage_to_colors" : 1,
          "base_pts" : 1,
          "centroid" : 1,
          "inflate" : 1,
          "to_mesh" : 1
        }
      },
      "start" : 11
    },
    "68765563-72a2-4db3-b8a7-bb390b98769c" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# an alteration of color_pt that operates on HSV", "def hsv_color_pt(hue,sat,val):", "    color = Color.HSB(hue,sat,val)", "    pt = Point(color.r,color.g,color.b)", "    pt.set_color(color)", "    return pt", "", "def val_strip(val):", "    segs = []", "    # for each sat and hue value to sample", "    for sat in Interval().divide(cnt)[1:]:", "        # best to set hue divisions to increments of six", "        for n, hue in enumerate(Interval().divide(12,True)[1:]):", "            # find the start and end points for this segment", "            if n == 0 :  pa = hsv_color_pt(0,sat,val)", "            else: pa = segs[-1].ept", "            pb = hsv_color_pt(hue,sat,val)", "            # ensure that the segment will be valid", "            if pa != pb:", "                seg = Segment(pa,pb)", "                seg.set_color(Color.HSB(hue,sat,val))", "                segs.append(seg)", "    return segs", "", "all_lines = [val_strip(val)for val in Interval().divide(cnt,True)[1:]]" ],
          "end" : 40,
          "start" : 16
        },
        "description" : "\nColor Lines\n",
        "end" : 16,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.04.L01b", "Create a number of Points with a given Interval. Color the Points with a RGB Color corresponding to their XYZ position." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Colors/4.04.L01b.py",
      "name" : "4.04.L01b.py",
      "references" : {
        "classes" : {
          "Color" : 2,
          "Interval" : 3,
          "Point" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "color_point (func) Function to create and assign Color to Points.", "n (int) Number of divisions for the Interval." ],
      "result" : [ "pts ([Point]) List of colored Points." ]
    },
    "68f42b62-bc41-43a7-b632-2cc7f73a2f50" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_raster.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Image constructor.", "        ", "            :param pixel_dim: Resolution of image.", "            :type pixel_dim: Interval or Tuple of two Integers", "            :param initial_color: Start color of image.", "            :type initial_color: Color", "            :param include_corners: Boolean value.", "            :type include_corners: bool", "            :param wrap: Boolean value.", "            :type wrap: bool", "            :result: Image object.", "            :rtype: Image", "            ", "            ", "        \"\"\"", "        super(Image,self).__init__(pixel_dim,**kwargs)", "        self.populate(initial_color)", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Image constructor." ],
          "parameters" : {
            "include_corners" : "Boolean value.\n",
            "initial_color" : "Start color of image.\n",
            "pixel_dim" : "Resolution of image.\n",
            "wrap" : "Boolean value.\n"
          },
          "rtype" : "Image",
          "rvalue" : "Image object.\n",
          "types" : {
            "include_corners" : "bool\n",
            "initial_color" : "Color\n",
            "pixel_dim" : "Interval or Tuple of two Integers\n",
            "wrap" : "bool\n"
          }
        },
        "end" : 187,
        "name" : "__init__",
        "start" : 170
      }, {
        "code" : [ "        \"\"\" Saves image file.", "            ", "            :param filename: Name of the image.", "            :type filename: str", "            :param path: File path to save image to.", "            :type path: bool", "            :param verbose: Boolean value", "            :type verbose: bool", "            :result: Saved image file.", "            :rtype: None", "        ", "        \"\"\"", "        import os, struct, array", "        if path==False : path = os.path.expanduser(\"~\")", "        filename = filename + \".tga\"", "", "        if verbose:", "            print \"saving image to \",os.path.join(path, filename)", "            from time import time", "            t0 = time()", "", "        ## begin tga header fields:", "        ## structure seen at ", "        ## http://gpwiki.org/index.php/TGA, 2009-09-20", "        Offset = 0", "        ColorType = 0", "        ImageType = 2", "        PaletteStart = 0", "        PaletteLen = 0", "        PalBits = 8", "        XOrigin = 0", "        YOrigin = 0", "        Width = int(self.px_width)", "        Height = int(self.px_height)", "        BPP = 24", "        Orientation = 0", "", "        # (c 'short' stays for 16 bit data)", "        StructFmt = \"<BBBHHBHHhhBB\"", "", "        header = struct.pack(StructFmt, Offset, ColorType, ImageType,", "                                        PaletteStart, PaletteLen, PalBits,", "                                        XOrigin, YOrigin, Width, Height,", "                                        BPP, Orientation)", "", "        # Array mdule and format documentation at:  http://docs.python.org/library/array.html", "        data = array.array(\"B\", (255 for i in xrange(self.px_width * self.px_height * 3)))", "", "        for n,clr in enumerate(self._pixels):", "            data[n * 3] = int(clr.b*255)", "            data[n * 3 + 1] = int(clr.g*255)", "            data[n * 3 + 2] = int(clr.r*255)", "", "        if verbose: ", "            t1 = time()", "            print 'packing data took: %f' %(t1-t0)", "", "        if not os.path.exists(path):", "            if verbose : print \"creating folder\",path", "            os.makedirs(path)", "        ", "        datafile = open(os.path.join(path, filename), \"wb\")", "        datafile.write(header)", "        data.write(datafile)", "        datafile.close()", "", "        if verbose: ", "            t2 = time()" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Saves image file." ],
          "parameters" : {
            "filename" : "Name of the image.\n",
            "path" : "File path to save image to.\n",
            "verbose" : "Boolean value\n"
          },
          "rtype" : "None",
          "rvalue" : "Saved image file.\n",
          "types" : {
            "filename" : "str\n",
            "path" : "bool\n",
            "verbose" : "bool\n"
          }
        },
        "end" : 257,
        "name" : "save",
        "start" : 190
      } ],
      "documentation" : {
        "description" : [ "a raster grid of Colors", "each pixel contains a Color with normalized R,G,B values" ]
      },
      "end" : 257,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_raster.py",
      "name" : "Image",
      "references" : {
        "classes" : {
          "BPP" : 2,
          "Color" : 1,
          "ColorType" : 2,
          "Height" : 2,
          "Image" : 2,
          "ImageType" : 2,
          "Offset" : 2,
          "Orientation" : 2,
          "PalBits" : 2,
          "PaletteLen" : 2,
          "PaletteStart" : 2,
          "Raster" : 1,
          "StructFmt" : 2,
          "Width" : 2,
          "XOrigin" : 2,
          "YOrigin" : 2
        },
        "functions" : {
          "__init__" : 1,
          "save" : 1
        }
      },
      "start" : 165
    },
    "691a1853-90e6-422a-8ec5-eebafba78780" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def straight_choice(agent,reverse=False):", "    # find possible directions", "    possibles = agent.possible_directions", "    if len(possibles)==0 : return False", "    ", "    # sort by angle relative to the current trajectory", "    possibles.sort( key = lambda v: v.angle(agent.traj))", "    # if reversing, return the index of the worst direction", "    if reverse: possibles[-1].idx", "    # otherwise, return the index of the best direction", "    return possibles[0].idx", "" ],
          "end" : 30,
          "start" : 18
        },
        "description" : "\nStraight Walking\nA best choice function that returns the next face with a direction closest to the current direction vector.\n",
        "end" : 18,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "def spiral_choice(agent,reverse=False):", "    # find possible directions", "    possibles = agent.possible_directions", "    if len(possibles)==0 : return False", "    ", "    # a vector at a right angle to the direction vector", "    turn_vec = agent.traj.cross(agent.normal)", "    # sort by angle relative to the turn_vec", "    possibles.sort(key = lambda v: v.angle(turn_vec))", "    # if reversing, return the index of the worst direction", "    if reverse: possibles.reverse()", "    # otherwise, return the index of the best direction", "    return possibles[0].idx", "" ],
          "end" : 48,
          "start" : 34
        },
        "description" : "\nSpiral Walking\nA best choice function that returns the next face at a right angle with the current direction vector.\n",
        "end" : 34,
        "start" : 31
      }, {
        "code" : {
          "content" : [ "def random_choice(agent):", "    # find possible directions", "    possibles = agent.possible_directions", "    if len(possibles)==0 : return False", "    # return one at random", "    return random.choice(agent.possible_directions).idx", "" ],
          "end" : 59,
          "start" : 52
        },
        "description" : "\nRandom Walking\nA best choice function that returns a random adjacent face for the walker's next position.\n",
        "end" : 52,
        "start" : 49
      }, {
        "code" : {
          "content" : [ "def attractor_choice(agent, pt=attr):", "    # stop the DirectedWalker if there are no adjacent faces", "    if len(agent.possible_directions)==0 : return False", "    ", "    # get the centroids of all faces adjacent to the current face", "    faces = agent.graph.edges[agent.idx]", "    pts = [[agent.pos_on_graph(i),i] for i in faces]", "    # sort these candidates by their distance to the attractor", "    pts.sort(key = lambda p: p[0].distance2(pt))", "    # stop the DirectedWalker if the current face is the closest", "    if agent.pos.distance2(attr)<= pts[0][0].distance2(attr): return False", "    # otherwise, return the index of the best direction", "    return pts[0][1]", "", "" ],
          "end" : 77,
          "start" : 63
        },
        "description" : "\nAttractor Walking\nA best choice function that returns the next adjacent face closest to a given attractor Point in space.\n",
        "end" : 63,
        "start" : 60
      } ],
      "documentation" : {
        "description" : [ "4.02.F02b", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Fornes/4.02.F02b.py",
      "name" : "4.02.F02b.py",
      "result" : [ "straight(None) Moves the Walker in a straight line on the Mesh", "spiral(None) Moves the Walker in a spiral on the Mesh", "random(None) Moves the Walker randomly on the Mesh", "attract(Point) Moves the Walker towards a given attractor Point in space" ]
    },
    "695a838b-51c7-4c8d-9ed8-e96431dbdf2e" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#nearest neighbors of pt in question; used for discrete approx calcs", "pt_t, pt_plus, pt_minus = nearest_neighbors(crv,t)", "", "#draws the osculating circle and calculates the curvature at t", "v1 = Vec(pt_plus - pt_t)", "v2 = Vec(pt_minus - pt_t)", "v3 = Vec(pt_plus - pt_minus)", "", "rad_osc = 0.5*v1.length*v2.length*v3.length/(v1*v3).length", "denom = 2*(v1.cross(v3).length)*(v1.cross(v3).length)", "a1 = v3.length*v3.length*v1.dot(v2)/denom", "a2 = v2.length*v2.length*v1.dot(v3)/denom", "a3 = v1.length*v1.length*(-v2.dot(v3))/denom", "center_osc = pt_t*a1 + pt_plus*a2 + pt_minus*a3", "", "pln_out = Plane(center_osc, v1.cross(v2))", "circ_out = Circle(pln_out,rad_osc)" ],
          "end" : 34,
          "start" : 17
        },
        "description" : "\nIllustrates the key geometric objects of osculating circle and curvature\n",
        "end" : 17,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "3.07.E03c", "Use of nearest neighbor calculations to draw Oculating Plane/Circle and Curvature" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Geometric Properties/3.07.E03c.py",
      "name" : "3.07.E03c.py",
      "references" : {
        "classes" : {
          "Circle" : 1,
          "Plane" : 1,
          "Vec" : 3
        }
      },
      "required" : [ "t (float) parameter at which to evaluate", "crv (Curve) a curve to evaluate", "nearest_neighbors (function) a function that returns the nearest neighbor points of a given evaluation parameter" ],
      "result" : [ "pt_out (Point) the point at parameter t", "ln_out (Segment) a line segment representing the curve tangent at the given parameter" ]
    },
    "6aedaea7-3736-4c37-9124-f8fb79d330ed" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "#points at the corners of a unit cube", "pts=[\\", "    Point(0,0,0),\\", "    Point(0,1,0),\\", "    Point(1,1,0),\\", "    Point(1,0,0),\\", "    Point(0,0,1),\\", "    Point(0,1,1),\\", "    Point(1,1,1),\\", "    Point(1,0,1),\\", "    ]\\", "    ", "#groups of indices describing quad faces", "faces_q = [[0,1,2,3],[4,5,6,7],[0,4,5,1],[3,7,6,2]]", "mesh_q = Mesh(pts,faces_q)", "", "#groups of indices describing triangular faces", "faces_t=[[0,5,7],[2,5,7],[0,2,5],[0,2,7]]", "mesh_t = Mesh(pts,faces_t)", "", "" ],
          "end" : 36,
          "start" : 15
        },
        "description" : "\nBasic construction of Meshes\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "msh = Mesh(pts)", "msh.add_face(0,7,5)", "msh.add_face(2,5,7)", "msh.add_face(0,2,5)", "msh.add_face(0,2,7)", "" ],
          "end" : 45,
          "start" : 39
        },
        "description" : "\nIncremental Mesh construction \n",
        "end" : 39,
        "start" : 37
      }, {
        "code" : {
          "content" : [ "#points bounding a given face", "pts = msh.face_pts(idx)", "#center of a given face", "cpt = msh.face_centroid(idx)", "#normal direction of a given face", "norm = msh.face_normal(idx)", "", "", "" ],
          "end" : 56,
          "start" : 48
        },
        "description" : "\nProperties of a Mesh\n",
        "end" : 48,
        "start" : 46
      } ],
      "documentation" : {
        "description" : [ "3.08.E00d", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/NOGHX/3.08.E00d.py",
      "name" : "3.08.E00d.py",
      "references" : {
        "classes" : {
          "Mesh" : 3,
          "Point" : 8
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "6b68ab61-9334-4e8d-b75d-1e4d6a22e7da" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_curve.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Constructs a Curve object. If tolerance is None, Curve.tol = tol_max().", "        ", "           :param function: A function returning points.", "           :type function: function", "           :param domain: Domain for curve points.", "           :type domain: Interval", "           :param tolerance: The tolerance of this curve expressed in domain space.", "           :type tolerance: float", "           :result: Curve object.", "           :rtype: Curve", "            ", "           :: ", "           ", "                def func(u):", "                    return Point(math.sin(u),u)", "                Inv=Interval(0,20)", "                crv = Curve(func,Inv)", "        \"\"\"", "        if function is not None : self._func = function", "        self._dom = domain", "        self._tol = self.tol_max", "        if tolerance is not None : self.tol = tolerance", "        if basis is not None : self._basis = basis", "", "        for t in [domain.a,domain.b]:", "            try:", "                pt = self.func(t)", "                pt.x", "                pt.y", "                pt.z", "            except:", "                raise GeometricError(\"Curve not valid: The given function does not return a point or plane at parameter %s\"%(t))", "", "        self._rebuild_surrogate()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Constructs a Curve object. If tolerance is None, Curve.tol = tol_max()." ],
          "parameters" : {
            "domain" : "Domain for curve points.\n",
            "function" : "A function returning points.\n",
            "tolerance" : "The tolerance of this curve expressed in domain space.\n"
          },
          "rtype" : "Curve\n \n",
          "rvalue" : "Curve object.\n",
          "types" : {
            "domain" : "Interval\n",
            "function" : "function\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 178,
        "name" : "__init__",
        "start" : 144
      }, {
        "code" : [ "    def surrogate(self): ", "        \"\"\" Returns a polyline representation of this curve. The number of points in the resulting PLine is related to the tolerance (tol) of this curve.", "        ", "            :result: Polyline of curve.", "            :rtype: PLine", "            ", "            ::", "            ", "                surg=crv.surrogate", "        ", "        \"\"\"", "        return self._surrogate", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a polyline representation of this curve. The number of points in the resulting PLine is related to the tolerance (tol) of this curve." ],
          "rtype" : "PLine\n\n",
          "rvalue" : "Polyline of curve.\n"
        },
        "end" : 193,
        "name" : "surrogate",
        "start" : 181
      }, {
        "code" : [ "    def appx_length(self): ", "        \"\"\"Returns the approximate length of a curve.", "            ", "            :result: Approximate length of a curve.", "            :rtype: float", "            ", "            ::", "            ", "                a_len=crv.appx_length", "        \"\"\"", "        return self._surrogate.length", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the approximate length of a curve." ],
          "rtype" : "float\n\n",
          "rvalue" : "Approximate length of a curve.\n"
        },
        "end" : 206,
        "name" : "appx_length",
        "start" : 195
      }, {
        "code" : [ "    def domain(self): ", "        \"\"\"Returns the Interval domain of a curve.", "        ", "            :result: Domain of a curve.", "            :rtype: Interval", "        \"\"\"", "        return self._dom", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Interval domain of a curve." ],
          "rtype" : "Interval",
          "rvalue" : "Domain of a curve.\n"
        },
        "end" : 215,
        "name" : "domain",
        "start" : 208
      }, {
        "code" : [ "    def tol_max(self):", "        \"\"\"Returns Curve.domain.delta / 10, which is understood to be the maximum tolerance (tol) of this curve.", "        ", "            :result: maximum tolerance", "            :rtype: float", "            ", "        \"\"\"", "        return self._dom.delta / 10.0", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns Curve.domain.delta / 10, which is understood to be the maximum tolerance (tol) of this curve." ],
          "rtype" : "float",
          "rvalue" : "maximum tolerance\n"
        },
        "end" : 225,
        "name" : "tol_max",
        "start" : 217
      }, {
        "code" : [ "    def tol(self): ", "        #TODO: express tolerance as a percentage of domain delta instead... surfaces may have radically different domains in either direction", "        \"\"\"| The tolerance of this Parameterized Object expressed in domain space.", "           | For example, given an interval of 0->1, a tol of 0.1 will result in a curve constructed of 10 segments, evaulated with t-values 0.1 apart", "           | Given an interval 0->PI, a tol of 0.1 will result in a curve constructed of 32 segments, evaluated with t-values less than 0.1 apart", "            ", "           :result: Sets the distance between point of a curve.", "           :rtype: float", "            ", "        \"\"\"", "        return self._tol", "    @tol.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "| The tolerance of this Parameterized Object expressed in domain space.", "| For example, given an interval of 0->1, a tol of 0.1 will result in a curve constructed of 10 segments, evaulated with t-values 0.1 apart", "| Given an interval 0->PI, a tol of 0.1 will result in a curve constructed of 32 segments, evaluated with t-values less than 0.1 apart" ],
          "rtype" : "float\n ",
          "rvalue" : "Sets the distance between point of a curve.\n"
        },
        "end" : 238,
        "name" : "tol",
        "start" : 227
      }, {
        "code" : [ "    def tol(self, tolerance):", "        \"\"\" Sets tolerance of this Curve.", "        ", "            :param tolerance: Distance between a point of a curve.", "            :type tolerance: float", "            :result: Distance between a point of a curve.", "            :rtype: None", "            ", "        \"\"\"", "        ", "        self._tol = tolerance", "        if self._tol > self.tol_max : ", "            self._tol = self.tol_max", "            warnings.warn(\"Curve tolerance too high relative to curve domain - Resetting to max tol.  tolerance (%s) > Curve.max_tol(%s)\"%(tolerance,self.tol_max),stacklevel=4)", "        self._rebuild_surrogate()", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets tolerance of this Curve." ],
          "parameters" : {
            "tolerance" : "Distance between a point of a curve.\n"
          },
          "rtype" : "None",
          "rvalue" : "Distance between a point of a curve.\n",
          "types" : {
            "tolerance" : "float\n"
          }
        },
        "end" : 254,
        "name" : "tol",
        "start" : 239
      }, {
        "code" : [ "    def tol_nudge(self):", "        return self.tol/100.0", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 258,
        "name" : "tol_nudge",
        "start" : 256
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a Point.", "           | t is a float value that falls within the defined domain of this Curve.", "", "           :param t: Value to evaluate the curve at.", "           :type t: float", "           :result: Point on the Curve.", "           :rtype: Point", "           ", "           ::", "           ", "                d_pt=curv.deval(0.5)", "", "            ", "        \"\"\"", "        if t<self.domain.a or t>self.domain.b : ", "            t = round(t,7) # this may be due to a rounding problem, try rounding to 7 decimal places", "            if t<self.domain.a or t>self.domain.b : raise DomainError(\"Curve evaluated outside the bounds of its domain: deval(%s) %s\"%(t,self.domain))", "        pt = self.func(t)", "", "        #transform result to curve basis", "        if not self.is_baseless:", "            #pt.basis = self.basis", "            #pt = pt.basis_applied()", "            # TODO: evaluate basis instead... not all bases will have xforms!", "            pt = pt * self.basis.xform", "        ", "        return pt", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a Point.", "| t is a float value that falls within the defined domain of this Curve." ],
          "parameters" : {
            "t" : "Value to evaluate the curve at.\n"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "Point on the Curve.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 287,
        "name" : "deval",
        "start" : 260
      }, {
        "code" : [ "        \"\"\" Calculates the Frenet Frame (vectors aligned with tangent (T), normal (N) and B (TxN) vectors", "            and returns a CS with x-y plane designated as N-B. This is chosen since most elements propogated", "            along a curve are positioned transversally to the curve. ", "        ", "            :param t: Value to evaluate the curve at.", "            :type t: float", "            :result: CS with T as x axis, N as y axis", "            :rtype: CS", "        ", "        \"\"\"", "        pt, vec_pos, vec_neg = self._nudged(t)", "", "        # if given a curve endpoint, nudge vectors a bit so we don't get zero curvature, but leave origin the same", "        if (t-self.tol_nudge <= self.domain.a):", "            nhood = self._nudged(self.tol_nudge)", "            vec_pos = nhood[1]", "            vec_neg = nhood[2]", "        if (t+self.tol_nudge >= self.domain.b):", "            nhood = self._nudged(self.domain.b-self.tol_nudge)", "            vec_pos = nhood[1]", "            vec_neg = nhood[2]", "        vec_T = self.tangent(self.domain.deval(t))", "        k, circ = Curve._curvature_from_vecs(pt,vec_pos,vec_neg, calc_circles = True)", "        center_osc = circ.plane.origin", "        vec_N = Vec(center_osc-pt).normalized()", "        vec_B = vec_T.cross(vec_N)", "        return CS(pt, vec_N, vec_B)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Calculates the Frenet Frame (vectors aligned with tangent (T), normal (N) and B (TxN) vectors", "and returns a CS with x-y plane designated as N-B. This is chosen since most elements propogated", "along a curve are positioned transversally to the curve." ],
          "parameters" : {
            "t" : "Value to evaluate the curve at.\n"
          },
          "rtype" : "CS",
          "rvalue" : "CS with T as x axis, N as y axis\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 317,
        "name" : "deval_cs",
        "start" : 290
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a Plane.", "           | t is a float value that falls within the defined domain of this Curve.", "           |  Tangent vector determined by a nearest neighbor evaluated at a parameter distance Curve.tol/100 away", "", "           :param t: Value to evaluate the curve at.", "           :type t: float", "           :result: Plane on the Curve.", "           :rtype: Plane", "        \"\"\"", "        if t<self.domain.a or t>self.domain.b : ", "            t = round(t,7) # this may be due to a rounding problem, try rounding to 7 decimal places", "            if t<self.domain.a or t>self.domain.b : raise DomainError(\"Curve evaluated outside the bounds of its domain: deval(%s) %s\"%(t,self.domain))", "", "        pt, vec, neg_vec = self._nudged(t)", "        ", "        #transform result to curve basis", "        if not self.is_baseless:", "            #pt.basis = self.basis", "            #pt = pt.basis_applied()", "            # TODO: evaluate basis instead... not all bases will have xforms!", "            pt = pt * self.basis.xform", "            vec = vec * self.basis.xform.strip_translation()", "        ", "        return Plane(pt,vec)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a Plane.", "| t is a float value that falls within the defined domain of this Curve.", "|  Tangent vector determined by a nearest neighbor evaluated at a parameter distance Curve.tol/100 away" ],
          "parameters" : {
            "t" : "Value to evaluate the curve at.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "Plane on the Curve.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 343,
        "name" : "deval_pln",
        "start" : 319
      }, {
        "code" : [ "        \"\"\" Calculates approximate curvature at the given t-value.", "        ", "            :param t: Value to evaluate the curve at.", "            :type t: float", "            :result: (Curvature at t-value, osculating Circle)", "            :rtype: (float, Circle)", "        ", "        \"\"\"", "        pt, vec_pos, vec_neg = self._nudged(t)", "", "        # if given a curve endpoint, nudge vectors a bit so we don't get zero curvature, but leave origin the same", "        if (t-self.tol_nudge <= self.domain.a):", "            nhood = self._nudged(self.tol_nudge)", "            vec_pos = nhood[1]", "            vec_neg = nhood[2]", "        if (t+self.tol_nudge >= self.domain.b):", "            nhood = self._nudged(self.domain.b-self.tol_nudge)", "            vec_pos = nhood[1]", "            vec_neg = nhood[2]", "", "        return Curve._curvature_from_vecs(pt,vec_pos,vec_neg)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Calculates approximate curvature at the given t-value." ],
          "parameters" : {
            "t" : "Value to evaluate the curve at.\n"
          },
          "rtype" : "(float, Circle)",
          "rvalue" : "(Curvature at t-value, osculating Circle)\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 367,
        "name" : "deval_crv",
        "start" : 346
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a Point.", "           | t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "           | Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain)).", "            ", "           :param t: Normalized value between 0 and 1, to evaluate a Curve.", "           :type t: float", "           :result: a Point on the Curve.", "           :rtype: Point", "            ", "        \"\"\"", "        if t<0 or t>1 : raise DomainError(\"eval() must be called with a number between 0->1: eval(%s)\"%t)", "        return self.deval(Interval.remap(t,Interval(),self.domain))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a Point.", "| t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "| Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain))." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1, to evaluate a Curve.\n"
          },
          "rtype" : "Point\n ",
          "rvalue" : "a Point on the Curve.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 381,
        "name" : "eval",
        "start" : 369
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a CS.", "           | t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "           | Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain))", "            ", "           :param t: Normalized value between 0 and 1, to evaluate a curve.", "           :type t: float", "           :result: a CS on the Curve.", "           :rtype: CS", "        \"\"\"", "        ", "        if t<0 or t>1 : raise DomainError(\"eval_cs() must be called with a number between 0->1: eval(%s)\"%t)", "        return self.deval_cs(Interval.remap(t,Interval(),self.domain))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a CS.", "| t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "| Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain))" ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1, to evaluate a curve.\n"
          },
          "rtype" : "CS",
          "rvalue" : "a CS on the Curve.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 395,
        "name" : "eval_cs",
        "start" : 383
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a Plane.", "           | t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "           | Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain))", "            ", "           :param t: Normalized value between 0 and 1, to evaluate a curve.", "           :type t: float", "           :result: a Plane on the Curve.", "           :rtype: Plane", "        \"\"\"", "        ", "        if t<0 or t>1 : raise DomainError(\"eval_pln() must be called with a number between 0->1: eval(%s)\"%t)", "        return self.deval_pln(Interval.remap(t,Interval(),self.domain))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a Plane.", "| t is a normalized float value (0->1) which will be remapped to the domain defined by this Curve.", "| Equivalent to Curve.deval(Interval.remap(t,Interval(),Curve.domain))" ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1, to evaluate a curve.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "a Plane on the Curve.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 409,
        "name" : "eval_pln",
        "start" : 397
      }, {
        "code" : [ "        \"\"\" Returns curvature of this Curve at given t-value.", "        ", "            :param t: Normalized value between 0 and 1, to evaluate a curve.", "            :type t: float", "            :result: (Curvature at t-value, osculating Circle)", "            :rtype: (float, Circle)", "        ", "        \"\"\"", "        if t<0 or t>1 : raise DomainError(\"eval_crv() must be called with a number between 0->1: eval(%s)\"%t)", "        return self.deval_crv(Interval.remap(t,Interval(),self.domain))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns curvature of this Curve at given t-value." ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1, to evaluate a curve.\n"
          },
          "rtype" : "(float, Circle)",
          "rvalue" : "(Curvature at t-value, osculating Circle)\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 421,
        "name" : "eval_crv",
        "start" : 411
      }, {
        "code" : [ "        \"\"\" Returns the tangent Vector to this Curve at given t-value", "        ", "            :param t: Normalized value between 0 and 1, to evaluate a curve.", "            :type t: float", "            :result: Tangent Vector at t-value", "            :rtype: Vec", "        ", "        \"\"\"", "        pln = self.eval_pln(t)", "        return pln.normal        ", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the tangent Vector to this Curve at given t-value" ],
          "parameters" : {
            "t" : "Normalized value between 0 and 1, to evaluate a curve.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "Tangent Vector at t-value\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 433,
        "name" : "tangent",
        "start" : 423
      }, {
        "code" : [ "    def _curvature_from_vecs(pt, vec_pos, vec_neg, calc_circles=False):", "        \"\"\" Returns curvature and osculating circle determined by point and nearest neighbors", "        ", "            :param pt: Point on Curve.", "            :type pt: Point", "            :param vec_pos: First vector for curvature.", "            :type vec_pos: Vec", "            :param vec_neg: Second vector for curvature.", "            :type vec_neg: Vec", "            :param calc_circles: Boolean Value.", "            :type calc_circles: bool", "            :result: (Curvature at point, osculating Circle)", "            :rtype: (float, Circle)", "            ", "            ", "        \"\"\"", "    ", "        pt_plus = pt + vec_pos", "        pt_minus = pt + vec_neg", "        ", "        v1 = vec_pos", "        v2 = vec_neg", "        v3 = Vec(vec_pos - vec_neg)", "        ", "        xl = v1.cross(v3).length", "        if xl == 0 : return 0,Ray(pt,vec_pos)", "        ", "        rad_osc = 0.5*v1.length*v2.length*v3.length/xl", "        if not calc_circles: return 1/rad_osc", "        ", "        denom = 2*xl*xl", "        a1 = v3.length*v3.length*v1.dot(v2)/denom", "        a2 = v2.length*v2.length*v1.dot(v3)/denom", "        a3 = v1.length*v1.length*(-v2.dot(v3))/denom", "        center_osc = pt*a1 + pt_plus*a2 + pt_minus*a3", "        ", "        pln_out = Plane(center_osc, v1.cross(v2))", "        circ_out = Circle(pln_out,rad_osc)", "        return (1/rad_osc, circ_out)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns curvature and osculating circle determined by point and nearest neighbors" ],
          "parameters" : {
            "calc_circles" : "Boolean Value.\n",
            "pt" : "Point on Curve.\n",
            "vec_neg" : "Second vector for curvature.\n",
            "vec_pos" : "First vector for curvature.\n"
          },
          "rtype" : "(float, Circle)",
          "rvalue" : "(Curvature at point, osculating Circle)\n",
          "types" : {
            "calc_circles" : "bool\n",
            "pt" : "Point\n",
            "vec_neg" : "Vec\n",
            "vec_pos" : "Vec\n"
          }
        },
        "end" : 475,
        "name" : "_curvature_from_vecs",
        "start" : 436
      }, {
        "code" : [ "        \"\"\" Returns the nearest neighbors of a point on this Curve at the given t-value. Used for discrete approximations calculations.", "        ", "            :param t: Value to evaluate the curve at.", "            :type t: float", "            :result: Point at t-value, nearest Vec, nearest Vec.", "            :rtype: Point, Vec, Vec", "        \"\"\"", "        ", "        if t<self.domain.a or t>self.domain.b : raise DomainError(\"Curve evaluated outside the bounds of its domain: deval(%s) %s\"%(t,self.domain))", "", "        pt_t = self.func(t)", "        vec_minus = False", "        vec_plus = False", "", "        if (t-self.tol_nudge >= self.domain.a): vec_minus = Vec(pt_t, self.func(t - self.tol_nudge))", "        if (t+self.tol_nudge <= self.domain.b): vec_plus = Vec(pt_t,self.func(t + self.tol_nudge))", "", "        if not vec_plus: vec_plus = vec_minus.inverted()", "        if not vec_minus: vec_minus = vec_plus.inverted()", "", "        return pt_t,vec_plus,vec_minus", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the nearest neighbors of a point on this Curve at the given t-value. Used for discrete approximations calculations." ],
          "parameters" : {
            "t" : "Value to evaluate the curve at.\n"
          },
          "rtype" : "Point, Vec, Vec",
          "rvalue" : "Point at t-value, nearest Vec, nearest Vec.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 499,
        "name" : "_nudged",
        "start" : 478
      }, {
        "code" : [ "        \"\"\"| Divides this Curve into a list of evaluated Planes equally spaced between Curve.domain.a and Curve.domain.b.", "           | If include_last is True (by default), returned list will contain divs+1 Points.", "           | If include_last is False, returned list will not include the point at Curve.domain.b", "        ", "           :param divs: Number of segments to divide this curve into.", "           :type divs: int", "           :param include_last: Boolean Value.", "           :type include_last: bool", "           :returns: List of points ", "           :rtype: [Point]", "           ", "           ::", "           ", "                divs=crv.divide(5)", "        \"\"\"", "        return [self.deval(t) for t in self.domain.divide(divs,include_last)]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Divides this Curve into a list of evaluated Planes equally spaced between Curve.domain.a and Curve.domain.b.", "| If include_last is True (by default), returned list will contain divs+1 Points.", "| If include_last is False, returned list will not include the point at Curve.domain.b" ],
          "parameters" : {
            "divs" : "Number of segments to divide this curve into.\n",
            "include_last" : "Boolean Value.\n"
          },
          "rtype" : "[Point]\n\n",
          "types" : {
            "divs" : "int\n",
            "include_last" : "bool\n"
          }
        },
        "end" : 518,
        "name" : "divide",
        "start" : 502
      }, {
        "code" : [ "        \"\"\"| Divides this Curve into a list of equal size sub-Curves.", "           | Each sub-Curve will adopt the tol of this curve, unless greater than the tol_max of the subcurve.", "        ", "           :param divs: Number of subcurves.", "           :type divs: int", "           :returns: List of sub-Curves. ", "           :rtype: [Curve]", "           ", "        \"\"\"", "        curves = []", "        for subd in self.domain//divs: curves.append(self.subcurve(subd,self.tol/divs))", "        return curves", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Divides this Curve into a list of equal size sub-Curves.", "| Each sub-Curve will adopt the tol of this curve, unless greater than the tol_max of the subcurve." ],
          "parameters" : {
            "divs" : "Number of subcurves.\n"
          },
          "rtype" : "[Curve]",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 532,
        "name" : "subdivide",
        "start" : 520
      }, {
        "code" : [ "        \"\"\" Returns a new Curve which is a copy of this Curve with the given Interval as the domain.", "        ", "           :param domain: New curve with a new given interval.", "           :type domain: Interval", "           :param tol: Tolerance of point on a subcurve.", "           :type tol: float", "           :result: Copy of curve with new domain.", "           :rtype: Curve", "            ", "           ::", "                ", "                sub_curv=crv.subcurve(Interval(5,10))            ", "        \"\"\"", "        if tol is None: tol = self.tol", "        if tol > domain.delta/10.0 : tol = domain.delta/10.0", "        return Curve(self.func,domain,tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new Curve which is a copy of this Curve with the given Interval as the domain." ],
          "parameters" : {
            "domain" : "New curve with a new given interval.\n",
            "tol" : "Tolerance of point on a subcurve.\n"
          },
          "rtype" : "Curve\n \n",
          "rvalue" : "Copy of curve with new domain.\n",
          "types" : {
            "domain" : "Interval\n",
            "tol" : "float\n"
          }
        },
        "end" : 550,
        "name" : "subcurve",
        "start" : 534
      }, {
        "code" : [ "        \"\"\" Calculates curve subdivisions.", "        ", "            :param func_nf: Function to produce a curve.", "            :type func_nf: function", "            :param pt: Point to begin recursion.", "            :type pt: Point", "            :param tolerance: Tolerance for point on a Curve.", "            :type tolerance: float.", "            :param max_recursion: Maximum number of recursions.", "            :type max_recursion: int", "            :param idivs: Number of initial divisions", "            :type idivs: int", "            :result: Curve", "            :rtype: Curve", "            ", "        \"\"\"", "        ", "        def sub(crv,divs):", "            buffer = 1.5 # multiplier for resulting area", "            ni = func_nf(pt,crv/divs) # divide the curve and find the nearest or furthest point (depending on the function that was provided)", "            nd = crv.domain.eval(ni/float(divs)) # find the domain value associated with this point", "            domain = Interval( nd-(buffer*crv.domain.delta/divs), nd+(buffer*crv.domain.delta/divs) ) #  create a new domain that may contain the nearest point", "            if domain.a < crv.domain.a : domain.a = crv.domain.a", "            if domain.b > crv.domain.b : domain.b = crv.domain.b", "            return crv.subcurve(domain),domain.a == crv.domain.a, domain.b == crv.domain.b # return a new curve with this domain", "", "        crv, force_spt, force_ept = sub(self,idivs)", "        n = 1", "        while crv.domain.delta > tolerance : ", "            divs = 8 # number of subsequent divisions to cut the given curve into", "            crv, at_spt, at_ept = sub(crv,divs)", "            force_spt = force_spt and at_spt", "            force_ept = force_ept and at_ept", "            n+=1", "            if n >= max_recursion : break", "", "        t = crv.domain.eval(0.5)", "        if force_spt : t = crv.domain.eval(0.0)", "        if force_ept : t = crv.domain.eval(1.0)", "        return t", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Calculates curve subdivisions." ],
          "parameters" : {
            "func_nf" : "Function to produce a curve.\n",
            "idivs" : "Number of initial divisions\n",
            "max_recursion" : "Maximum number of recursions.\n",
            "pt" : "Point to begin recursion.\n",
            "tolerance" : "Tolerance for point on a Curve.\n"
          },
          "rtype" : "Curve",
          "rvalue" : "Curve\n",
          "types" : {
            "func_nf" : "function\n",
            "idivs" : "int\n",
            "max_recursion" : "int\n",
            "pt" : "Point\n",
            "tolerance" : "float.\n"
          }
        },
        "end" : 592,
        "name" : "_nearfar",
        "start" : 552
      }, {
        "code" : [ "        \"\"\" Creates a PLine from a curve.", "", "            :result: Returns a PLine built from a curve.", "            :rtype: PLine", "        \"\"\"", "        return PLine([self.deval(t) for t in self.domain.divide(int(math.ceil(self.domain.delta/self.tol)),True)])", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Creates a PLine from a curve." ],
          "rtype" : "PLine",
          "rvalue" : "Returns a PLine built from a curve.\n"
        },
        "end" : 601,
        "name" : "_to_pline",
        "start" : 595
      }, {
        "code" : [ "        self._surrogate = self._to_pline()", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 605,
        "name" : "_rebuild_surrogate",
        "start" : 604
      }, {
        "code" : [ "    def circle(ctr=Point(),rad=1.0,ival=Interval.twopi()):", "        \"\"\"| Constructs a Curve object that describes a circle given: a center (Point) and radius (float).", "           | The plane of the circle will always be parallel to the xy-plane.", "        ", "           :param ctr: Center point of the circle.", "           :type ctr: Point", "           :param rad: Radius of the circle.", "           :type rad: float", "           :result: Curve describing a circle.", "           :rtype: Curve", "        \"\"\"", "        def func(t):", "            x = rad*math.cos(t)", "            y = rad*math.sin(t)", "            return Point(x,y)+ctr", "        return Curve(func,ival)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "| Constructs a Curve object that describes a circle given: a center (Point) and radius (float).", "| The plane of the circle will always be parallel to the xy-plane." ],
          "parameters" : {
            "ctr" : "Center point of the circle.\n",
            "rad" : "Radius of the circle.\n"
          },
          "rtype" : "Curve",
          "rvalue" : "Curve describing a circle.\n",
          "types" : {
            "ctr" : "Point\n",
            "rad" : "float\n"
          }
        },
        "end" : 624,
        "name" : "circle",
        "start" : 608
      }, {
        "code" : [ "    def helix(ctr,rad,rise_per_turn=1.0,number_of_turns=3.0):", "        \"\"\"| Constructs a Curve object that describes a helix given: a center (Point), a radius (float), a rise_per_turn (float), and a number_of_turns (float).", "           | The plane of the circle of the helix will always be parallel to the xy-plane.", "            ", "           :param ctr: Center point of the helix.", "           :type ctr: Point", "           :param rad: Radius of the helix.", "           :type rad: float", "           :param rise_per_turn: Amount the helix rises in z per turn.", "           :type rise_per_turn: float", "           :param number_of_turns: Number of turns the helix has.", "           :type number_of_turns: float", "           :result: Helix Curve object.", "           :rtype: Curve", "            ", "        \"\"\"", "        b = rise_per_turn/(math.pi*2)", "        def func(t):", "            x = rad*math.cos(t)", "            y = rad*math.sin(t)", "            z = b*t", "            return Point(x,y,z)+ctr", "        return Curve(func,Interval(0,math.pi*2*number_of_turns))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "| Constructs a Curve object that describes a helix given: a center (Point), a radius (float), a rise_per_turn (float), and a number_of_turns (float).", "| The plane of the circle of the helix will always be parallel to the xy-plane." ],
          "parameters" : {
            "ctr" : "Center point of the helix.\n",
            "number_of_turns" : "Number of turns the helix has.\n",
            "rad" : "Radius of the helix.\n",
            "rise_per_turn" : "Amount the helix rises in z per turn.\n"
          },
          "rtype" : "Curve\n ",
          "rvalue" : "Helix Curve object.\n",
          "types" : {
            "ctr" : "Point\n",
            "number_of_turns" : "float\n",
            "rad" : "float\n",
            "rise_per_turn" : "float\n"
          }
        },
        "end" : 649,
        "name" : "helix",
        "start" : 626
      }, {
        "code" : [ "    def bezier(cpts):", "        \"\"\" Constructs a bezier curve.", "        ", "            :param cpts: List of points the bezier curve is going to be built with.", "            :type cpts: [Point]", "            :result: Bezier curve.", "            :rtype: Curve", "            ", "        \"\"\"", "        if len(cpts) <= 1 : raise GeometricError(\"Curve not valid: A Bezier requires a minimum of two points.  You gave me %s\"%(len(cpts)))", "        def func(t):", "            pts = cpts", "            while len(pts) > 1: pts = [Point.interpolate(pts[n],pts[n+1],t) for n in range(len(pts)-1)]", "            return pts[0]", "", "        return Curve(func)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a bezier curve." ],
          "parameters" : {
            "cpts" : "List of points the bezier curve is going to be built with.\n"
          },
          "rtype" : "Curve",
          "rvalue" : "Bezier curve.\n",
          "types" : {
            "cpts" : "[Point]\n"
          }
        },
        "end" : 667,
        "name" : "bezier",
        "start" : 651
      }, {
        "code" : [ "    def hermite(cpts, tension=0.0, bias = 0.0):", "        \"\"\" Constructs a hermite interpolation curve with tension and bias controls", "            ", "            :param cpts: List of control points to build the curve.", "            :type cpts: [Point]", "            :result: Hermite Curve object.", "            :rtype: Curve", "        \"\"\"", "        if len(cpts) <= 1 : raise GeometricError(\"Curve not valid: A Hermite requires a minimum of two points.  You gave me %s\"%(len(cpts)))", "        # sum distances between control pts and construct intervals", "        ivals = []", "        sum = 0", "        for dist in [pa.dist(pb) for pa,pb in zip(cpts[:-1],cpts[1:])]:", "            ivals.append(Interval(sum,sum+dist))", "            sum += dist", "", "        # add tangent control points", "        cpts.insert( 0, cpts[0]+Vec(cpts[1],cpts[0]) )", "        cpts.append( cpts[-1]+Vec(cpts[-2],cpts[-1]) )", "", "        # a span relates an interval to a set of points", "        spans = {}", "        for n, ival in enumerate(ivals):", "            spans[ival] = [ cpts[n], cpts[n+1], cpts[n+2], cpts[n+3] ]", "        ", "        def func(t):", "            t = t*sum", "            for ival in spans:", "                if t in ival:", "                    # set t to the normalized value for this span", "                    t = ival.deval(t)", "                    # square and cube of t", "                    t2, t3 = t**2, t**3", "                    # the points of the span", "                    p0,p1,p2,p3 = spans[ival]", "                    ", "                    # hermite interpolation", "                    tau = 0.5*(1-tension)*(1+bias)", "                    m0, m1 = (p2-p0)*tau, (p3-p1)*tau", "                    a0 = 2*t3 - 3*t2 + 1", "                    a1 = t3 - 2*t2 + t", "                    a2 = t3 - t2", "                    a3 = -2*t3 + 3*t2", "                    return( p1*a0 + m0*a1 + m1*a2 + p2*a3 )", "                    ", "        return Curve(func)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a hermite interpolation curve with tension and bias controls" ],
          "parameters" : {
            "cpts" : "List of control points to build the curve.\n"
          },
          "rtype" : "Curve",
          "rvalue" : "Hermite Curve object.\n",
          "types" : {
            "cpts" : "[Point]\n"
          }
        },
        "end" : 715,
        "name" : "hermite",
        "start" : 669
      } ],
      "documentation" : {
        "description" : [ "A simple curve class.", "To construct a curve, pass in a function and an [optional] interval that determines a valid range of values.", "The function should expect a single parameter t(float), and return a Point." ]
      },
      "end" : 715,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_curve.py",
      "name" : "Curve",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Circle" : 1,
          "Curve" : 8,
          "HasBasis" : 1,
          "Interval" : 13,
          "IsParametrized" : 1,
          "PLine" : 1,
          "Plane" : 2,
          "Point" : 4,
          "Ray" : 1,
          "Vec" : 6
        },
        "functions" : {
          "__init__" : 1,
          "_curvature_from_vecs" : 1,
          "_nearfar" : 1,
          "_nudged" : 1,
          "_rebuild_surrogate" : 1,
          "_to_pline" : 1,
          "appx_length" : 1,
          "bezier" : 1,
          "circle" : 1,
          "deval" : 1,
          "deval_crv" : 1,
          "deval_cs" : 1,
          "deval_pln" : 1,
          "divide" : 1,
          "domain" : 1,
          "eval" : 1,
          "eval_crv" : 1,
          "eval_cs" : 1,
          "eval_pln" : 1,
          "func" : 4,
          "helix" : 1,
          "hermite" : 1,
          "sub" : 1,
          "subcurve" : 1,
          "subdivide" : 1,
          "surrogate" : 1,
          "tangent" : 1,
          "tol" : 2,
          "tol_max" : 1,
          "tol_nudge" : 1
        }
      },
      "start" : 135
    },
    "6c125650-7cba-468b-8d30-1f561d1e488b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pts = [Point(),Point(0.33,0),Point(0.5,0.25),Point(0.66,0),Point(1,0)]", "pl_a = PLine(pts)", "", "" ],
          "end" : 20,
          "start" : 16
        },
        "description" : "\nThe basic construction of a PLine\n",
        "end" : 16,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "cs = CS.on_xy(0.5,1.5)", "pl_b = PLine(pts,cs)", "", "" ],
          "end" : 27,
          "start" : 23
        },
        "description" : "\nA PLine may defined a 'basis', which is understood as a coordinate system with respect to which all points are defined\n",
        "end" : 23,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "cs = CS()", "#this PLine starts at the world origin", "pl = PLine(pts,cs)", "", "#the PLine is then moved to start at another location", "pl.basis.origin = Point(0.5,0.5)", "", "" ],
          "end" : 38,
          "start" : 30
        },
        "description" : "\nA PLine stores a base coordinate system and a list of 'vertices' (described as vectors) each of which may be accessed and manipulated directly.\n",
        "end" : 30,
        "start" : 28
      }, {
        "code" : {
          "content" : [ "", "#indexing a PLine directly returns a reference to a Vec", "print pl[0] #prints vec[0,0,0]", "#indexing the pts property of a PLine returns a new Point", "print pl.pts[0] #prints pt[0.5,0.5,0.0]", "", "" ],
          "end" : 48,
          "start" : 41
        },
        "description" : "\nThe points of the PLine are a derivative property, calculated by evaluating the basis by the vertices. Manipulating the resulting points do not affect the PLine. \n",
        "end" : 41,
        "start" : 39
      }, {
        "code" : {
          "content" : [ "PHI = 1.6126979252", "def fib_pt(theta):", "    r = PHI**theta", "    return CS().eval_cyl(r,theta)", "", "pl = PLine()", "segs_per_turn = int(turns * 20) # maintains twenty segments per turn", "for theta in Interval(0,math.pi*2*turns).divide(segs_per_turn,True):", "    pl.append(fib_pt(theta))", "" ],
          "end" : 61,
          "start" : 51
        },
        "description" : "\nConstructs a golden spiral as a PLine, given a radius, height, and number of turns\n",
        "end" : 51,
        "start" : 49
      }, {
        "code" : {
          "content" : [ "pl = PLine()", "ival_theta = Interval(0,math.pi*2*turns)", "for theta in ival_theta.divide(segs_per_turn,True):", "    pt = fib_pt(theta) * radius", "    pt.z = height * ival_theta.deval(theta)", "    pl.append(pt)", "    " ],
          "end" : 71,
          "start" : 64
        },
        "description" : "\nConstructs a 3d Golden Spiral (a Golden Helix, perhaps?) as a PLine.\n",
        "end" : 64,
        "start" : 62
      }, {
        "code" : {
          "content" : [ "xf = Xform.mirror(\"world_xz\")", "pl_cw = PLine([p*xf for p in pl.pts])", "pl_join = pl_cw.join(pl)", "" ],
          "end" : 77,
          "start" : 74
        },
        "description" : "\nConstructs a new PLine by mirroring the existing one about the world xz plane, and joining the results\n",
        "end" : 74,
        "start" : 72
      } ],
      "documentation" : {
        "description" : [ "3.08.E00b", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/NOGHX/3.08.E00b.py",
      "name" : "3.08.E00b.py",
      "references" : {
        "classes" : {
          "CS" : 3,
          "Interval" : 2,
          "PHI" : 2,
          "PLine" : 6,
          "Point" : 6,
          "Xform" : 1
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "6c15050a-dca3-4d3b-8d7b-94c4a93767a7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Guy():", "    ", "    def __init__(self, pos_start = Point(0,0), vel_start = Vec(-0.1,0.1)):   ", "        # sets the initial position of the Guy", "        self.pos = pos_start        ", "        # sets the initial velocity vector for the Guy", "        self.vel = vel_start", "        ", "    \"\"\"", "    Step Method", "    Causes the agent to move, using its current velocity, then randomly", "    pick a new velocity", "    [noprint]", "    \"\"\"       ", "    def step(self):        ", "        # update the position of this Guy", "        self.pos += self.vel        ", "        # pick a new 2d velocity vector", "        self.vel = Vec.random(Interval(-1,1),constrain2d = True)        ", "        ", "    \"\"\"", "    Revised Steer Method", "    Provides an interface for influencing the direction of this Guy by adding a given vector to his current velocity. The 'force' of this steering will be limited by a constant value.", "    \"\"\"           ", "    def steer(self, vec):", "        # limit the influence of the given vector", "        vec = vec.limited(0.5)        ", "        # update the velocity of this Guy", "        self.vel += vec        ", "        " ],
          "end" : 46,
          "start" : 17
        },
        "description" : "\nGuy Class\nUpdates the agent class to add a method for steering\n[noprint]\n",
        "end" : 17,
        "start" : 13
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04c.py",
      "name" : "4.02.L04c.py",
      "references" : {
        "classes" : {
          "Guy" : 1,
          "Interval" : 1,
          "Point" : 1,
          "Vec" : 2
        }
      }
    },
    "6cb113ca-3987-4dad-b648-f4ec6bbefc15" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def magnetic_field(pt_in, seg):", "    # create Vecs from the start and end Points of an edge ", "    vec_a = Vec(seg.spt - pt_in)", "    vec_b = Vec(seg.ept - pt_in)", "    # get the lengths of the Vecs", "    mag_a = vec_a.length", "    mag_b = vec_b.length", "    # get the magnetic field values", "    a_cross_b = vec_a.x*vec_b.y - vec_a.y*vec_b.x", "    bottom = mag_a*mag_b*(mag_a*mag_b + vec_a.dot(vec_b))", "    # if the Point is not on the edge: ", "    if (bottom > 0.0):", "        # return a new value", "        return a_cross_b*(mag_a + mag_b)/bottom", "    else: return 0.0", "   " ],
          "end" : 35,
          "start" : 18
        },
        "description" : " \nMagnetic Field Value\nMethod to generate a value from a simulated magnetic field\n",
        "end" : 18,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "", "def func(u,v):", "    x = u", "    y = v", "    # calculate the Z value if the Point is not on an edge", "    if (abs(abs(x) - w) > 0.0) and (abs(abs(y) - h) > 0.0):", "        this_magnetic_field = 0", "        # for every index in the rectangle vertices:", "        for i in range(len(rec.pts)-1):", "            # get an edge", "            seg = rec.edges[i]", "            # calculate the magnetic field of a given point", "            this_magnetic_field  += magnetic_field(Point(x,y), seg)", "        # assign a X value to a Point based on magnetic field", "        z = 2.0/this_magnetic_field", "    # if the Point is on the edge: its Z value is zero", "    else: z = 0", "    return Point(x,y,z)", "", "", "# Set the values for the rectangle", "w = 0.5*rec_w", "h = 0.5*rec_h", "# create a rectangle PGon with the Points", "rec = PGon([Point(w,h), Point(-w,h), Point(-w,-h), Point(w,-h)])", "", "# create a Surface with a given function", "srf = Surface(func, Interval(-w,w), Interval(-h, h), tol_u = 0.08, tol_v = 0.08)", "" ],
          "end" : 67,
          "start" : 39
        },
        "description" : " \nMagnetic Field Surface\nMethod to create a Surface given a magnetic field function\n",
        "end" : 39,
        "start" : 36
      } ],
      "documentation" : {
        "description" : [ "4.07.F02b", "Given a width and a length, generate a Surface resulting from a magnetic field function." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Williams Biot-Savart/4.07.F02b.py",
      "name" : "4.07.F02b.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "PGon" : 1,
          "Point" : 6,
          "Surface" : 1,
          "Vec" : 2
        }
      },
      "required" : [ "rec_w (float) Rectangle width.", "rec_l (float) Rectangle length." ],
      "result" : [ "surface (Surface) Surface created with the magnetic field function." ]
    },
    "6d535c7b-783c-47aa-97d2-46751b240411" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# get the centroid and vertices of the top PGon", "cen = Point.centroid(pgon_top.pts)", "pts_top = pgon_top.pts", "", "# displace the top PGon, and get its vertices ", "pts_mid = [edge.eval(0.5) - Vec(0,0,cen.z*.5) for edge in pgon_top.edges]", "# create a rotation transformation matrix", "xf = Xform.rotation(center= Point.centroid(pts_mid), angle=rot_mid)", "pts_mid = [pt * xf for pt in pts_mid]", "# get the step size for the domain ", "step = math.pi/(len(pgon_top.edges)-1)", "", "# create the transformation matrix based on a sine ", "xs_list = []", "for i in Interval.pi().divide(step):", "    xs_list.append(Xform.scale(math.sin(i)*amp, Point.centroid(pts_mid)))", "new_pts_mid = []", "for i, pt in enumerate(pts_mid):", "    new_pts_mid.append(pt * xs_list[i])", "", "# displace the top PGon, and get its vertices ", "pts_btm = [pt - Vec(0,0,cen.z) for pt in pts_top]", "# create a scaling transformation matrix", "xf2 = Xform.scale(1.25, Point.centroid(pts_btm))", "new_pts_btm = [pt * xf2 for pt in pts_btm]", "", "# create a Mesh with the 3 lists of Points", "column = mesh_pgons(pts_top, new_pts_mid, new_pts_btm)", "" ],
          "end" : 49,
          "start" : 20
        },
        "description" : "\nMesh Column\nUsing a given PGon, produce three sets of points at the bottom, mid, and top of a column. Leaving the top and bottom sets of points as they are, modify the middle set using a rotational transformation.\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.04.L04b", "Given a rotation and scaling values, transform the mesh. The transformations will be planar." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Columns/4.04.L04b.py",
      "name" : "4.04.L04b.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 4,
          "Vec" : 2,
          "Xform" : 3
        }
      },
      "required" : [ "rot_mid(int) Rotation in radians.", "f_mid (float) Scaling factor." ],
      "result" : [ "pts_top ([Point]) Vertices of the geometries.", "pts_mid ([Point]) Vertices of the geometries.", "pts_btm ([Point]) Vertices of the geometries.", "column (Mesh) Resulting Mesh" ]
    },
    "6fa59137-b953-458d-8954-9ebf32b78052" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_has_pts.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" A constructor for a list of vertices with a shared basis.", "        ", "            :param vertices: A list of Vecs.", "            :type vertices: [Vec]", "            :param basis: A basis", "            :type basis: Basis", "            :result: HasPts object", "            :rtype: HasPts", "        ", "        \"\"\"", "        self._verts = [] # a list of vecs that represent the local coordinates of this object's points", "        if vertices is not None: self._append(vertices)", "        self._basis = basis # set the basis after appending the points", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "A constructor for a list of vertices with a shared basis." ],
          "parameters" : {
            "basis" : "A basis\n",
            "vertices" : "A list of Vecs.\n"
          },
          "rtype" : "HasPts",
          "rvalue" : "HasPts object\n",
          "types" : {
            "basis" : "Basis\n",
            "vertices" : "[Vec]\n"
          }
        },
        "end" : 28,
        "name" : "__init__",
        "start" : 15
      }, {
        "code" : [ "        \"\"\" Returns item in this HasPts at given index.", "        ", "            :param slice: Given index.", "            :type slice: int", "            :result: Vec", "            :rtype: Vec", "        ", "        \"\"\"", "        sliced = self._verts[slice] # may return a singleton or list", "        return sliced", "        try:", "            #TODO: move slice indexing to subclasses and return object rather than point list", "            return [Point(self._basis.eval(vec)) for vec in sliced]", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns item in this HasPts at given index." ],
          "parameters" : {
            "slice" : "Given index.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "Vec\n",
          "types" : {
            "slice" : "int\n"
          }
        },
        "end" : 44,
        "name" : "__getitem__",
        "start" : 31
      }, {
        "code" : [ "        \"\"\" Replaces vertices at given index with the given vertices.", "        ", "            :param index: Index to replace.", "            :type index: int", "            :param other: New vertices.", "            :type other: Vec", "            :result: None", "            :rtype: None", "           ", "        \"\"\"", "    ", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        try:", "            self._verts[index] = self._compatible_vec(other)", "        except:", "                raise TypeError(\"You cannot set the vertices of this object using slicing syntax\")", "        self._vertices_changed() # call to trigger subclass handling of vertex manipulation", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Replaces vertices at given index with the given vertices." ],
          "parameters" : {
            "index" : "Index to replace.\n",
            "other" : "New vertices.\n"
          },
          "rtype" : "None",
          "rvalue" : "None\n",
          "types" : {
            "index" : "int\n",
            "other" : "Vec\n"
          }
        },
        "end" : 65,
        "name" : "__setitem__",
        "start" : 48
      }, {
        "code" : [ "    def basis(self):", "        \"\"\" Returns basis.", "            ", "            :result: Basis", "            :rtype Basis", "        ", "        \"\"\"", "        warnings.warn(\"Altering the properties of the basis of a HasPts object will not automatically update the HasPts.pts. If you want to mess around with any properties of this HasPts object's basis, be sure to call HasPts._unset_attr() after doing so.\")", "        return self._basis", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns basis." ],
          "rvalue" : "Basis\n"
        },
        "end" : 76,
        "name" : "basis",
        "start" : 67
      }, {
        "code" : [ "    def basis(self, basis): ", "        \"\"\" Sets basis.", "        ", "            :param basis: New Basis.", "            :type basis: Basis.", "            :result: None", "            :rtype: None", "            ", "        \"\"\"", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        self._basis = basis", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets basis." ],
          "parameters" : {
            "basis" : "New Basis.\n"
          },
          "rtype" : "None",
          "rvalue" : "None\n",
          "types" : {
            "basis" : "Basis.\n"
          }
        },
        "end" : 89,
        "name" : "basis",
        "start" : 78
      }, {
        "code" : [ "        \"\"\" Returns the length of the list of vertices.", "        ", "            :result: Length of list.", "            :rtype: int", "        \"\"\"", "        return len(self._verts)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the length of the list of vertices." ],
          "rtype" : "int",
          "rvalue" : "Length of list.\n"
        },
        "end" : 97,
        "name" : "__len__",
        "start" : 91
      }, {
        "code" : [ "        \"\"\" Overloads the addition **(+)** operator. Adds the given vector to each vertex in this Geometry", "        ", "            :param vec: Vec to be added.", "            :type vec: Vec", "            :result: None", "            :rtype: None", "        \"\"\"", "        self._unset_attr()  # call this when any of storable properties (subclass_attr or class_attr) changes", "        for v in self._verts: v = v + vec", "        self._vertices_changed() # call to trigger subclass handling of vertex manipulation", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the addition **(+)** operator. Adds the given vector to each vertex in this Geometry" ],
          "parameters" : {
            "vec" : "Vec to be added.\n"
          },
          "rtype" : "None",
          "rvalue" : "None\n",
          "types" : {
            "vec" : "Vec\n"
          }
        },
        "end" : 111,
        "name" : "__add__",
        "start" : 101
      }, {
        "code" : [ "        \"\"\"| Overloads the multiplication **(*)** operator. ", "           | If given a scalar, multiplies each vertex in this Geometry by the given scalar.", "           | If given an Xform, applies the given transformation to each vertex of this Geometry.", "        ", "           :param vec: Object to be multiplied.", "           :type vec: Vec or Xform", "           :result: New Vec.", "           :rtype: Vec", "        \"\"\"  ", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        from .dc_xform import Xform", "        if isinstance(other, Xform) : return other * self", "        else : " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the multiplication **(*)** operator.", "| If given a scalar, multiplies each vertex in this Geometry by the given scalar.", "| If given an Xform, applies the given transformation to each vertex of this Geometry." ],
          "parameters" : {
            "vec" : "Object to be multiplied.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "New Vec.\n",
          "types" : {
            "vec" : "Vec or Xform\n"
          }
        },
        "end" : 125,
        "name" : "__mul__",
        "start" : 113
      }, {
        "code" : [ "    def pts(self): ", "        \"\"\"| Returns a copy of the vertices contained within this HasPts as Points.", "           | Does not allow manipulation.", "           | If you want to manipulate the vertices of this object, you should operate on the vertices directly (which are defined relative to this HasPts's basis) by calling HasPts[0].x = value", "", "           :result: Point or list of points.", "           :rtype: Point or [Point]", "        \"\"\"", "        try:", "            return copy.copy(self._pts)", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "| Returns a copy of the vertices contained within this HasPts as Points.", "| Does not allow manipulation.", "| If you want to manipulate the vertices of this object, you should operate on the vertices directly (which are defined relative to this HasPts's basis) by calling HasPts[0].x = value" ],
          "rtype" : "Point or [Point]",
          "rvalue" : "Point or list of points.\n"
        },
        "end" : 140,
        "name" : "pts",
        "start" : 130
      }, {
        "code" : [ "        self._append(pts)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 149,
        "name" : "append",
        "start" : 148
      }, {
        "code" : [ "        self._unset_attr()", "        try : ", "            for p in pts : self._verts.append(self._compatible_vec(p))", "        except : ", "            self._verts.append(self._compatible_vec(pts))", "        self._vertices_changed() # call to trigger subclass handling of vertex manipulation", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 157,
        "name" : "_append",
        "start" : 151
      }, {
        "code" : [ "        \"\"\"Clears this Geometry of all the Points contained within it.\"\"\"", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        del self._verts[:]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Clears this Geometry of all the Points contained within it." ]
        },
        "end" : 162,
        "name" : "clear",
        "start" : 159
      }, {
        "code" : [ "    def centroid(self):", "        \"\"\" Returns the centroid of the points of this object.", "        ", "            :returns: Centroid (point).", "            :rtype: Point", "        \"\"\"", "        try:", "            return self._centroid", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the centroid of the points of this object.", ":returns: Centroid (point)." ],
          "rtype" : "Point"
        },
        "end" : 172,
        "name" : "centroid",
        "start" : 164
      }, {
        "code" : [ "        \"\"\" Reverses storable properties depending on class or subclass attribute changes.", "        ", "            :result: HasPts object", "            :rtype: HasPts", "            ", "        \"\"\"", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        self._verts.reverse()", "        return self", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Reverses storable properties depending on class or subclass attribute changes." ],
          "rtype" : "HasPts",
          "rvalue" : "HasPts object\n"
        },
        "end" : 187,
        "name" : "reverse",
        "start" : 178
      }, {
        "code" : [ "        \"\"\"| Rotates the vertices in this object.", "           | In the case of a PGon, this resets which point is the first point.", "           ", "           :param n: Number of steps to rotate.", "           :type n: int", "           :result: HasPts object", "           :rtype: HasPts", "                ", "        \"\"\"", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        if n > len(self._verts): n =  n%len(self._verts)", "        if n < -len(self._verts): n =  -abs(n)%len(self._verts)", "        self._verts = self._verts[n:] + self._verts[:n]", "        return self", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Rotates the vertices in this object.", "| In the case of a PGon, this resets which point is the first point." ],
          "parameters" : {
            "n" : "Number of steps to rotate.\n"
          },
          "rtype" : "HasPts\n     ",
          "rvalue" : "HasPts object\n",
          "types" : {
            "n" : "int\n"
          }
        },
        "end" : 203,
        "name" : "rotate",
        "start" : 189
      }, {
        "code" : [ "        \"\"\" Returns a new Geometry with basis applied. Coordinates will be interpreted in world space, appearing in the same position when drawn.", "        ", "            :result: Object with basis applied.", "            :rtype: Object", "        \"\"\"", "        # TODO: copy properties over", "        clone = copy.copy(self)", "        clone._verts = [Vec(pt) for pt in self.pts]", "        clone.basis = None", "        clone._unset_attr()  # call this when any of storable properties (subclass_attr or class_attr) changes", "        return clone", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new Geometry with basis applied. Coordinates will be interpreted in world space, appearing in the same position when drawn." ],
          "rtype" : "Object",
          "rvalue" : "Object with basis applied.\n"
        },
        "end" : 216,
        "name" : "basis_applied",
        "start" : 205
      }, {
        "code" : [ "        \"\"\" Returns a new Geometry stripped of any bases. Coordinates will be interpreted in world space, in their analogous \"local\" position when drawn.", "        ", "            :result: Object with basis stripped.", "            :rtype: Object", "        \"\"\"", "        # TODO: copy properties over", "        clone = copy.copy(self)", "        clone.basis = None", "        clone._unset_attr()  # call this when any of storable properties (subclass_attr or class_attr) changes", "        return clone", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new Geometry stripped of any bases. Coordinates will be interpreted in world space, in their analogous \"local\" position when drawn." ],
          "rtype" : "Object",
          "rvalue" : "Object with basis stripped.\n"
        },
        "end" : 228,
        "name" : "basis_stripped",
        "start" : 218
      }, {
        "code" : [ "        \"\"\" Returns a vector compatible with the collection of vectors in this object if possible.", "        ", "            :param other: Vect to make compatible.", "            :type other: Vec", "            :result: New Vec.", "            :rtype: Vec", "            ", "        \"\"\"", "        if self.is_baseless: ", "            # if this object is baseless, attempt to use the world coordinates of the other", "            return Vec(other) ", "        if isinstance(other, Point): ", "            # if this object is based and the other is a Point, devaluate by this object's basis", "            return Vec(self._basis.deval(other))", "            ", "        try:", "            # Vecs (and anything else from which we can read x,y,z values) are interpreted in local coordinates", "            return Vec(other.x,other.y,other.z)", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a vector compatible with the collection of vectors in this object if possible." ],
          "parameters" : {
            "other" : "Vect to make compatible.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "New Vec.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 249,
        "name" : "_compatible_vec",
        "start" : 231
      }, {
        "code" : [ "        \"\"\" Deletes class and sublcass attributes when possible.", "        ", "            :result: None", "            :rtype: None", "        \"\"\"", "        try: ", "            del self._pts", "        except:", "            pass", "            ", "        for attr in self.class_attr : ", "            try: delattr(self, attr)", "            except:", "                #print \"can't unset \",attr", "                pass", "        if hasattr(self, 'subclass_attr'):", "            for attr in self.subclass_attr : " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Deletes class and sublcass attributes when possible." ],
          "rtype" : "None",
          "rvalue" : "None\n"
        },
        "end" : 270,
        "name" : "_unset_attr",
        "start" : 254
      }, {
        "code" : [ "        pass" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 278,
        "name" : "_vertices_changed",
        "start" : 277
      } ],
      "documentation" : {
        "description" : [ "| A base class for anything that contains a list of vertices.", "| All HasPts classes also have bases." ]
      },
      "end" : 278,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_has_pts.py",
      "name" : "HasPts",
      "references" : {
        "classes" : {
          "HasBasis" : 1,
          "HasPts" : 1,
          "Point" : 5,
          "Vec" : 4,
          "Xform" : 1
        },
        "functions" : {
          "__add__" : 1,
          "__getitem__" : 1,
          "__init__" : 1,
          "__len__" : 1,
          "__mul__" : 1,
          "__setitem__" : 1,
          "_append" : 1,
          "_compatible_vec" : 1,
          "_unset_attr" : 1,
          "_vertices_changed" : 1,
          "append" : 1,
          "basis" : 2,
          "basis_applied" : 1,
          "basis_stripped" : 1,
          "centroid" : 1,
          "clear" : 1,
          "pts" : 1,
          "reverse" : 1,
          "rotate" : 1
        }
      },
      "start" : 7
    },
    "70451a57-0efb-47dc-bf50-bd297b66dbb0" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "    ", "def func(u,v):", "\t# define the smoothness of the rotated curve", "    steps = 20 ", "    height = 20 ", "    pts = []", "    # for each subdivision of the Interval", "    for n in Interval().divide(steps, True):", "        # assign a height", "        z = n*height ", "        # assign a rotation angle  ", "        theta = 2*pi*(n+u)", "        # assign a radius to a Point as factors of u", "        rad = sin(pi*n+sine)+radius", "        # evaluate the Point on the CylCS", "        pt = CylCS().eval(rad, theta, z)", "        pts.append(pt)", "    # create a PLine, and evaluate that PLine at v", "    pt_out = PLine(pts).eval(v)", "    return pt_out", "", "srf = Surface(func, tol_u = 0.05, tol_v = 0.05)", "srf.surrogate" ],
          "end" : 38,
          "start" : 16
        },
        "description" : "\nA Gherkin-Like Surface\nA method for creating surfaces based on constructing and evaluating helices.  \n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.03.L01a", "Given a base curve evaluate a helix and construct a Gherkin shaped surface." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Bespoke Parameterizations/4.03.L01a.py",
      "name" : "4.03.L01a.py",
      "references" : {
        "classes" : {
          "CylCS" : 1,
          "Interval" : 1,
          "PLine" : 1,
          "Surface" : 1
        }
      },
      "required" : [ "radius (float) A number that affects the helix sine Curve radius.", "sine (float) A number that affects the helix sine Curve offset." ],
      "result" : [ "ret (Mesh) A gherkin shaped Mesh." ]
    },
    "72c5087e-7e0e-41ef-ac85-df10a815a8da" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 13,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "DomainError",
      "references" : {
        "classes" : {
          "DomainError" : 1,
          "GeometricError" : 1
        }
      },
      "start" : 13
    },
    "72d39dd0-9532-4804-94d6-92d9fcfd426d" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_circle.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Circle constructor.", "        ", "            :param plane: Plane the Circle is centered on.", "            :type plane: Plane", "            :param radius: Radius of the circle.", "            :type radius: float", "            :result: Circle object.", "            :rtype: Circle", "            ", "            ", "        \"\"\"", "        self.x = plane.x", "        self.y = plane.y", "        self.z = plane.z", "        self._vec = plane._vec", "        self.rad = radius", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Circle constructor." ],
          "parameters" : {
            "plane" : "Plane the Circle is centered on.\n",
            "radius" : "Radius of the circle.\n"
          },
          "rtype" : "Circle",
          "rvalue" : "Circle object.\n",
          "types" : {
            "plane" : "Plane\n",
            "radius" : "float\n"
          }
        },
        "end" : 30,
        "name" : "__init__",
        "start" : 14
      }, {
        "code" : [ "    def plane(self):", "        \"\"\" Returns the plane this circles lies on.", "            ", "            :result: Plane.", "            :rtype: Plane", "        \"\"\"", "        return Plane(Point(self.x,self.y,self.z),self._vec)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the plane this circles lies on." ],
          "rtype" : "Plane",
          "rvalue" : "Plane.\n"
        },
        "end" : 39,
        "name" : "plane",
        "start" : 32
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 42,
        "name" : "__repr__",
        "start" : 42
      }, {
        "code" : [ "        \"\"\" Returns intersections with another circle.", "        ", "            :param other: Other circle to intersect.", "            :type other: Circle", "            :result: Boolean value.", "            :rtype: bool", "            ", "            .. warning:: Please use Intersector() instead.", "        \"\"\"", "        warnings.warn(\"circle.intersections depreciated. please Intersector() instead\")", "        xsec = Intersector()", "        if xsec.of(self,other):", "            return xsec._geom", "        return False", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns intersections with another circle." ],
          "parameters" : {
            "other" : "Other circle to intersect.\n"
          },
          "rtype" : "bool\n\n.. warning",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "other" : "Circle\n"
          }
        },
        "end" : 58,
        "name" : "intersections",
        "start" : 44
      }, {
        "code" : [ "    def mutually_tangent(cir_a,cir_b,tangent_offset=0.0,calc_extras=False):", "        \"\"\"| given two circles, returns a circle that is tangent to both of them.", "           | by default, returns the smallest possible circle (where the points of tangency on each given circle lies along a single line), ", "           | however, if the tan_offset parameter is set to a value other than zero, then the point of tangency may be explicitly set as a rotation from this smallest tangency point", "           | the two given circles must be co-planar", "           | calc_extras = True returns the points of tangency as well", "           ", "           :param cir_a: First Circle.", "           :type cir_a: Circle.", "           :param cir_b: Second Circle.", "           :type cir_b: Circle", "           :param tangent_offset: Rotation from the smallest tangency point.", "           :type tangent_offset: float", "           :param calc_extras: Boolean Value.", "           :type calc_extras: bool", "           :result: Mutually tangent Circle.", "           :rtype: Circle", "           ", "        \"\"\"", "        if not cir_a.plane.is_coplanar(cir_b.plane):", "            raise GeometricError(\"Circles must be co-planar.\")  ", "        z_axis = cir_a.plane.normal", "", "        vec_rad = Vec(cir_a.origin,cir_b.origin).normalized(cir_a.rad)", "        pt_tan = cir_a.origin + vec_rad", "        if tangent_offset != 0.0:", "            cs = CS(cir_a.origin,vec_rad,vec_rad.cross(z_axis))", "            pt_tan = cs.eval(cir_a.rad * math.cos(tangent_offset),cir_a.rad * math.sin(tangent_offset))", "", "        pt_ff = pt_tan + Vec(pt_tan,cir_a.origin).normalized(cir_b.rad)", "        ln_f = Line(pt_ff,Vec(pt_ff,pt_tan))", "", "        pt_gg = Point.centroid([pt_ff,cir_b.plane.origin])", "        ln_g = Line(pt_gg , Vec(pt_ff,cir_b.plane.origin).cross(z_axis))", "", "        from .dc_intersection import Intersector ", "        xsec = Intersector()", "        if xsec.of(ln_g,ln_f):", "            rad = xsec[0].distance(pt_tan)" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "| given two circles, returns a circle that is tangent to both of them.", "| by default, returns the smallest possible circle (where the points of tangency on each given circle lies along a single line),", "| however, if the tan_offset parameter is set to a value other than zero, then the point of tangency may be explicitly set as a rotation from this smallest tangency point", "| the two given circles must be co-planar", "| calc_extras = True returns the points of tangency as well" ],
          "parameters" : {
            "calc_extras" : "Boolean Value.\n",
            "cir_a" : "First Circle.\n",
            "cir_b" : "Second Circle.\n",
            "tangent_offset" : "Rotation from the smallest tangency point.\n"
          },
          "rtype" : "Circle",
          "rvalue" : "Mutually tangent Circle.\n",
          "types" : {
            "calc_extras" : "bool\n",
            "cir_a" : "Circle.\n",
            "cir_b" : "Circle\n",
            "tangent_offset" : "float\n"
          }
        },
        "end" : 98,
        "name" : "mutually_tangent",
        "start" : 60
      }, {
        "code" : [ "    def thru_pts(start_pt, mid_pt, end_pt):", "        \"\"\" Returns an Circle that goes through a startpoint, midpoint and endpoint", "                ", "            :param start_pt: First Point on Circle", "            :type start_pt: Point", "            :param mid_pt: Second Point on Circle.", "            :type mid_pt: Point", "            :param end_pt: Third Point on Circle", "            :type end_pt: Point", "            :result: circ_out", "            :rtype: Circle", "            ", "        \"\"\"", "        v1 = Vec(end_pt - mid_pt)", "        v2 = Vec(start_pt - mid_pt)", "        v3 = Vec(end_pt - start_pt)", "        ", "        try:", "            rad_osc = 0.5*v1.length*v2.length*v3.length/(v1*v3).length", "            denom = 2*(v1.cross(v3).length)*(v1.cross(v3).length)", "            a1 = v3.length*v3.length*v1.dot(v2)/denom", "            a2 = v2.length*v2.length*v1.dot(v3)/denom", "            a3 = v1.length*v1.length*(-v2.dot(v3))/denom", "            center_osc = mid_pt*a1 + end_pt*a2 + start_pt*a3", "            ", "            pln_out = Plane(center_osc, v1.cross(v2))", "            circ_out = Circle(pln_out,rad_osc)", "            ", "            return circ_out", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns an Circle that goes through a startpoint, midpoint and endpoint" ],
          "parameters" : {
            "end_pt" : "Third Point on Circle\n",
            "mid_pt" : "Second Point on Circle.\n",
            "start_pt" : "First Point on Circle\n"
          },
          "rtype" : "Circle",
          "rvalue" : "circ_out\n",
          "types" : {
            "end_pt" : "Point\n",
            "mid_pt" : "Point\n",
            "start_pt" : "Point\n"
          }
        },
        "end" : 137,
        "name" : "thru_pts",
        "start" : 108
      } ],
      "documentation" : {
        "description" : [ "a circle class", "inherits all properties of the Plane class" ]
      },
      "end" : 137,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_circle.py",
      "name" : "Circle",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Circle" : 3,
          "Intersector" : 2,
          "Line" : 2,
          "Plane" : 4,
          "Point" : 2,
          "Vec" : 8
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "intersections" : 1,
          "mutually_tangent" : 1,
          "plane" : 1,
          "thru_pts" : 1
        }
      },
      "start" : 8
    },
    "73921ff2-c76c-4ebd-be56-9de73b868e51" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_graph.py",
      "definitions" : [ {
        "code" : [ "        self.nodes = set() # a set is an unordered collection of unique elements", "        self.edges = {}", "        self.weights = {}", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 14,
        "name" : "__init__",
        "start" : 11
      }, {
        "code" : [ "        self.nodes.add(value)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 17,
        "name" : "add_node",
        "start" : 16
      }, {
        "code" : [ "        # make sure these nodes are in our list of nodes", "        if from_node not in self.nodes: self.add_node(from_node)", "        if to_node not in self.nodes: self.add_node(to_node)", "        ", "        # add the edge", "        success = self._add_edge(from_node, to_node, weight)", "        # add the reverse edge", "        if bidirectional:", "            if not from_node == to_node: ", "                success= success and self._add_edge(to_node, from_node, weight)", "        return success", " " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 30,
        "name" : "add_edge",
        "start" : 19
      }, {
        "code" : [ "        self.edges.setdefault(from_node, []) # key might exist already, but if not this instructs our dict to return an empty list for this key.", "        if not to_node in self.edges[from_node]:", "            self.edges[from_node].append(to_node)", "            self.weights[(from_node, to_node)] = weight", "            return True", "        return False", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 38,
        "name" : "_add_edge",
        "start" : 32
      }, {
        "code" : [ "    def node_list(self):", "        return list(self.nodes)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 42,
        "name" : "node_list",
        "start" : 40
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 44,
        "name" : "__repr__",
        "start" : 44
      }, {
        "code" : [ "    def node_pairs(self):", "        ret = []", "        for n1, others in self.edges.iteritems():", "             for n2 in others: ret.append((n1,n2))", "        return tuple(ret)", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 52,
        "name" : "node_pairs",
        "start" : 47
      }, {
        "code" : [ "        # set the current visited nodes and the distance travelled", "        visited = {initial_node: 0}", "        # set the current node as the initial node", "        current_node = initial_node", "        # create an empty dictionary for the path", "        path = {}", "    ", "        # create a set of all the nodes in the graph", "        nodes = set(self.nodes)", "        # while there are still nodes in the set", "        while nodes:", "            # calculate the minimum node", "            min_node = None", "            for node in nodes:", "                if node in visited:", "                    if min_node is None:", "                        min_node = node", "                    elif visited[node] < visited[min_node]:", "                        min_node = node", "            if min_node is None:", "                break", "            # remove the current node from nodes", "            nodes.remove(min_node)", "            # get the distance to the current node", "            cur_wt = visited[min_node]", "            # for every edge connected to the current node:", "            for edge in self.edges[min_node]:", "                # record this edge to visited and path dicts", "                wt = cur_wt + self.weights[(min_node, edge)]", "                if edge not in visited or wt < visited[edge]:", "                    visited[edge] = wt", "                    path[edge] = min_node", "    ", "        return visited, path", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 96,
        "name" : "_calc_dijkstra",
        "start" : 62
      }, {
        "code" : [ "        # set distances and paths to the result of the dijkstra function", "        distances, paths = self._calc_dijkstra(initial_node)", "        # set the route as the goal node", "        route = [goal_node]", "    ", "        # while the goal node is not the same as the initial node", "        while goal_node != initial_node:", "            # add the current goal node to the route", "            route.append(paths[goal_node])", "        ", "            goal_node = paths[goal_node]", "    ", "        # reverse the route list to start from the initial node", "        route.reverse()", "        return route", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 116,
        "name" : "shortest_path",
        "start" : 101
      } ],
      "documentation" : {
        "description" : [ "A directed, weighted graph" ]
      },
      "end" : 116,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_graph.py",
      "name" : "Graph",
      "references" : {
        "classes" : {
          "Graph" : 1
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "_add_edge" : 1,
          "_calc_dijkstra" : 1,
          "add_edge" : 1,
          "add_node" : 1,
          "node_list" : 1,
          "node_pairs" : 1,
          "shortest_path" : 1
        }
      },
      "start" : 7
    },
    "7401387a-0037-4b0d-9bd2-720c35570643" : {
      "code" : [ "    xform = Xform.translation(Point(1,1)) ", "    xform *= Xform.rotation(center=Point(),angle=math.pi/3, axis=Vec(0,1,1))", "    ta = DzTileA(xf=xform,rlvl=0)", "    out_0.put(ta.draw())", "", "    inflt1 = ta.inflate()", "    for tile in inflt1 : ", "        out_1.put(tile.draw())", "        inflt2 = tile.inflate()", "        for tile in inflt2 : out_2.put(tile.draw())", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 342,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "inflationA",
      "start" : 332
    },
    "7631acbc-2f89-4a7b-91a8-72b09e48e1d5" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/classical_surfaces.py",
      "definitions" : [ {
        "code" : [ "        '''", "        the given generator curve will be rotated about an axis through the center and defined by given vector", "        '''", "        self.genx = generator", "        self.center = axis._pt", "        self.axis = axis._vec", "", "        def func(u,v):", "            pt = self.genx.eval(v)", "            xf = Xform.rotation(angle = dom_u.eval(u), center = self.center, axis = self.axis)        ", "            return pt*xf", "", "        try:", "            dom_v = self.genx.domain", "            tol_v = self.genx.tol", "        except:", "            dom_v = Interval()", "            tol_v = 1.0/10.0", "", "        super(RotationalSurface,self).__init__(func,Interval(),Interval(),tol_u,tol_v)", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "the given generator curve will be rotated about an axis through the center and defined by given vector" ]
        },
        "end" : 59,
        "name" : "__init__",
        "start" : 39
      }, {
        "code" : [ "        xf = Xform.rotation(angle=u,axis=self.axis)", "        pln_crv = self.genx.deval_pln(v) * xf", "        axis_pt = Point(self.axis.to_line().near_pt(pln_crv.origin))", "", "        try:", "            pln = Plane(pln_crv.origin, pln_crv.normal.cross(axis_pt).cross(pln_crv.normal))", "            # doesn't work in all situations", "            # if self.axis.angle(axis_pt) < flip_ang_tol : pln.normal = pln.normal.inverted()", "        except:", "            # seems to only happen when evaluated point lies at (0,0), but may happen when evaluated pt lies on axis", "            return super(ClassicalSurface,self).deval_pln(u,v)", "", "        return pln", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 74,
        "name" : "deval_pln",
        "start" : 61
      }, {
        "code" : [ "        # we could re-implement deval_crv here in the context of this classical surface type, or we could pass the buck to our general Surface class", "        return super(ClassicalSurface,self).deval_crv(u,v)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 78,
        "name" : "deval_crv",
        "start" : 76
      }, {
        "code" : [ "        if u_val is None and v_val is None: raise AttributeError(\"Surface.isocurve requires either u_val OR v_val to be set\")", "        if u_val is not None and v_val is not None: raise AttributeError(\"u_val AND v_val cannot both be set when generating a Surface.isocurve\")", "        ", "        # if plotting a u-iso, return an Arc", "        if u_val is None:", "            pt_0 = self.func(0,v_val)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 85,
        "name" : "isocurve",
        "start" : 80
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 85,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/classical_surfaces.py",
      "name" : "RotationalSurface",
      "references" : {
        "classes" : {
          "Arc" : 1,
          "CS" : 1,
          "ClassicalSurface" : 3,
          "Interval" : 4,
          "Plane" : 1,
          "Point" : 2,
          "Ray" : 1,
          "RotationalSurface" : 2,
          "Vec" : 1,
          "Xform" : 4
        },
        "functions" : {
          "__init__" : 1,
          "deval_crv" : 1,
          "deval_pln" : 1,
          "func" : 1,
          "isocurve" : 1
        }
      },
      "start" : 36
    },
    "7666a5b9-75d0-4bc3-95a1-892cc398ecf7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Cell(object):", "    def __init__(self, points, neighbor_side=False, neighbor_bottom=False):", "        # list of Points creating a Cell", "        self.points = points", "        # determine the that cell is on the side", "        self.neighbor_side = neighbor_side", "        # determine whether the cell that is on bottom", "        self.neighbor_bottom = neighbor_bottom", "        # set the height of an apex with mathematical functions", "        self.apex_height = sin(points[0].x)*0.3+sin(points[0].y+1)*0.4+0.05", "    ", "    # method to get the apex Point of a Cell", "    def apex(self, pts):", "        vec = Vec(pts[0],pts[1]).cross(Vec(pts[0], pts[2]))", "        apx = Point.centroid(pts)+vec.normalized(self.apex_height)", "        return apx", "    ", "    # get the neighboring point on the side of a Cell", "    @property", "    def pt_side(self):", "        return self.points[0]", "    ", "    # get the Point on the bottom of a Cell", "    @property", "    def pt_bottom(self):", "        return self.apex([self.points[1], self.points[0], self.points[2]])", "        ", "    \"\"\"", "    Draw Mesh", "    Meshes this Cell, creating apex points and connections to neighbors as needed", "    [pseudo]", "    \"\"\"", "    @property", "    def to_mesh(self):", "        # initialize an empty Mesh", "        msh = Mesh()", "        # compute apex points", "        ap1 = [self.points[3],self.points[0],self.points[2]]", "        ap2 = [self.points[1],self.points[0],self.points[2]]", "        self.points.append(self.apex(ap1))", "        self.points.append(self.apex(ap2))", "        # add both existing and apex points to the mesh", "        msh.append(self.points)", "        # make mesh faces", "        msh.add_face(0,2,4)", "        msh.add_face(2,3,4)", "        msh.add_face(1,2,5)", "        msh.add_face(2,3,5)", "        msh.add_face(0,2,3)", "        ", "        # if this cell has a side neighbor:", "        if self.neighbor_side:", "            self.points.append(self.neighbor_side)", "            # create a mesh face connecting to the neighbor", "            msh.append(self.neighbor_side)", "            msh.add_face(0,4,6)", "        ", "        # if this cell has a bottom neighbor:", "        if self.neighbor_bottom:", "            # create a mesh face connecting to the neighbor", "            self.points.append(self.neighbor_bottom)", "            msh.append(self.neighbor_bottom)", "            # if this Cell has a side neighbor", "            if self.neighbor_side:", "                # create a mesh face connecting bottom and side neighbors", "                msh.add_face(1,5,7)", "            # if this Cell has no side neighbor", "            else: ", "                # create a mesh face capping bottom neighbor", "                msh.add_face(1,5,6)", "        ", "        # return the completed mesh", "        return msh" ],
          "end" : 93,
          "start" : 21
        },
        "description" : "\nCell Component\nConstructs a Cell object. The Cell provides methods for obtaining the apex, and Points on the top and bottom of the Surface.\n",
        "end" : 21,
        "start" : 18
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Encoding Material Behavior/4.05.L05a.py",
      "name" : "4.05.L05a.py",
      "references" : {
        "classes" : {
          "Cell" : 1,
          "Mesh" : 1,
          "Point" : 1,
          "Vec" : 2
        }
      }
    },
    "77e03946-f01c-4da0-9c47-56b04e38eb84" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_raster.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" ValueField constructor.", "        ", "            :param pixel_dim: Resolution of ValueField.", "            :type pixel_dim: Interval", "            :param initial_value: Start value of ValueField.", "            :type initial_value: float", "            :param include_corners: Boolean Value.", "            :type include_corners: bool", "            :param wrap: Boolean Value.", "            :type wrap: bool", "            :result: ValueField Object", "            :rtype: ValueField", "            ", "        \"\"\"", "        if \"wrap\" not in kwargs: kwargs[\"wrap\"] = True", "        super(ValueField,self).__init__(pixel_dim,**kwargs)", "        self.populate(initial_value)", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "ValueField constructor." ],
          "parameters" : {
            "include_corners" : "Boolean Value.\n",
            "initial_value" : "Start value of ValueField.\n",
            "pixel_dim" : "Resolution of ValueField.\n",
            "wrap" : "Boolean Value.\n"
          },
          "rtype" : "ValueField",
          "rvalue" : "ValueField Object\n",
          "types" : {
            "include_corners" : "bool\n",
            "initial_value" : "float\n",
            "pixel_dim" : "Interval\n",
            "wrap" : "bool\n"
          }
        },
        "end" : 285,
        "name" : "__init__",
        "start" : 268
      }, {
        "code" : [ "    def max_value(self):", "        \"\"\" Returns max value of ValueField.", "        ", "            :result: Maximum value.", "            :rtype: float", "        \"\"\"", "    ", "        return max(self._pixels)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns max value of ValueField." ],
          "rtype" : "float",
          "rvalue" : "Maximum value.\n"
        },
        "end" : 296,
        "name" : "max_value",
        "start" : 288
      }, {
        "code" : [ "    def min_value(self):", "        \"\"\" Returns min value of ValueField.", "        ", "            :result: Minimum value.", "            :rtype: float", "        \"\"\"", "        return min(self._pixels)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns min value of ValueField." ],
          "rtype" : "float",
          "rvalue" : "Minimum value.\n"
        },
        "end" : 305,
        "name" : "min_value",
        "start" : 298
      }, {
        "code" : [ "        \"\"\" Constructs image from ValueField.", "        ", "            :param min_color: Minimum color in image.", "            :type min_color: Color", "            :param max_color: Maximum color in image.", "            :type max_color: Color", "            :param value_range: Range of values.", "            :type value_range: Interval", "            :result: Image.", "            :rtype: Image.", "            ", "        \"\"\"", "        from .dc_interval import Interval", "        if value_range is None : value_range = Interval(self.min_value,self.max_value)", "        img = Image(self.dimensions)", "        for n, val in enumerate(self._pixels):", "            try: ", "                t = value_range.deval(val)", "            except :", "                t = 0.0", "            img._pixels[n] = Color.interpolate(min_color,max_color,t)", "        return img", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Constructs image from ValueField." ],
          "parameters" : {
            "max_color" : "Maximum color in image.\n",
            "min_color" : "Minimum color in image.\n",
            "value_range" : "Range of values.\n"
          },
          "rtype" : "Image.",
          "rvalue" : "Image.\n",
          "types" : {
            "max_color" : "Color\n",
            "min_color" : "Color\n",
            "value_range" : "Interval\n"
          }
        },
        "end" : 329,
        "name" : "to_image",
        "start" : 307
      } ],
      "documentation" : {
        "description" : [ "a raster grid of floating point values", "each pixel contains a floating point number" ]
      },
      "end" : 329,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_raster.py",
      "name" : "ValueField",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Image" : 1,
          "Interval" : 1,
          "Raster" : 1,
          "ValueField" : 2
        },
        "functions" : {
          "__init__" : 1,
          "max_value" : 1,
          "min_value" : 1,
          "to_image" : 1
        }
      },
      "start" : 263
    },
    "78f5c5a0-df6f-4cdd-9a31-6efef1779edd" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# Farfalle pasta Surface", "def surf_func (u, v):", "    # define values based on mathematical functions", "    alph = m.sin((7*u+16)/40*m.pi)", "    beta = 7*v/16 + 4*m.sin(u/80*m.pi) * m.sin((v-10)/120*m.pi)", "    gamma = 10*m.cos((u+80)/80*m.pi) * m.sin((v+110)/100*m.pi)**9", "    nu = 7*v/16 - 4*m.sin(u/80*m.pi) - alph * m.sin((10-v)/20*m.pi)", "    ips = 7*v/16 + 4*m.sin(u/80*m.pi) + alph * m.sin((10-v)/20*m.pi)", "    # if U is larger than 20 and smaller than 60: ", "    if 20 <= u <= 60 :", "        # define x", "        x = 3/8 * u + 7 * m.sin((u+40)/40*m.pi)**3 *m.sin((v+110)*m.pi/100)**9", "    # else: assign a different value", "    else : x = 3/8 * u + gamma", "    # if V is smaller than 10: y equals nu", "    if v <= 10: y = nu ", "    # else if V is larger than 10 and smaller than 70:", "    elif  10 <= v <= 70:", "        y = beta - 4*m.sin(u/80*m.pi) * m.sin((70-v)/120*m.pi)", "    # else: assign a different value", "    else: y = ips", "    # assign Z a value", "    z = 3 * m.sin((u+10)*m.pi/20) * m.sin(v/80*m.pi)**1.5", "    # create a Point with X,Y, and Z values", "    return Point(x,y,z)", "    ", "# Gnocci pasta Surface ", "def surf_func (u, v):", "    # define values based on mathematical functions", "    alpha =u/40 * m.sin(v/130*m.pi)", "    beta = abs(m.cos((v+13)/26*m.pi))", "    val1 = u*m.pi*1.3/40", "    x = 0.2*m.cos(val1)*m.sin(v*m.pi/130)*beta+alpha*m.cos(u*1.3*m.pi/40)", "    y = 0.2*m.sin(val1)*m.sin(v*m.pi/130)*beta+alpha*m.sin(u*1.3*m.pi/40)", "    z = 1.5*m.cos(v*m.pi/130)", "    # create a Point with X,Y, and Z values", "    return Point(x,y,z)", "", "# Orecchiette Surface", "def surf_func (u, v):", "    # define values based on mathematical functions", "    x = 2/3*v*cos(u*pi/75) + 0.3*cos(2/15*u*pi)", "    y = 10*sin(u*pi/75)", "    z = 0.1*cos(u*pi/3) + 5 * (cos(v*pi/30)**2) * (0.5 + 0.5*(cos(2*u*pi/75)))**4  + 1.5 * (0.5 + 0.5*cos(2*u*pi/75))**5 * sin(v*pi/30)**10", "    # create a Point with X,Y, and Z values", "    return Point(x,y,z)", "    ", "    " ],
          "end" : 69,
          "start" : 20
        },
        "description" : "\nParametrize Pasta-Like Surfaces \nMethods for creating Farfalle and Gnocci Surfaces with given U and V values (based on the work of George L. Legendre)\n",
        "end" : 20,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "", "d0 = Interval(0,15)", "d1 = Interval(0,80)", "d2 = Interval(0,40)", "d3 = Interval(0,130)", "d4 = Interval(0,150)", "# create a Farfalle pasta Surface", "bowtie = Surface(surf_func, dom_u=d1, dom_v=d1).surrogate", "# create a Gnocci pasta Surface ", "curly = Surface(surf_func, dom_u=d2, dom_v=d3).surrogate", "# create a wavy surface", "wavy = Surface(surf_func, dom_u=d0, dom_v=d4).surrgoate", "", "" ],
          "end" : 86,
          "start" : 73
        },
        "description" : "\nMake Pasta!\nGiven Surface methods, create Pasta shaped Meshes.\n",
        "end" : 73,
        "start" : 70
      } ],
      "documentation" : {
        "description" : [ "3.09.E01d", "Methods to create a series of explicitly designed surfaces based on pasta shapes. Based on the work of George L. Legendre" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Surface Basics/3.09.E01d.py",
      "name" : "3.09.E01d.py",
      "references" : {
        "classes" : {
          "Interval" : 5,
          "Point" : 3,
          "Surface" : 3
        }
      },
      "required" : [ "surf_func (function) Explicit surface function.", "dom_u (Interval) Surface domain in U direction.", "dom_v (Interval) Surface domain in V direction." ],
      "result" : [ "bowtie (Mesh) A Pasta Surface.", "curly (Mesh) A Pasta Surface.", "wavy (Mesh) A Pasta Surface." ]
    },
    "7972c149-8f53-4e6b-a56d-8ca891da62ef" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_interval.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Interval Constructor.", "        ", "            :param a: First number of the interval.", "            :type a: float", "            :param b: Second number of the interval.", "            :type a: float", "            :result: Interval Object.", "            :rtype: Interval", "        \"\"\"", "        self.a = float(a)", "        self.b = float(b)", "    " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Interval Constructor." ],
          "parameters" : {
            "a" : "First number of the interval.\n",
            "b" : "Second number of the interval.\n"
          },
          "rtype" : "Interval",
          "rvalue" : "Interval Object.\n",
          "types" : {
            "a" : "float\n"
          }
        },
        "end" : 21,
        "name" : "__init__",
        "start" : 10
      }, {
        "code" : [ "    def __div__(self, divs): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 23,
        "name" : "__truediv__",
        "start" : 23
      }, {
        "code" : [ "        \"\"\" Overloads the division **(/)** operator. Calls Interval.divide(divs).", "        ", "            :param divs: Number of divisions.", "            :type divs: int", "            :result: List of numbers in which a list is divided. ", "            :rtype: list", "        \"\"\"", "        return self.divide(divs)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the division **(/)** operator. Calls Interval.divide(divs)." ],
          "parameters" : {
            "divs" : "Number of divisions.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of numbers in which a list is divided. \n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 32,
        "name" : "__div__",
        "start" : 24
      }, {
        "code" : [ "        \"\"\" Overloads the integer division **(//)** operator. Calls Interval.subinterval(other).", "            ", "            :param other: Number to subintervals.", "            :type other: int", "            :result: list of subintervals", "            :rtype: list", "            ", "        \"\"\"", "        return self.subinterval(other)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the integer division **(//)** operator. Calls Interval.subinterval(other)." ],
          "parameters" : {
            "other" : "Number to subintervals.\n"
          },
          "rtype" : "list",
          "rvalue" : "list of subintervals\n",
          "types" : {
            "other" : "int\n"
          }
        },
        "end" : 43,
        "name" : "__floordiv__",
        "start" : 34
      }, {
        "code" : [ "        \"\"\" Overloads the addition **(+)** operator.", "            ", "            :param val: Value to add to the interval.", "            :type val: float", "            :result: New interval.", "            :rtype: Interval", "            ", "        \"\"\"    ", "        return Interval(self.a + val, self.b + val)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the addition **(+)** operator." ],
          "parameters" : {
            "val" : "Value to add to the interval.\n"
          },
          "rtype" : "Interval",
          "rvalue" : "New interval.\n",
          "types" : {
            "val" : "float\n"
          }
        },
        "end" : 54,
        "name" : "__add__",
        "start" : 45
      }, {
        "code" : [ "        \"\"\" Overloads the subtraction **(-)** operator.", "", "            :param val: Value to subtract from the interval.", "            :type val: float", "            :result: New interval.", "            :rtype: Interval", "        \"\"\"    ", "        return Interval(self.a - val, self.b - val)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the subtraction **(-)** operator." ],
          "parameters" : {
            "val" : "Value to subtract from the interval.\n"
          },
          "rtype" : "Interval",
          "rvalue" : "New interval.\n",
          "types" : {
            "val" : "float\n"
          }
        },
        "end" : 64,
        "name" : "__sub__",
        "start" : 56
      }, {
        "code" : [ "        \"\"\" Overloads the containment **(in)** operator", "        ", "            :param number: Number whose containment must be determined.", "            :type number: float", "            :result: Boolean result of containment.", "            :rtype: bool", "            ", "        \"\"\"", "        ival = self.order()", "        return (ival.a <= number) and (ival.b >= number)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the containment **(in)** operator" ],
          "parameters" : {
            "number" : "Number whose containment must be determined.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of containment.\n",
          "types" : {
            "number" : "float\n"
          }
        },
        "end" : 76,
        "name" : "__contains__",
        "start" : 66
      }, {
        "code" : [ "        \"\"\" Overloads the equal **(==)** operator.", "        ", "            :param other: Interval to be compared.", "            :type other: Interval", "            :result: Boolean result of comparison", "            :rtype: bool", "        \"\"\"", "        return all([self.a==other.a,self.b==other.b])", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the equal **(==)** operator." ],
          "parameters" : {
            "other" : "Interval to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison\n",
          "types" : {
            "other" : "Interval\n"
          }
        },
        "end" : 86,
        "name" : "__eq__",
        "start" : 78
      }, {
        "code" : [ "        return hash( (self.a, self.b) )", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 89,
        "name" : "__hash__",
        "start" : 88
      }, {
        "code" : [ "    def list(self): ", "        \"\"\" Returns a list of the interval's start and end values.", "        ", "            :result: List of interval's components", "            :rtype: list", "        \"\"\"", "        return [self.a, self.b]", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a list of the interval's start and end values." ],
          "rtype" : "list",
          "rvalue" : "List of interval's components\n"
        },
        "end" : 99,
        "name" : "list",
        "start" : 92
      }, {
        "code" : [ "    def is_ordered(self): ", "        \"\"\" Returns True if the start value of the interval is smaller than the end value.", "        ", "            :result: Boolean value", "            :rtype: bool", "        \"\"\"", "        return True if self.a < self.b else False", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns True if the start value of the interval is smaller than the end value." ],
          "rtype" : "bool",
          "rvalue" : "Boolean value\n"
        },
        "end" : 108,
        "name" : "is_ordered",
        "start" : 101
      }, {
        "code" : [ "    def length(self):", "        \"\"\"| Returns the absolute value of length of the interval.", "           | For a signed representation, use delta.", "        ", "           :result: Absolute value of length of an interval.", "           :rtype: int ", "        \"\"\"", "        length = self.b - self.a ", "        if length > 0: return length", "        else: return length *-1" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "| Returns the absolute value of length of the interval.", "| For a signed representation, use delta." ],
          "rtype" : "int ",
          "rvalue" : "Absolute value of length of an interval.\n"
        },
        "end" : 119,
        "name" : "length",
        "start" : 110
      }, {
        "code" : [ "    def delta(self): ", "        \"\"\"| Returns the signed delta of the interval, calculated as b-a", "           | For an unsigned representation, use length.", "", "           :result: Delta of an interval.", "           :rtype: float ", "        \"\"\"", "        return float(self.b - self.a)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "| Returns the signed delta of the interval, calculated as b-a", "| For an unsigned representation, use length." ],
          "rtype" : "float ",
          "rvalue" : "Delta of an interval.\n"
        },
        "end" : 130,
        "name" : "delta",
        "start" : 122
      }, {
        "code" : [ "    def mid(self):", "        \"\"\"Returns the midpoint value of the interval.", "        \"\"\"", "        return self.eval(0.5)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the midpoint value of the interval." ]
        },
        "end" : 136,
        "name" : "mid",
        "start" : 132
      }, {
        "code" : [ "        \"\"\"", "        \"\"\"", "        return other.a in self or other.b in self or self.a in other or self.b in other", "        " ],
        "decorators" : "method",
        "end" : 141,
        "name" : "overlaps",
        "start" : 138
      }, {
        "code" : [ "        \"\"\" Returns a copy of this interval with ordered values, such that a < b", "        ", "            :result: Ordered copy of Interval object.", "            :rtype: Interval ", "        \"\"\"", "        if self.is_ordered: return Interval(self.a, self.b)", "        else: return Interval(self.b, self.a)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a copy of this interval with ordered values, such that a < b" ],
          "rtype" : "Interval ",
          "rvalue" : "Ordered copy of Interval object.\n"
        },
        "end" : 149,
        "name" : "order",
        "start" : 143
      }, {
        "code" : [ "        \"\"\"| Returns a copy of this interval with swapped values.", "           | Such that this.a = new.b and this.b = new.a", "        ", "           :result: Interval object with swapped values.", "           :rtype: Interval ", "        \"\"\"", "        return Interval(self.b, self.a)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a copy of this interval with swapped values.", "| Such that this.a = new.b and this.b = new.a" ],
          "rtype" : "Interval ",
          "rvalue" : "Interval object with swapped values.\n"
        },
        "end" : 159,
        "name" : "invert",
        "start" : 152
      }, {
        "code" : [ "        \"\"\"| Divides this interval into a list of values equally spaced between a and b.", "           | Unless include_last is set to True, returned list will not include Interval.b: the first value returned is Interval.a and the last is Interval.b-(Interval.delta/divs)", "        ", "           :param divs: Number of interval divisions.", "           :type divs: int", "           :param include_last: Boolean value.", "           :type include_last: bool", "           :result: List of numbers in which a list is divided. ", "           :rtype: list", "        \"\"\"", "        step = self.delta/float(divs)", "        if include_last : divs += 1", "        return [self.a+step*n for n in range(divs)]", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Divides this interval into a list of values equally spaced between a and b.", "| Unless include_last is set to True, returned list will not include Interval.b: the first value returned is Interval.a and the last is Interval.b-(Interval.delta/divs)" ],
          "parameters" : {
            "divs" : "Number of interval divisions.\n",
            "include_last" : "Boolean value.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of numbers in which a list is divided. \n",
          "types" : {
            "divs" : "int\n",
            "include_last" : "bool\n"
          }
        },
        "end" : 174,
        "name" : "divide",
        "start" : 161
      }, {
        "code" : [ "        \"\"\" Divides an interval into a list of equal size subintervals(interval objects).", "        ", "            :param divs: Number of subintervals.", "            :type divs: int", "            :result: List of subintervals (interval objects). ", "            :rtype: list", "        \"\"\"", "        return [Interval(n,n+self.delta/float(divs)) for n in self.divide(divs)]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Divides an interval into a list of equal size subintervals(interval objects)." ],
          "parameters" : {
            "divs" : "Number of subintervals.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of subintervals (interval objects). \n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 184,
        "name" : "subinterval",
        "start" : 176
      }, {
        "code" : [ "        \"\"\" Divides an interval into a list of randomly sized subintervals(interval objects).", "        ", "            :param divs: Number of subintervals.", "            :type divs: int", "            :result: List of subintervals (interval objects). ", "            :rtype: list", "        \"\"\"", "        if divs < 1 : return ival", "        result = []", "        r_list = [self.a,self.b]", "        r_list.extend(self.eval(random.random()) for k in range(divs-1)) ", "        r_list.sort()", "", "        return [Interval(r_list[n],r_list[n+1]) for n in range(divs)]", "           " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Divides an interval into a list of randomly sized subintervals(interval objects)." ],
          "parameters" : {
            "divs" : "Number of subintervals.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of subintervals (interval objects). \n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 200,
        "name" : "rand_interval",
        "start" : 186
      }, {
        "code" : [ "        \"\"\"| Returns a parameter corresponding to the position of the given number within this interval.", "           | Effectively, the opposite of eval().", "", "           :param number: Number to find the parameter of.", "           :type number: float", "           :result: Parameter.", "           :rtype: float", "", "           ::", "            ", "                print Interval(10,20).deval(12)", "                >>0.2", "                print Interval(10,20).deval(25)", "                >>1.5", "", "        \"\"\" ", "        if self.delta == 0 : raise ZeroDivisionError(\"This interval cannot be devaluated because the delta is zero\")", "        return (number-self.a) / self.delta", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Returns a parameter corresponding to the position of the given number within this interval.", "| Effectively, the opposite of eval()." ],
          "parameters" : {
            "number" : "Number to find the parameter of.\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Parameter.\n",
          "types" : {
            "number" : "float\n"
          }
        },
        "end" : 220,
        "name" : "deval",
        "start" : 202
      }, {
        "code" : [ "        \"\"\"| Evaluates a given parameter within this interval.", "           | For example, given an Interval(0->2*math.pi): eval(0.5) == math.pi", "           | Optionally, you may limit the resulting output to this interval", "        ", "            ", "           :param t: Number to evaluate.", "           :type t: float", "           :result: Evaluated number. ", "           :rtype: float", "", "           ::", "            ", "                print Interval(10,20).eval(0.2)", "                >>12.0", "                print Interval(10,20).deval(1.5)", "                >>25.0", "", "        \"\"\"  ", "        ret = self.delta * t + self.a", "        if not limited : return ret", "        return self.limit_val(ret)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates a given parameter within this interval.", "| For example, given an Interval(0->2*math.pi): eval(0.5) == math.pi", "| Optionally, you may limit the resulting output to this interval" ],
          "parameters" : {
            "t" : "Number to evaluate.\n"
          },
          "rtype" : "float\n\n",
          "rvalue" : "Evaluated number. \n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 243,
        "name" : "eval",
        "start" : 222
      }, {
        "code" : [ "        \"\"\" Limits a given value to the min and max of this Interval.", "        ", "            :param n: the number to be limited by the Interval.", "            :type n: float", "            :result: a number between the min and max of this Interval (inclusive).", "            :rtype: float", "        \"\"\"", "        if n < self.a : return self.a", "        if n > self.b : return self.b", "        return n", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Limits a given value to the min and max of this Interval." ],
          "parameters" : {
            "n" : "the number to be limited by the Interval.\n"
          },
          "rtype" : "float",
          "rvalue" : "a number between the min and max of this Interval (inclusive).\n",
          "types" : {
            "n" : "float\n"
          }
        },
        "end" : 255,
        "name" : "limit_val",
        "start" : 245
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 257,
        "name" : "__repr__",
        "start" : 257
      }, {
        "code" : [ "        return Interval.remap(val,self,target_interval,limited)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 261,
        "name" : "remap_to",
        "start" : 260
      }, {
        "code" : [ "    def remap(val, source_interval, target_interval=None, limited=False): ", "        \"\"\" Translates a number from its position within the source interval to its relative position in the target interval.  Optionally, you may limit the resulting output to the target interval.", "        ", "            :param val: Number to remap.", "            :type val: float", "            :param source_interval: Source interval.", "            :type source_interval: interval", "            :param target_interval: Target interval", "            :type target_interval: interval", "            :param limited: flag that limits result to target interval", "            :type limited: bool", "            :result: The given number remapped to the target interval.", "            :rtype: float", "        ", "        \"\"\"  ", "        if target_interval is None: target_interval = Interval(0,1)", "", "        t = source_interval.deval(val)", "        return target_interval.eval(t,limited)", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Translates a number from its position within the source interval to its relative position in the target interval.  Optionally, you may limit the resulting output to the target interval." ],
          "parameters" : {
            "limited" : "flag that limits result to target interval\n",
            "source_interval" : "Source interval.\n",
            "target_interval" : "Target interval\n",
            "val" : "Number to remap.\n"
          },
          "rtype" : "float",
          "rvalue" : "The given number remapped to the target interval.\n",
          "types" : {
            "limited" : "bool\n",
            "source_interval" : "interval\n",
            "target_interval" : "interval\n",
            "val" : "float\n"
          }
        },
        "end" : 282,
        "name" : "remap",
        "start" : 263
      }, {
        "code" : [ "    def encompass(values = [0],nudge=False):", "        \"\"\" Returns an interval defined by the minimum and maximum of a list of values.", "        ", "            :param values: A list of numbers.", "            :type values: list", "            :result: An Interval from the min and max of a list of values.", "            :rtype: Interval", "        \"\"\"", "        from .dc_base import EPSILON", "        if nudge: return Interval(min(values)-EPSILON, max(values)+EPSILON)", "        a, b = min(values), max(values)", "        if a == b : return False", "        return Interval(a,b)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns an interval defined by the minimum and maximum of a list of values." ],
          "parameters" : {
            "values" : "A list of numbers.\n"
          },
          "rtype" : "Interval",
          "rvalue" : "An Interval from the min and max of a list of values.\n",
          "types" : {
            "values" : "list\n"
          }
        },
        "end" : 297,
        "name" : "encompass",
        "start" : 284
      }, {
        "code" : [ "    def twopi():", "        \"\"\" Creates an interval from 0->2PI", "        ", "            :result: Interval from 0 to 2PI.", "            :rtype: Interval", "        \"\"\"", "        return Interval(0,math.pi*2)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Creates an interval from 0->2PI" ],
          "rtype" : "Interval",
          "rvalue" : "Interval from 0 to 2PI.\n"
        },
        "end" : 307,
        "name" : "twopi",
        "start" : 300
      }, {
        "code" : [ "    def pi():", "        \"\"\" Creates an interval from 0->PI", "            ", "            :result: Interval from 0 to 2PI.", "            :rtype: Interval", "        \"\"\"", "        return Interval(0,math.pi)", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Creates an interval from 0->PI" ],
          "rtype" : "Interval",
          "rvalue" : "Interval from 0 to 2PI.\n"
        },
        "end" : 316,
        "name" : "pi",
        "start" : 309
      } ],
      "documentation" : {
        "description" : [ "an interval class" ]
      },
      "end" : 316,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_interval.py",
      "name" : "Interval",
      "references" : {
        "classes" : {
          "EPSILON" : 2,
          "Interval" : 14
        },
        "functions" : {
          "__add__" : 1,
          "__contains__" : 1,
          "__div__" : 1,
          "__eq__" : 1,
          "__floordiv__" : 1,
          "__hash__" : 1,
          "__init__" : 1,
          "__repr__" : 1,
          "__sub__" : 1,
          "__truediv__" : 1,
          "delta" : 1,
          "deval" : 1,
          "divide" : 1,
          "encompass" : 1,
          "eval" : 1,
          "invert" : 1,
          "is_ordered" : 1,
          "length" : 1,
          "limit_val" : 1,
          "list" : 1,
          "mid" : 1,
          "order" : 1,
          "overlaps" : 1,
          "pi" : 1,
          "rand_interval" : 1,
          "remap" : 1,
          "remap_to" : 1,
          "subinterval" : 1,
          "twopi" : 1
        }
      },
      "start" : 5
    },
    "7ade47ca-b05c-4cc4-8684-8282ed341309" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def func(u,v):", "    # draw PLine between a number of Points ", "    pline_u = PLine([pg.eval(u) for pg in pgons_v])", "    # evaluate the PLine in V", "    pt = pline_u.eval(v)", "    # if the Point is not at the edge of the PGon: ", "    if (v>0):", "        this_magnetic_field = 0", "        # for every index of the PGon vertices:", "        for i in range(len(pgon.pts)):", "            # evaluate the Point at a given edge of the PGon", "            seg = pgon.edges[i]", "            this_magnetic_field  += magnetic_field(pt, seg)", "        # get their Z value with the magnetic field", "        z = 2.0/this_magnetic_field", "    # If the point is on the edge, its height is zero", "    else: z = 0", "    return Point(pt.x,pt.y,z)", "", "# redraw the PGon with the basis at the centroid", "pgon = rebase_to_centroid(pgon)", "# set scale and rotation values for the inscribed PGons", "pgons_v = [pgon]", "# for every recurssion in the inflations: ", "for n in range(inflat_cnt):", "    # recursively inflate the given PGon and scale it down", "    pgon_i = pgons_v[-1].inflate(rotation)", "    pgon_i * scale", "    pgons_v.append(pgon_i)", "", "# create the Surface ", "srf = Surface(func)", "# set a Surface tolerance", "srf.tol_u = 1.0/12" ],
          "end" : 54,
          "start" : 20
        },
        "description" : "\nInflated Magnetic Field Surface\ncreate a Surface by inflation\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.07.F02c", "Given a polygon, create a Surface by parameterizing the inflated polygon. Control the parameterization of the Surface by modifying the PGon's inflation, their scaling factor and  their rotation. The Z height of the Surface's Points results from a magnetic field function." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Williams Biot-Savart/4.07.F02c.py",
      "name" : "4.07.F02c.py",
      "references" : {
        "classes" : {
          "PLine" : 1,
          "Point" : 1,
          "Surface" : 1
        }
      },
      "required" : [ "pgon (PGon) PGon to inflate.", "inflate_cnt (int) Number of inflations of the PGon.", "scale (float) Scale factor for the inflated PGons.", "rotation (float) Rotation angle for the inflated PGons", "height (float) Maximum inflation height.", "magnetic_field (function) Magnetic field function." ],
      "result" : [ "srf (Surface) Inflated Surface." ]
    },
    "7af81b78-3d96-43f9-abe0-2b8d476f49a9" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_grid.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Grid constructor.", "", "            :param pixel_dim: Resolution of Grid.", "            :type pixel_dim: Interval or Tuple of two Integers", "            :param bnds: 2d spatial boundary of Grid.", "            :type pixel_dim: Bounds         ", "            :param include_corners: Boolean value.", "            :type include_corners: bool", "            :param wrap: Boolean value.", "            :type wrap: bool", "            :result: Raster object", "            :rtype: Raster", "            ", "        \"\"\"", "        super(Grid,self).__init__(pixel_dim,**kwargs)", "        if bnds is None: self._bnds = Bounds.unit_square()", "        else: self._bnds = Bounds(ival_x=bnds.ival_x,ival_y=bnds.ival_y ) # enforces 2d Bounds", "        self._recalculate_base_pts()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Grid constructor." ],
          "parameters" : {
            "bnds" : "2d spatial boundary of Grid.\n",
            "include_corners" : "Boolean value.\n",
            "pixel_dim" : "Resolution of Grid.\n",
            "wrap" : "Boolean value.\n"
          },
          "rtype" : "Raster",
          "rvalue" : "Raster object\n",
          "types" : {
            "include_corners" : "bool\n",
            "pixel_dim" : "Bounds         \n",
            "wrap" : "bool\n"
          }
        },
        "end" : 28,
        "name" : "__init__",
        "start" : 10
      }, {
        "code" : [ "    def bnds(self):", "        \"\"\" Returns Grid bounds.", "            ", "            :result: Grid bounds.", "            :rtype: Bounds", "            ", "        \"\"\"", "        return self._bnds", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns Grid bounds." ],
          "rtype" : "Bounds",
          "rvalue" : "Grid bounds.\n"
        },
        "end" : 39,
        "name" : "bnds",
        "start" : 31
      }, {
        "code" : [ "        \"\"\" Returns the center point of the cell associated with the given address.", "        ", "            :param x: x-coordinate", "            :type x: float", "            :param y: y-coordinate", "            :type y: float", "            :result: Center point of cell.", "            :rtype: Point", "        ", "        \"\"\"", "        return self._base_pts[y*self.px_width+x]", "       " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the center point of the cell associated with the given address." ],
          "parameters" : {
            "x" : "x-coordinate\n",
            "y" : "y-coordinate\n"
          },
          "rtype" : "Point",
          "rvalue" : "Center point of cell.\n",
          "types" : {
            "x" : "float\n",
            "y" : "float\n"
          }
        },
        "end" : 52,
        "name" : "get_cpt",
        "start" : 41
      }, {
        "code" : [ "        \"\"\" Returns center point of cell nearest to given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: Center point of near cell.", "            :rtype: Point", "            ", "            ", "        \"\"\"", "        x,y = self.address_near(a,b)", "        return self.get_cpt(x,y)       ", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns center point of cell nearest to given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Center point of near cell.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 67,
        "name" : "cpt_near",
        "start" : 54
      }, {
        "code" : [ "        \"\"\" Returns center points of cells near the given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: List of center points near given location.", "            rtype: [Point]", "            ", "        \"\"\"", "        ", "        tups = self.addresses_near(a,b)", "        return [self.get_cpt(tup[0],tup[1]) for tup in tups]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns center points of cells near the given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rvalue" : "List of center points near given location.\nrtype",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 82,
        "name" : "cpts_near",
        "start" : 69
      }, {
        "code" : [ "        \"\"\" Returns address of the grid cell nearest to the given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: Location of vector.", "            :rtype: int, int", "            ", "        \"\"\"", "        pt = Point(a,b)", "        ", "        if pt.x <= self.bnds.ival_x.a : idx_x = 0", "        elif pt.x >= self.bnds.ival_x.b : idx_x = self.px_width - 1", "        else: idx_x = [pt.x in ival for ival in self._ivals_x].index(True)", "        ", "        if pt.y <= self.bnds.ival_y.a : idx_y = 0", "        elif pt.y >= self.bnds.ival_y.b : idx_y = self.px_height - 1", "        else: idx_y = [pt.y in ival for ival in self._ivals_y].index(True)", "        ", "        return idx_x, idx_y", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns address of the grid cell nearest to the given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "int, int",
          "rvalue" : "Location of vector.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 105,
        "name" : "address_near",
        "start" : 84
      }, {
        "code" : [ "        \"\"\" Returns addresses of grid cells near the given location. May be passed either a point or an x,y coordinate.", "        ", "            :param a: x-coordinate or Point.", "            :type a: float or Point", "            :param b: y-coordinate or None.", "            :type b: float or None", "            :result: List of locations.", "            :rtype: [tup]", "            ", "        \"\"\"", "        pt = Point(a,b)", "        add = self.address_near(pt)", "        dx = 1 if pt.x > self._ivals_x[add[0]].mid else -1", "        dy = 1 if pt.y > self._ivals_y[add[1]].mid else -1", "        adds = [add,(add[0]+dx,add[1]),(add[0]+dx,add[1]+dy),(add[0],add[1]+dy)]", "        adds = filter(lambda add: add[0]>=0 and add[0]<self.px_width, adds)", "        adds = filter(lambda add: add[1]>=0 and add[1]<self.px_height, adds)", "        return sorted(adds)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns addresses of grid cells near the given location. May be passed either a point or an x,y coordinate." ],
          "parameters" : {
            "a" : "x-coordinate or Point.\n",
            "b" : "y-coordinate or None.\n"
          },
          "rtype" : "[tup]",
          "rvalue" : "List of locations.\n",
          "types" : {
            "a" : "float or Point\n",
            "b" : "float or None\n"
          }
        },
        "end" : 125,
        "name" : "addresses_near",
        "start" : 107
      }, {
        "code" : [ "        \"\"\"", "        If the bounds changes or the res changes, the values defined here must be recalculated", "        ", "        \"\"\"", "        #sp_org = self._bnds.cpt", "        #sp_dim = spatial_dim", "        #self._sp_ival_x = Interval(self._sp_org.x - self._sp_dim.a/2, self._sp_org.x + self._sp_dim.a/2) # spatial interval x", "        #self._sp_ival_y = Interval(self._sp_org.y - self._sp_dim.b/2, self._sp_org.y + self._sp_dim.b/2) # spatial interval y", "        self._base_pts = []", "        self._ivals_x = self.bnds.ival_x//self.px_width", "        self._ivals_y = self.bnds.ival_y//self.px_height", "        for ival_y in self._ivals_y:", "            for ival_x in self._ivals_x:", "                self._base_pts.append(Point(ival_x.mid, ival_y.mid))", "     " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "If the bounds changes or the res changes, the values defined here must be recalculated" ]
        },
        "end" : 141,
        "name" : "_recalculate_base_pts",
        "start" : 127
      }, {
        "code" : [ "    def cell_pgons(self):", "        from .dc_pgon import PGon", "        pgons = []", "        for ival_y in self._ivals_y:", "            for ival_x in self._ivals_x:", "                pts = Point(ival_x.a, ival_y.a),Point(ival_x.b, ival_y.a),Point(ival_x.b, ival_y.b),Point(ival_x.a, ival_y.b)", "                pgons.append(PGon(pts))", "        return pgons", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 151,
        "name" : "cell_pgons",
        "start" : 143
      }, {
        "code" : [ "    def lattice_segs(self):", "        x_segs = []", "        x_segs.append(Segment( Point(self._ivals_x[0].a,self.bnds.ival_y.a), Point(self._ivals_x[0].a,self.bnds.ival_y.b) ))", "        for ival_x in self._ivals_x:", "            x_segs.append(Segment( Point(ival_x.b,self.bnds.ival_y.a), Point(ival_x.b,self.bnds.ival_y.b) ))", "            ", "        y_segs = []", "        y_segs.append(Segment( Point(self.bnds.ival_x.a,self._ivals_y[0].a), Point(self.bnds.ival_x.b,self._ivals_y[0].a) ))", "        for ival_y in self._ivals_y:", "            y_segs.append(Segment( Point(self.bnds.ival_x.a,ival_y.b), Point(self.bnds.ival_x.b,ival_y.b) ))            ", "                ", "        return x_segs, y_segs", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 165,
        "name" : "lattice_segs",
        "start" : 153
      } ],
      "documentation" : {
        "description" : [ "an abstract class for storing information in a spatialized raster grid format.", "once a Grid.bnds is initialized it should not be changed, as collections of spatial intervals are calculated to speed addressing and near pts calculations" ]
      },
      "end" : 165,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_grid.py",
      "name" : "Grid",
      "references" : {
        "classes" : {
          "Bounds" : 2,
          "Grid" : 2,
          "PGon" : 1,
          "Point" : 15,
          "Raster" : 1,
          "Segment" : 4
        },
        "functions" : {
          "__init__" : 1,
          "_recalculate_base_pts" : 1,
          "address_near" : 1,
          "addresses_near" : 1,
          "bnds" : 1,
          "cell_pgons" : 1,
          "cpt_near" : 1,
          "cpts_near" : 1,
          "get_cpt" : 1,
          "lattice_segs" : 1
        }
      },
      "start" : 4
    },
    "7b9f825d-f5a4-49f7-9b08-7655ddc94854" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def nearby_clrs(cl, delta):", "    nearby = []", "    # previous, current, and next Color step", "    deltas = [-delta,0,delta]", "    # for every Color step in deltas:", "    for r_delta in deltas:", "        # for every Color step in deltas:", "        for g_delta in deltas:", "            # for every Color step in deltas:", "            for b_delta in deltas:", "                # if the sum of the abs values is not 0:", "                if not((abs(r_delta)+abs(g_delta)+abs(b_delta)) == 0):", "                    # create a new Color", "                    cl=Color(sample.r+r_delta,sample.g+g_delta,sample.b+b_delta)", "                    # add the Color to the nearby Colors", "                    nearby.append(cl)", "    return nearby", "", "# set maximum number of iterations", "max_count = 100", "# for every index in the max_count:", "for count in range(max_count):", "    # if the current sample doesn't meet the threshold:", "    if fitness(sample) < thresh:", "        # get all the nearby samples", "        step_samples = nearby_clrs(sample,step)", "        # sort them by their fitness to the goal Color", "        step_samples.sort(key=fitness)", "        # make the highest fitness sample the current sample", "        sample = step_samples[-1]", "    else: ", "        break" ],
          "end" : 50,
          "start" : 18
        },
        "description" : " \nGreedy Color Optimization\nUses a function that returns a list of Colors near to a given Color in order to perform a rudimentary optimization.\n",
        "end" : 18,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "4.07.L01c", "Given a fitness function, perform a directed search. Step size by checking neighboring Colors and moving in the direction of best fit. Create a path representing search history." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Color Optimization/4.07.L01c.py",
      "name" : "4.07.L01c.py",
      "references" : {
        "classes" : {
          "Color" : 1
        }
      },
      "required" : [ "fitness (func) Fitness function.", "step (float) Step size for search.", "threshold (float) Threshold for fitness.", "sample (Color) Sample Color." ],
      "result" : [ "sample (Color) Sample Color to compare." ]
    },
    "7c2b0218-18f9-499f-9de4-815e51fd5386" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def func1(i):", "    return Point(sin(Interval(0.4,math.pi+0.9).eval(i))+1, 0 , sqrt(i)*height)", "" ],
          "end" : 16,
          "start" : 13
        },
        "description" : "\nA function that creates a curve for the rotational surface\n",
        "end" : 13,
        "start" : 11
      }, {
        "code" : {
          "content" : [ "def func2(pt):", "    # construct the surface axis", "    vec = srf.axis * srf.height", "    axis = vec.to_line()", "    # calculate the nearest point on the axis to the pt", "    ppt,t,dist = axis.near(pt)", "    # remap pt to surface domain u(height)", "    u = t**2", "    ", "    # remap pt to surface domain v ", "    v0 = Vec(1,0) ", "    v1 = Vec(ppt,pt)", "    ang = v0.angle(v1)", "    if v0.cross(v1).z < 0 : ang = math.pi*2-ang", "    v = srf.domain_v.deval(ang)", "    ", "    return srf.eval(u,v)", "", "height = 5", "crv = Curve(function = func1, domain = Interval(0,1)) # curve to rotate", "srf = RotationalSurface(crv, dom_v= Interval(0,(3/2)*pi)) # rotational surface", "srf.height = func1(1).z # surface height", "srf.project = func2 # surface projection function" ],
          "end" : 41,
          "start" : 19
        },
        "description" : "\nA function that projects a given point onto the Rotational Surface\n",
        "end" : 19,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.07.L05c", "Creates a Rotational Surface, and a function that allows for the projection of a point onto that surface." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Mesh Relaxation/4.07.L05c.py",
      "name" : "4.07.L05c.py",
      "references" : {
        "classes" : {
          "Curve" : 1,
          "Interval" : 3,
          "Point" : 1,
          "RotationalSurface" : 1,
          "Vec" : 2
        }
      },
      "result" : [ "a Rotational Surface" ]
    },
    "7ff1f3c6-4db2-46f8-9436-4f1f48c20419" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# import the solar geometry extension", "from decodes.extensions.solar_geometry import *", "", "# initiate a SolarGeom object with lat, long & time zone", "sg = SolarGeom(42.3583, 71.05690, -5)", "# define a day of the year from a date", "day = SolarGeom.str_to_day_of_year('08/25')", "", "# get the solar vector from a range of hours", "for hr in range(start_hr,end_hr):", "    vec = sg.vec_at(day, hr)", "", "" ],
          "end" : 32,
          "start" : 18
        },
        "description" : "\nSolar Vectors\nGiven start and end hour values, calculate solar vectors for a given date and location. \n",
        "end" : 18,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "def does_cast_shadow(pt, vec, site):", "    # create a ray with the given Point and Vec", "    ray = Ray(pt,vec)", "    # test if this ray intersects the site:", "    return xsec.of(ray,site)", "    " ],
          "end" : 41,
          "start" : 35
        },
        "description" : "\nTest for Shadow Casting on Site\n",
        "end" : 35,
        "start" : 33
      }, {
        "code" : {
          "content" : [ "# define Bounds for the voxel", "ivx = Interval(0,15)", "ivy = Interval(0,25)", "ivz = Interval(0,20)", "envelope = Bounds(ival_x = ivx , ival_y = ivy , ival_z = ivz)", "# create a VoxelField with Bounds and x,y,z step sizes", "vf = VoxelField(envelope, 10, 10, 10)", "# initiate an Intersector object", "xsec = Intersector()", "", "# make a container to store Points not touching the site", "slices = [[] for z in range(vf.res_z)]", "# for every x value in the VovexlField resolution: ", "for x in range(vf.res_x):", "    # for every y value in the VovexlField resolution: ", "    for y in range(vf.res_y): ", "        # for every z value in the VovexlField resolution: ", "        for z in range(vf.res_z):", "            # create a Point with the x,y, and z values", "            pt = vf.cpt_at(x,y,z)", "            # for every Vec in Vecs:", "            for vec in vecs:", "                # if the solar Vec and the site intersect:", "                if does_cast_shadow(pt,vec,geom):", "                    # record it in our vector field", "                    vf.set(x,y,z,1) ", "                    break # stop looking at other vectors", "            # if this point found an intersection:", "            if vf.get(x,y,z) == 1: ", "                # stop looking for intersections in this stack", "                break ", "            # append any points that don't produce intersections", "            else: slices[z].append(pt)" ],
          "end" : 77,
          "start" : 45
        },
        "description" : "\nVoxel Shadow Analysis\nGiven a list of Vecs, evaluate the solar incidence of a VoxelField onto a given site. \n",
        "end" : 45,
        "start" : 42
      } ],
      "documentation" : {
        "description" : [ "4.04.F03a", "Given a start hr and an end hr, create solar vectors for a date and place. Evaluate the solar incidence of a voxel field onto a given site." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Right to Light/4.04.F03a.py",
      "name" : "4.04.F03a.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "Intersector" : 1,
          "Interval" : 3,
          "Ray" : 1,
          "SolarGeom" : 2,
          "VoxelField" : 1
        }
      },
      "required" : [ "start_hr (int) Starting hr for solar calculation", "end_hr (int) Ending hr for solar calculation", "geom (PGon) Site geometry" ],
      "result" : [ "slices ([[Point]]) Points that don't touch the site." ]
    },
    "83e7b3e4-4989-4700-b114-3e32dec3045d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Guy():", "    ", "    def __init__(self, pos_start = Point(), vel_start = Vec(-0.1,0.1)):", "        self.pos = pos_start ", "        self.vel = vel_start", "        ", "    \"\"\"", "    Step Method", "    Causes this Guy to move by updating its position according to its current velocity, and then randomly picking a new velocity ", "    \"\"\"       ", "    def step(self):        ", "        # update the position of this Guy", "        self.pos += self.vel       ", "        # randomly select a new direction to walk", "        self.vel = Vec.random(Interval(-1,1),constrain2d = True)", "        " ],
          "end" : 31,
          "start" : 16
        },
        "description" : "\nGuy Class\nA class that stores the position and direction of movement of a \"Guy\" agent\n",
        "end" : 16,
        "start" : 13
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04a.py",
      "name" : "4.02.L04a.py",
      "references" : {
        "classes" : {
          "Guy" : 1,
          "Interval" : 1,
          "Point" : 1,
          "Vec" : 2
        }
      }
    },
    "83f516b8-afd2-4c7e-91b2-bafeea20e7cd" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "width = 0.1", "" ],
          "end" : 18,
          "start" : 16
        },
        "description" : "\n[noprint]\n",
        "end" : 16,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "def spike(pt, p_vec, m_vec, attr, ival):", "    p_vec.length = Interval.remap(pt.distance(attr), ival, spike_length)", "    return [pt-m_vec.normalized(width), pt+p_vec, pt]", "" ],
          "end" : 26,
          "start" : 22
        },
        "description" : "\nSpike Generator\nCreates a spike with a given width, and a length dependent on distance to attractor point \n",
        "end" : 22,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "def noise(pgon, min_dist, attr_pt): ", "    dists = sorted([p.distance(attr_pt) for p in pgon.pts])", "    #create interval from smallest and greatest distance  ", "    dist_ival = Interval(dists[0],dists[-1])", "    pgn_pts = []", "    #for each edge of the polygon:", "    for edge in pgon.edges:", "        pgn_pts.append(edge.spt)", "        #vector parallel to edge", "        move_vec = edge.vec.normalized(min_dist)", "        #outward-pointing vector perpendicular to edge", "        perp_vec = move_vec.cross(pgon.basis.z_axis)", "        spike_pt = edge.spt + move_vec", "        #while edge length is greater than a given minimum", "        while edge.spt.distance2(spike_pt) < edge.spt.distance2(edge.ept):", "            #if chosen to have a spike", "            if random.uniform(0.00,1.00)> 0.50:", "                #add points for a spike", "                spk = spike(spike_pt, perp_vec, move_vec, attr_pt, dist_ival)", "                pgn_pts.extend(spk)", "            spike_pt += move_vec", "        ", "    return PGon(pgn_pts)", "", "n_path = [noise(pgon,0.3,attractor) for pgon in pgons]", "" ],
          "end" : 55,
          "start" : 30
        },
        "description" : "\nNoisemaker\nModifies a polygon outline to one that has outward pointing spikes at random points along edge\n",
        "end" : 30,
        "start" : 27
      } ],
      "documentation" : {
        "description" : [ "4.05.L06a", "Given a list of polygons, creates noise along these outlines in the form of outward pointing spikes at randomly chosen points" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/3d Printed Toolpathing/4.05.L06a.py",
      "name" : "4.05.L06a.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "PGon" : 1
        }
      },
      "required" : [ "pgons ([PGons]) List of PGons", "attractor (Point) Attractor Point", "spike_length (Interval) Range of allowable spike lengths" ],
      "result" : [ "n_path ([PGons]) List of modified PGons with noise" ]
    },
    "8520ba5e-f023-4220-bb31-f005d639ea65" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "kfs_tup = knifiness, forkiness, spooniness", "prongs = [Prong(dict,CS(),kfs_tup) for dict in Prong.prong_info]", "", "webs = [\\", "    Web(prongs[0],prongs[1],kfs_tup,False),\\", "    Web(prongs[1],prongs[2],kfs_tup,False),\\", "    Web(prongs[2],prongs[3],kfs_tup,False),\\", "    Web(prongs[0],prongs[3],kfs_tup,True)\\", "    ]", "    ", "prong_crvs = [png.outline for png in prongs]", "web_crvs = [web.outline for web in webs]" ],
          "end" : 31,
          "start" : 20
        },
        "description" : "\nDraw Flatware\nProduces curves that describe a piece of flatware generated from a given set of knifiness, spooniness, and forkiness values.\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.04.L02c", "Given three parameters - knifiness, spooniness, and forkiness - produce a two-dimensional outline of a piece of flatware that is an appropriate \"hybrid\" of each of these three archetypes." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/A Design Space of Flatware/4.04.L02c.py",
      "name" : "4.04.L02c.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Prong" : 2,
          "Web" : 4
        }
      },
      "required" : [ "Prong (class) A class that creates Prongs from given Points", "Webs(class) A class that creates Webs from two Prongs", "knifiness (float) An index of the current flatware's knifiness", "forkiness (float) An index of the current flatwares's forkiness", "spooniness (float) An index of the current flateware's spooniness" ],
      "result" : [ "([Pline]) A list of Plines representing a \"hybrid\" piece of flatware" ]
    },
    "8572b6e0-fb0f-4f29-b39d-85acafccb04d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class Strip():", "    def __init__(self, start, length, filled = None):", "        # define the boundary of a Strip", "        self.boundary = Interval(start, start+length)", "        # if the Strip is not filled:", "        if filled is None:", "            # there is no filling in the Strip", "            self.filling = None", "            # there is no remainder in the Strip", "            self.remainder = None", "        else:", "            # the filling is an Interval with a start and an end", "            self.filling = Interval(start, start+filled)", "            # the remainder is a new Strip", "            self.remainder = Strip(start+filled, start+length-filled)", "", "    # returns whether or not a Strip is filled", "    @property", "    def filled(self):", "        return not(self.filling is None)", "", "    \"\"\"", "    Put Item in Strip", "    Fills a Strip and returns remainders of a Strip.", "    \"\"\"", "    ", "    def put_item(self, length):", "        # if the Strip is filled:", "        if self.filled:", "            # the length of the item is a remainder", "            self.remainder.put_item(length)", "        else:", "            # if the length of the item is larger than Strip boundary:", "            if length > self.boundary.length : ", "                # the item doesn't fit in the Strip", "                return False", "            # update the filling of the Strip with an item length", "            self.filling = Interval(self.boundary.a, self.boundary.a + length)", "            # get the remaining length of the Strip ", "            avail_length = self.boundary.length - length", "            # create a new Strip with the remaining length", "            self.remainder = Strip(self.boundary.a + length, avail_length)", "            return True", "", "    \"\"\"", "    Query Methods", "    Methods to know whether an item can fit or not into a Strip, and to get the length of filled Strip", "    \"\"\"", "    ", "    # see if an item can fit in a Strip", "    def can_fit(self, length):", "        # if the Strip is filled:", "        if self.filled:", "            # the length of the item is a remainder", "            return self.remainder.can_fit(length)", "        else:", "            # if the length is smaller than Strip boundary: ", "            if length <= self.boundary.length: ", "                # return the Strip", "                return self", "            else: return None", "", "    # get the length of a filled Strip", "    def get_filled(self):", "        result = []", "        # if the Strip is filled:", "        if self.filled:", "            # add the remaining Strip to the result", "            result.append(self.filling)", "            # if the remainder is different than None:", "            if self.remainder != None : ", "                # add the remaining Strip to the result", "                r = self.remainder.get_filled()", "                if r <> [] : result.extend(r)", "        return result", "", "    \"\"\"", "    Bin Strips", "    Method to place different lengths into Strips.", "    \"\"\"", "    def bin_strips(self, lengths = [], stock_size = Interval(100,100)):", "            # construct a Strip with a stock_size", "            strips = [Strip(stock_size.a,stock_size.b)]", "            # start with 1 Strip", "            no_strips = 1", "            # for every length in the list of lengths", "            for i, r in enumerate(lengths):", "                flag = False", "                # for every Strip in Strips:", "                for j, s in enumerate(strips):", "                    # see if the item can fit in the Strip", "                    test_strip = s.can_fit(r)", "                    # if the item can fit:", "                    if test_strip <> None:", "                        # put the item in the Strip", "                        test_strip.put_item(r)", "                        flag = True", "                        break", "                # if the item can fit:", "                if not flag:", "                    # add a new Strip to the list", "                    strips.append(Strip(no_strips*stock_size.a, stock_size.b))", "                    # increase the count of Strips", "                    no_strips += 1", "                    strips[no_strips-1].put_item(r)", "            return strips" ],
          "end" : 124,
          "start" : 18
        },
        "description" : "\n1D Packing Strip Class\nCreates a Strip object that contains filled areas and open sub-strips.\n",
        "end" : 18,
        "start" : 15
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01a.py",
      "name" : "4.05.L01a.py",
      "references" : {
        "classes" : {
          "Interval" : 4,
          "Strip" : 5
        }
      }
    },
    "85b10f38-b62d-44e9-8f42-f44748c90626" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "class LEngine(object):", "", "    def __init__(self,axiom):", "        self.axiom = axiom", "        self.rules = []", "        self.clear()", "    ", "    # removes all rules and initializes history", "    def clear(self):", "        self.hist = [self.axiom]", "        self.rules = []", "    ", "    \"\"\"", "    Add Rule Method", "    Adds a rule to this LEngine.  Rules are be defined as single strings separated by \"->\" or as a tuple of two strings", "    \"\"\"", "    def add_rule(self,rulestring):", "        rule = [str.strip() for str in rulestring.split(\"->\")]", "        self.rules.append(rule)", "", "    \"\"\"", "    Apply Rule Method", "    Returns the replacement string for the specified character based on the rules.  If no rules apply, returns the original character", "    \"\"\"", "    def apply_rules(self, char):", "        # for each rule in the rule set:", "        for rule in self.rules:", "            # if the character matches the first half of the rule:", "            if char == rule[0]:", "                # return the second half of the rule", "                return rule[1]", "                break", "        # if none match, return the original character", "        return str(char)", "    ", "    \"\"\"", "    Step Method", "    Produces a new string based on the transformations defined by the set of rules", "    \"\"\"", "    def step(self):", "        nxt_gen = \"\"", "        # for every character in the current string:", "        for chr in self.cur_gen:", "            # check if there is a rule that applies to it and replace", "            nxt_gen += self.apply_rules(chr)", "        self.hist.append(nxt_gen)", "", "    \"\"\"", "    [noprint]", "    \"\"\"", "    # returns the last generation of applied strings of rules", "    @property", "    def cur_gen(self):", "        return self.hist[-1]", "    " ],
          "end" : 75,
          "start" : 20
        },
        "description" : "\nLEngine Class\nDefines an evaluation 'engine' type that operates on strings of characters in the manner of an LSystem. Given an initial string called an 'axiom', an instance of this engine will iteratively produce new generations of strings based on transformations defined by a set of rules.\n",
        "end" : 20,
        "start" : 17
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/LSystem/4.02.L06a.py",
      "name" : "4.02.L06a.py",
      "references" : {
        "classes" : {
          "LEngine" : 1
        }
      }
    },
    "8818c332-72ee-4ebc-b812-4f3b4db3f0d9" : {
      "code" : [ "    \"\"\" parses an EPW file and returns structured data", "    path (string) filepath to the EPW file", "    desired_keys ([string]) keys indicating the values to be returned.    only keys listed in epw_keycols may be used.    ", "    out: if desired_keys is a single string, an array of floats is returned, if desired_keys is an array of keys, an array of dicts is returned.", "    \"\"\"", "    skip = number_of_epw_header_lines", "    file = open(path) # open the file", "    lineno = 0 # keeps track of how many lines have been parsed", "    hours = [] #initalize an empty list where we'll store our dicts", "    for line in file:", "        if lineno >= skip : # only parse this line if past the header", "            hourdict = _parse_epw_line(line, desired_keys) # parse line", "            if hourdict is not None : ", "                hours.append(hourdict)", "        lineno += 1 # keep track of how many lines have been parsed", "        if lineno > 8760+skip : break", "    return hours", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "parses an EPW file and returns structured data", "path (string) filepath to the EPW file", "desired_keys ([string]) keys indicating the values to be returned.    only keys listed in epw_keycols may be used.", "out: if desired_keys is a single string, an array of floats is returned, if desired_keys is an array of keys, an array of dicts is returned." ]
      },
      "end" : 67,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/parse_epw.py",
      "name" : "parse_epw_file",
      "start" : 50
    },
    "88c83570-7b75-4f02-9473-a1fd33fec63d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "for src,tar in gph.node_pairs:", "    # if the distance to a target node is below the tolerance:", "    if src.dist(tar)<ttol:", "        # remove all traces of the target node", "        if tar in gph.edges and node in gph.edges:", "            for node in gph.edges[tar]: gph.edges[node].remove(tar)", "            del gph.edges[tar]", "        gph.nodes.discard(tar)", "        ", "        " ],
          "end" : 24,
          "start" : 14
        },
        "description" : "\nPoint Proximity Cleanup\nEnsures that Points are not too close together - if any node in the graph is too close to another node it is removed.\n",
        "end" : 14,
        "start" : 11
      }, {
        "code" : {
          "content" : [ "", "#returns node pairs forming a triangle with a given node", "def forms_triangle_with(g,src):", "    ret = []", "    for tar in g.edges[src]:", "        # intersection of src neighbors and target neighbors sets", "        mut_nbrs = set(g.edges[src]) & set(g.edges[tar])", "        mut_nbrs.discard(src) ", "        if len(mut_nbrs) > 0: ret.extend([(tar,mut) for mut in mut_nbrs ])", "    return ret", "", "# a minimum ratio of edge lengths", "allowable_ratio = 1.6    ", "for src in gph.nodes:", "    # for each trio of nodes ", "    for n1,n2 in forms_triangle_with(gph,src):", "        # if one connection is similar in length to two others", "        if (src.dist(n1)+ src.dist(n2))/n1.dist(n2) < allowable_ratio:", "            # remove it", "            if n2 in gph.edges[n1]: gph.edges[n1].remove(n2)", "            if n1 in gph.edges[n2]: gph.edges[n2].remove(n1)", "            " ],
          "end" : 50,
          "start" : 28
        },
        "description" : "\nAngle Cleanup\nEnsures that connected edges are not nearly parallel - if any connection in the graph is too similar to another connection, it is removed.\n",
        "end" : 28,
        "start" : 25
      }, {
        "code" : {
          "content" : [ "def forms_quad_with(g,src,allow_diagonal=False):", "    ret = []", "    for n1 in g.edges[src]:", "        # for each valid 1st and 2nd degree connection", "        for n2 in set(g.edges[n1]) - set([src]):", "            # if searching for quads", "            if not allow_diagonal:", "                # check each 3rd degree connection and return quads if found", "                pass", "                if src in g.edges[n2] or n2 in g.edges[src]:  continue # diagonal found", "                for n3 in set(g.edges[n2]) - set([n1,src]):", "                    if n3 in g.edges[n1] or n1 in g.edges[n3]:  continue # diagonal found", "                    if src in g.edges[n3]:", "                        ret.append([n1,n2,n3])", "            # if searching for crosses", "            else:", "                # check each 3rd degree connection and return crosses if found", "                if src in g.edges[n2] or n2 in g.edges[src]: # diagonal found", "                    for n3 in set(g.edges[n2]) - set([n1,src]):", "                        if n3 in g.edges[n1] or n1 in g.edges[n3]: # diagonal found", "                            if src in g.edges[n3]:", "                                ret.append([n1,n2,n3])", "    return ret", "" ],
          "end" : 79,
          "start" : 55
        },
        "description" : "\nQuad and Cross Detection\nGiven a graph (g) and a starting node (n0), searches chains of connected nodes that form a \"quad\", which is understood as four connections that form a loop. Optionally, we may search for \"crosses\", which are understood as quads that have connections across both diagonals.\n[pseudo]\n",
        "end" : 55,
        "start" : 51
      }, {
        "code" : {
          "content" : [ "for src in gph.nodes.copy():", "    # for each quartet of nodes", "    for n1,n2,n3 in forms_quad_with(gph,src):", "        # create connection across the smaller diag", "        if src.distance2(n2) < n1.distance2(n3): gph.add_edge(src,n2)", "        else: gph.add_edge(n1,n3)", "        " ],
          "end" : 90,
          "start" : 83
        },
        "description" : "\nQuad Cleanup\nEnsures triangulation - removes any quad connections found in the graph by creating diagonals along its shorter edge.\n",
        "end" : 83,
        "start" : 80
      }, {
        "code" : {
          "content" : [ "for n0 in gph.nodes:", "    chns = forms_quad_with(gph,n0, False)", "    # for each chain found:", "    for chn in chns:", "        # find the longest diagonal connection and remove", "        chn.sort(key = lambda pt : n0.distance2(pt))", "        if chn[-1] in gph.edges[n0]: gph.edges[n0].remove(chn[-1])", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          "end" : 115,
          "start" : 94
        },
        "description" : "\nCross Cleanup\nEnsures clean overlaps by removing any overlapping or crossing connections\n",
        "end" : 94,
        "start" : 91
      } ],
      "documentation" : {
        "description" : [ "4.02.F01b", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Sabin/4.02.F01b.py",
      "name" : "4.02.F01b.py"
    },
    "8937b4b1-6b26-44a3-af7b-f717b3d40761" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_danzer.py",
      "definitions" : [ {
        "code" : [ "        #create a child TileA by mapping child base to parent pts[3,0,1]", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    3,0,1 )", "        tileB0 = self.child_by_base(\"B0\",cs_prnt,not self.flip)    # opposite handdeness as parent", "        #create a child TileA by mapping child base to parent pts[3,0,2]", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    3,0,2 )", "        tileK0 = self.child_by_base(\"K0\",cs_prnt,self.flip)# same handedness as parent", "        #create a child TileK by mapping child pts[1,0,3] to parent pts[0,3,1]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,    1,0,3 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    0,3,1 )", "        tileK1 = self.child_by_explicit(\"K2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create two child TileK by mirroring the previous two tiles", "        cs_mir = tileK0.cs_by_tile_pts(0,2,3)", "        tileK2 = tileK0.sibling_by_mirror(\"K2\",cs_mir)", "        tileK3 = tileK1.sibling_by_mirror(\"K3\",cs_mir)", "        ", "        #create a child TileB by mapping child pts[2,0.1] to parent pts[1,3,2]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,    2,0,1 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    1,3,2 )", "        tileB1 = self.child_by_explicit(\"B1\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[2,1,3] to parent pts[2,0,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,    2,1,3 )", "        cs_prnt = DzTileB().cs_by_base_pts(self.rlvl,    2,0,1 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        ", "        #return all children", "        return [tileB0,tileK0,tileK1,tileK2,tileK3,tileB1,tileC0]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 246,
        "name" : "inflate",
        "start" : 220
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 246,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DzTileB",
      "references" : {
        "classes" : {
          "DzTile" : 1,
          "DzTileB" : 7,
          "DzTileC" : 1,
          "DzTileK" : 1,
          "Point" : 4,
          "_base_pts" : 1
        },
        "functions" : {
          "inflate" : 1
        }
      },
      "start" : 209
    },
    "899f242f-d7a3-4b12-8aea-84d0cae4de82" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def blob(t):", "    # define a number of values with mathematical functions", "    c = math.cos(2*math.pi*t)", "    s = math.sin(2*math.pi*t)", "    c_theta = math.cos(2*math.pi*alpha)", "    s_theta = math.sin(2*math.pi*alpha)", "    factor = 1.0/math.sqrt(2)", "    cos1 = math.cos(4*math.pi*t)", "    r = 50*(1+rad*factor*c_theta*cos1+rad*factor*s_theta*math.cos(6*math.pi*t))", "    # create a Point based on the mathematical values", "    pt_out = Point(r*c, r*s)", "    return pt_out", "     ", "", "" ],
          "end" : 32,
          "start" : 17
        },
        "description" : "\nBlob by Radius and Alpha\nMethod to create a blobby curve based on a d1 and d2 values\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.04.L05a", "Create a solution space matrix of blobby curves." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Blobs/4.04.L05a.py",
      "name" : "4.04.L05a.py",
      "references" : {
        "classes" : {
          "Point" : 1
        }
      },
      "required" : [ "rad (float) Radius of blob.", "alpha ([float]) Decimal value to create the blob." ],
      "result" : [ "crv_out (Curve) A close curve with different shape and size. A portion of the curves will be self-intersecting." ]
    },
    "89e927d8-e7ee-41fc-9715-6b1f891b4e93" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def func(t):", "    x = (1 - t**2)/(1 + t**2)", "    y = 2*t/(1+t**2)", "    return Point(x,y)", "    ", "ival = Interval(-10,10)", "tol = ival.delta/pt_count", "crv = Curve(func,ival,tol)", "#a.put(crv)", "" ],
          "end" : 35,
          "start" : 24
        },
        "description" : "\n",
        "end" : 24,
        "start" : 23
      }, {
        "code" : {
          "content" : [ "pln = crv.eval(t)", "" ],
          "end" : 40,
          "start" : 38
        },
        "description" : "\ncurves can be evaluated within an interval of 0->1\n",
        "end" : 38,
        "start" : 36
      }, {
        "code" : {
          "content" : [ "pln = crv.deval(td)", "" ],
          "end" : 45,
          "start" : 43
        },
        "description" : "\ncurves can be \"devaluated\" within the interval defined by their domain\n",
        "end" : 43,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "print \"curve length is a bit more than \",crv.appx_length", "", "near_pt, near_t, dist = crv.near(pt)", "print \"nearest point\",near_pt,\"found at t=\",near_t,\",\",dist,\"units away\"", "" ],
          "end" : 54,
          "start" : 50
        },
        "description" : "\nthe tolerence of a curve does not effect the position of evaluated points, but does effect other things, such as the calculated length of the curve this is because some operations are performed on a discretized version of the curve (a polyline).  we can access this 'secret' polyline via the surrogate property\n\ntry setting a very low pt_count and see what happens to the output below:\n",
        "end" : 50,
        "start" : 46
      } ],
      "documentation" : {
        "description" : [ "3.07.E01d", "Creates a curve with a given amount of control points.", "Then, given a number from 0 to 1, and a number belonging to the domain of the curve, evaluates the curve at both of those locations. Finally given a point in space, returns the nearest point on the curve to that point." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Curve Basics/3.07.E01d.py",
      "name" : "3.07.E01d.py",
      "references" : {
        "classes" : {
          "Curve" : 1,
          "Interval" : 1,
          "Point" : 1
        }
      },
      "required" : [ "a point count (int)", "a number from 0 to 1 (float)", "a number from -10 to 10 {float)", "a point (point)" ],
      "result" : [ "a curve", "a plane representing the evaluated curve on [0,1]", "a plane representing the evaluated curve on [-10,10]", "a curve representing the approximate calculated length", "a point on the curve nearest the given point in space" ]
    },
    "8a089c7b-766e-435e-ba6a-a60f7bb52134" : {
      "documentation" : {
        "description" : [ "2.03.E02a", "Koch Snowflakes and Gosper Islands can be implemented as two configurations of a single function." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/03-Collections/2.03.E02 - Fractals/2.03.E02a.py",
      "name" : "2.03.E02a.py",
      "references" : {
        "classes" : {
          "Segment" : 1,
          "Vec" : 1
        }
      }
    },
    "8a4a31d3-b01b-413c-9993-306dd014d88d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def distance_curve_arc(crv, arc):", "    # set the step size for curve evaluation", "    step = crv.tol", "    # set the t value of the first point on the Curve to evaluate", "    t_now = crv.domain.a + step", "    # set the t value of the max distance to the current t value", "    t_max = t_now", "    # set the max distance to 0", "    dist_max = 0", "    # while the t value is within the curve domain:", "    while t_now < crv.domain.b:", "        # evaluate the curve at that value", "        pt_crv = crv.deval(t_now)", "        # compute the distance between that point and the Arc", "        dist = arc.near(pt_crv)[2]", "        # if the distance is greater than the current max", "        if dist > dist_max:", "            # store the distance", "            dist_max = dist", "            # and store the t value", "            t_max = t_now", "        # increase the t value", "        t_now += step", "    # return the max distance, and its t value", "    return dist_max, t_max", "" ],
          "end" : 45,
          "start" : 20
        },
        "description" : "\nDistance Curve Arc\nCompute the maximum distance between a Curve and an Arc\n[pseudo]\n",
        "end" : 20,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "4.03.L02c", "Computes the distance between a given curve and arc, defined as the maximal", "distance between points on curve and the arc.  Returns the distance and the", "t-value on the curve at which this distance is achieved." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Curve Decomposition/4.03.L02c.py",
      "name" : "4.03.L02c.py",
      "required" : [ "crv (Curve) The Curve to compute the distance from", "arc (Arc) The Arc to compute the distance from" ],
      "result" : [ "dist_max (float) The maximum distance between the curve and arc", "t_max (float) The domain evaluation on the curve where the max distance happens." ]
    },
    "8a8b1614-a301-4d4d-b174-6239b7d623e3" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_danzer.py",
      "definitions" : [ {
        "code" : [ "        #create a child TileA by mapping child base to parent pts[0,1,3]", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,    0,1,3 )", "        tileA0 = self.child_by_base(\"A0\",cs_prnt,not self.flip)    # opposite handdeness as parent", "        #create a child TileK by mapping child pts[1,0,2] to parent pts[2,3,1]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,    1,0,2)", "        cs_prnt = DzTileC().cs_by_base_pts(self.rlvl,    2,3,1 )", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK0.cs_by_tile_pts(0,2,3)", "        tileK1 = tileK0.sibling_by_mirror(\"K1\",cs_mir)        ", "        ", "        #create a child TileC by mapping child pts[1,2,0] to parent pts[3,1,2]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,    1,2,0)", "        cs_prnt = DzTileC().cs_by_base_pts(self.rlvl,    3,1,2 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileC by mirroring the previous tile", "        cs_mir = tileC0.cs_by_tile_pts(0,2,3)", "        tileC1 = tileC0.sibling_by_mirror(\"C1\",cs_mir)   ", "        ", "        #return all children", "        return [tileA0,tileK0,tileK1,tileC0,tileC1]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 283,
        "name" : "inflate",
        "start" : 262
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 283,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DzTileC",
      "references" : {
        "classes" : {
          "DzTile" : 1,
          "DzTileA" : 1,
          "DzTileC" : 4,
          "DzTileK" : 1,
          "Point" : 4,
          "_base_pts" : 1
        },
        "functions" : {
          "inflate" : 1
        }
      },
      "start" : 251
    },
    "8a94cd94-8eb0-4f6d-8fb4-85008f0c326d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# hexagonal module", "hex = RGon(6, basis = CS(), apothem = apot)", "# set the initial width and height values", "grid_y = int(m.ceil(dim.y/(2*apot)))", "grid_x = int(m.ceil(dim.x/(1.5*hex.radius)))", "", "hexgrid = []", "# for every y value in the grid_y:", "for p in range(grid_y):", "    # for every x value in the grid_x:", "    for h in range(grid_x):", "        # if the cell is even:", "        if h % 2 == 0 : ", "            cs = CS(Point(1.5*h*hex.radius,p*apot*2,0))", "            # create a hexagon", "            hexgrid.append(RGon(6, basis= cs, apothem = apot))", "        else : ", "            cs = CS(Point(1.5*h*hex.radius,p*apot*2 + apot,0))", "            # create a translated hexagon", "            hexgrid.append(RGon(6, basis= cs, apothem = apot))", "" ],
          "end" : 41,
          "start" : 20
        },
        "description" : "\nApply Hexagon Grid\nCreate a grid of hexagons that matches the wall area.\n",
        "end" : 20,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "", "hexpanels =[]", "# for every index in hexgrid: create an empty list ", "for h in range(len(hexgrid)):hexpanels.append([])", "# for every index and hexpanel in hexgrid:", "for p_num, hexpanel in enumerate(hexgrid) :", "    # add the panel to the new grid", "    hexpanels[p_num].append(hexpanel)", "    # for Point in pts:", "    for p in pts :", "        # if the distance to the panel is not too small:", "        if hexpanel.basis.origin.distance(p) <= apot-offset : ", "            # keep the Point", "            hexpanels[p_num].append(p)" ],
          "end" : 58,
          "start" : 45
        },
        "description" : "\nRemove Invalid Points\nRemove any Points that are too close to the edges of the panels.\n",
        "end" : 45,
        "start" : 42
      } ],
      "documentation" : {
        "description" : [ "4.05.F02c", "Given a list of Points, match a grid of hexagons to the wall area. Remove any Points that are too close to the edges of the panels" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/PWall/4.05.F02c.py",
      "name" : "4.05.F02c.py",
      "references" : {
        "classes" : {
          "CS" : 3,
          "Point" : 2,
          "RGon" : 3
        }
      },
      "required" : [ "pts ([Point]) Randomized Point density array.", "dim (Vec) Dimensions of wall", "offset (float) Distance from edge to eliminate Points.", "apot (float) Apothem of hexagon." ],
      "result" : [ "hexgrid ([PGon]) Hexagonal panels.", "hexpanels ([[Point]]) Point in the panelgrid." ]
    },
    "8b3299bc-bd10-49ef-839c-770769bee9c9" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# construct a CA instance, and set a rule", "ca = CA(Interval(w,h),corners = True,wrap = False)", "ca.set_rule(func)", "", "# set cells to a randomly populated initial field", "rand_field = [random.choice([True, False]) for n in range(w*h)]", "ca.set_cells(rand_field) # set field to the new boolean field", "", "# for every generation to be produced:", "for n in range(max_gen):", "    # record the state of the CA every so often", "    if n % stepsize == 0: ca.record() ", "    # step the CA forward one generation", "    ca.step() ", "    " ],
          "end" : 35,
          "start" : 19
        },
        "description" : "\nCellular Automata Routine\nCreate a CA object, define an initial state, perform algorithm and visualize results\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "# get True and False points from the CA for a generation", "points = ca.to_pts(select_step)" ],
          "end" : 39,
          "start" : 38
        },
        "description" : "\n[noprint]\n",
        "end" : 38,
        "start" : 36
      } ],
      "documentation" : {
        "description" : [ "4.02.L02b", "Given a set of rules, the width and height of the cell field, and the number of generations, create a ca model with its time history." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Cellular Automata/4.02.L02b.py",
      "name" : "4.02.L02b.py",
      "references" : {
        "classes" : {
          "CA" : 1,
          "Interval" : 1
        }
      },
      "required" : [ "func (function) A function for evaluating each cell", "w,h (integers) Width, height of boolean field", "max_gen (int) The number of generations for the algorithm to run.", "stepsize (int) The number of generations to run before recording the state of the model.", "select_step (int) The recorded step of the model to visualize." ],
      "result" : [ "pts_true, pts_false (list of points) Lists representing true cells and false cells" ]
    },
    "8c03702c-9539-450d-af47-f20c64e9b167" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "for n in range(10):", "    for m in range(10):", "        pt = Point(n,m)", "        " ],
          "end" : 19,
          "start" : 14
        },
        "description" : "\n",
        "end" : 14,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "", "pt_grid = []", "for n in range(10):", "    pt_row = []", "    for m in range(10):", "        pt_row.append(Point(n,m))", "    pt_grid.append(pt_row)" ],
          "end" : 27,
          "start" : 21
        },
        "description" : "\n",
        "end" : 21,
        "start" : 20
      } ],
      "documentation" : {
        "description" : [ "2.03.E00b", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/03-Collections/2.03.E00 - NOGHX/2.03.E00b.py",
      "name" : "2.03.E00b.py",
      "references" : {
        "classes" : {
          "Point" : 2
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "8c8f1a4d-82bc-4ef3-b95f-5fdbfe87a498" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def guilloche_line(t):", "    pts = []", "    off = (pi * 2 / hump_count) * t", "    for y in Interval().divide(res,True):", "        pt_a = curve_a.eval(y)", "        pt_b = curve_b.eval(y)", "        theta = Interval.twopi().eval(y)+off", "        v = 0.5 + sin(theta*hump_count)/2", "        pts.append(Point.interpolate(pt_a,pt_b,v))", "    return(PLine(pts))", "    ", "chains = []", "for n in range(chain_count):", "    chain = guilloche_line(n/chain_count)", "    chains.append(chain)", "", "" ],
          "end" : 33,
          "start" : 17
        },
        "description" : "\nGuilloche of Chains Between Two Curves\n",
        "end" : 17,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "3.03.E01c", "Creates a guilloche of wavy chains between two curves." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Line/Guilloche/3.03.E01c.py",
      "name" : "3.03.E01c.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "PLine" : 1,
          "Point" : 1
        }
      },
      "required" : [ "curve_a (Curve) curve representing a boundary for each chain", "curve_b (Curve) curve representing the other boundary for each chain", "chain_count(int) number of wavy chains", "hump_count (int) number of complete waves in each wavy chain" ],
      "result" : [ "chains ([Pline]) a guilloche of wavy chains" ]
    },
    "8cb4ea57-a7c0-4931-a23c-a5abf891681d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def dupin(u,v):", "    return sphere_invert(torus(u,v), origin, r_i) ", "" ],
          "end" : 25,
          "start" : 21
        },
        "description" : "\nParmetrization for Dupin Cylide\nDependent on parametrization of torus\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "   ", "def iso_pts(srf, param, res, dir=\"u\") :", "    pts=[]", "    if dir == \"u\" : ", "        for n in Interval().divide(res): pts.append(srf.eval(n, param))", "        return PLine(pts)", "    elif dir == \"v\" :", "        for n in Interval().divide(res): pts.append(srf.eval(param, n))", "        return PLine(pts)", "    else : print \"please set dir = to u or v\"", "    " ],
          "end" : 40,
          "start" : 30
        },
        "description" : "\nIsocurve Extraction\nGeneral method to extract an isocurves from a surface \n[noprint] \n",
        "end" : 30,
        "start" : 26
      } ],
      "documentation" : {
        "description" : [ "4.03.L04c", "Inversion of Torus with respect to a sphere" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Pre-Rational Torus Studies/4.03.L04c.py",
      "name" : "4.03.L04c.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "PLine" : 2
        }
      },
      "required" : [ "torus (func) - a parametrization for a torus", "origin (Point) - center of inversion", "r_i (float) - radius of inversion", "sphere_invert (func) - inversion function" ],
      "result" : [ "dupin (func) - parametrization for the the inverted torus. Notice that isocurves of this parametrization are exactly the inverted isocurves of the torus parametrizaton", "iso_pts (iso) - TODO" ]
    },
    "8d1c6ec5-b85d-49a1-bf19-3d37f30ed982" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "tool_size = 0.05", "factor = 1.0", "tool_spac = tool_size * factor", "", "ival_u = Interval(0.5,1.0)", "ival_v = Interval(0.0,1.0)", "belt = surf.isopolyline(v_val=0.45, dom=Interval(0.0,0.5)) # the belt should be the longest v-curve", "tie  = surf.isopolyline(u_val=0.00, dom=ival_v)", "", "# set the number of u and v paths based on the tool", "divs_u = int( math.ceil( belt.length / tool_spac ))", "divs_v = int( math.ceil( tie.length / tool_spac ))", "divs_v = 65 # increases speed, but loses accuracy", "", "# the first polyline in the path", "p_lines = [surf.isopolyline(u_val = ival_u.a, res = divs_v)]", "u_lines = list(p_lines[0].pts)", "", "# for each u path in the division", "for u in ival_u.divide(divs_u):", "    ln = [[]]", "    # check every point in the path", "    for pt in surf.isopolyline(u_val = u, res = divs_v).pts:", "        # add it to the polyline if it is not too close to a previous point", "        if pt.distance(Point.near(pt, u_lines))> tool_spac: ln[-1].append(pt)", "        # else make a new polyline", "        else:ln.append([])", "    # add all polylines and points to the super lists if they are not null", "    for l in ln:", "        if len(l):", "            u_lines.extend(l)", "            p_lines.append(PLine(l))", "" ],
          "end" : 44,
          "start" : 12
        },
        "description" : "\nDraws toolpaths on a surface given a tool size\n",
        "end" : 12,
        "start" : 10
      } ],
      "documentation" : {
        "description" : [ "4.05.L03b", "Creates tool paths on a surface using the isopolylines and given a tool size. This ensures no overlap of paths." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Toolpathing/4.05.L03b.py",
      "name" : "4.05.L03b.py",
      "references" : {
        "classes" : {
          "Interval" : 3,
          "PLine" : 1,
          "Point" : 1
        }
      }
    },
    "8e6d9a8c-41ce-4fd8-8c3b-d287c1014c87" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# a container to hold resulting paths", "paths = []", "# a bounds within which walkers will walk", "bnds = Bounds.unit_square(10)", "u_args = (0.1,0.9)", "", "# for each type of walker:", "for n in range(2):", "    x,y = random.uniform(*u_args),random.uniform(*u_args)", "    start_pt = bnds.eval(x,y)", "    start_vel = vf.vec_near(start_pt)", "    ", "    # if this is our first walker:", "    if n%2==0 : walker = Jorn(start_pt,start_vel) # make it a Jorn", "    # if this is our second walker", "    else : walker = Guy(start_pt,start_vel) # make it a Guy", "        ", "    # for every time step:", "    for s in range(count):", "        # find vector nearest to the current position", "        fvec = vf.vec_near(walker.pos)   ", "        # steer the walker", "        if fvec.length > 0: walker.steer(fvec,infl_vec,infl_rand)", "        # update the walker's position", "        walker.step()", "        # if the walker has walked out of bounds", "        if not walker.pos in bnds:", "            # if he's walked far enough, append his path to our list", "            if len(walker.hist) > 1: paths.append(PLine(walker.hist))", "            # reset the walker to a new random position", "            walker.hist = []", "            x,y = random.uniform(*u_args),random.uniform(*u_args)", "            walker.pos = bnds.eval(x,y)", "            walker.vel = vf.vec_near(walker.pos)" ],
          "end" : 52,
          "start" : 19
        },
        "description" : "\nGuys and Jorns Routine\nCreates walkers and let them loose.\n",
        "end" : 19,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "4.02.L04f", "Make multiple walkers of different types and demonstrate their behavior." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04f.py",
      "name" : "4.02.L04f.py",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "Guy" : 1,
          "Jorn" : 1,
          "PLine" : 1
        }
      },
      "required" : [ "Guy (class) A class of walker", "Jorn (Guy) A class of walker based on Guy", "vf (VecField) A vector field for walkers to wander in", "influence (float) The amount of randomness in the walkers' walk", "count (int) Amount of steps for each type of walker to take" ],
      "result" : [ "paths ([PLines]) Paths of wandering walkers" ]
    },
    "8f30144f-25fb-4e9e-9965-118b27e374e7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# define a number of divisions for the Surface", "divs = 10", "pt_grid = []", "# for every u value of the Surface:", "for u in Interval().divide(divs, True):", "    # create a list for the rows", "    row = []", "    # for every v value of the Surface:", "    for v in Interval().divide(divs, True):", "        # evaluate the Surface and get a Point ", "        row.append(surf.eval(u,v))", "    # add the row to the list of Points", "    pt_grid.append(row)", "" ],
          "end" : 30,
          "start" : 16
        },
        "description" : "\nEvaluate a given surface, storing a grid of points\n[noprint]\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "", "cells = []", "# for every row except the last:", "for r in range(len(pt_grid)-1):", "    # for every Point in this row except the last: ", "    for i in range(len(pt_grid[r])-1):", "        # get four Points combining neighboring Points and rows", "        pt0 = pt_grid[r][i]", "        pt1 = pt_grid[r][i+1]", "        pt2 = pt_grid[r+1][i+1]", "        pt3 = pt_grid[r+1][i]", "        pts = [pt0,pt1,pt2,pt3] ", "        btm = cells[len(cells)-len(pt_grid[r])+1].pt_bottom", "        # if the Point is in bottom left corner - no neighbors:", "        if i == 0 and r == 0:", "            # create a Cell with no neighbors on sides or bottom", "            cells.append(Cell(pts))", "        # if the Point is in the left row - no side neighbor:", "        if i == 0 and r != 0:", "            # create a Cell with no neighbors on sides ", "            cells.append(Cell(pts, False, btm))", "        # if the Point is in the bottom row - no bottom neighbor:", "        if i != 0 and r == 0:", "            # create a Cell with no neighbors on bottom ", "            cells.append(Cell(pts, cells[-1].pt_side , False ))", "        # if the Points have neighbors:", "        if i != 0 and r != 0:", "            # create a Cell with neighbors on sides or bottom", "            cells.append(Cell(pts, cells[-1].pt_side , btm))", "# mesh the cells", "mesh_cells = [cell.to_mesh for cell in cells]" ],
          "end" : 64,
          "start" : 34
        },
        "description" : "\nArray Cells\nGiven a grid of Points, check for neighboring Points, and create Mesh cells with a Cell class.\n",
        "end" : 34,
        "start" : 31
      } ],
      "documentation" : {
        "description" : [ "4.05.L05b", "Given a Surface and a Cell class, subdivide the Surface and use the Cell class to panel the Surface according to neighboring Cells." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Encoding Material Behavior/4.05.L05b.py",
      "name" : "4.05.L05b.py",
      "references" : {
        "classes" : {
          "Cell" : 4,
          "Interval" : 2
        }
      },
      "required" : [ "surf (Surface) A Surface to populate with Cells.", "Cell (Cell) A Cell class to panel the Surface." ],
      "result" : [ "mesh_cells ([Mesh]) List of Cells Meshed." ]
    },
    "8fc588d1-4af4-4175-a250-46c2d40dfb88" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create a PinwheelTile and inflate it once", "tiles = PinwheelTile().inflate()", "", "# for every desired generation of Pinwheel tiles:", "for n in range(iter):", "    # create a container to hold inflated tiles", "    nxt_tiles = []", "    # for every tile in the current generation: ", "    for tile in tiles:", "        # inflate the tile and add it to our container", "        nxt_tiles.extend(tile.inflate())", "    # set things up for the next generation of inflation", "    tiles = nxt_tiles", "" ],
          "end" : 30,
          "start" : 16
        },
        "description" : " \nPinwheel Tiling Routine\nCreates and recursively inflates a Pinwheel tile\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.01.L04b", "Create a Pinwheeltile object and inflate the tile." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Tiling by Inflation/4.01.L04b.py",
      "name" : "4.01.L04b.py",
      "references" : {
        "classes" : {
          "PinwheelTile" : 1
        }
      },
      "required" : [ "pwtile (PinwheelTile) Pinwheel Class.", "iter (int) Number of recursions." ],
      "result" : [ "ret ([mesh]) Pinwheel tiles." ]
    },
    "8fcc7ae6-0a5a-462a-ae67-0d1599dbab85" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create a list with an initial SBin", "bins = [SBin(p_gon)]", "cuts_remain = True", "# create an empty list for finished cuts", "finished_bins = []", "", "# while a maximum value is not reached: ", "while cuts_remain:", "    cuts_remain = False", "    # create an empty list for new bins", "    new_bins = []", "    # for every SBin in bins:", "    for bin in bins:", "        # cut the given PGon", "        test_cut = bin.cut(mat_width)", "        # if there are no more cuts:", "        if test_cut == None :", "            # the cut is done, add the SBin to the finished_bins list", "            finished_bins.extend([bin])", "            # if the number of SBins is smaller than max_options:", "            if len(finished_bins) >= max_options: ", "                # no more cuts remain, break", "                cuts_remain = False", "                break", "        else:", "            # add the cuts to the new_bins list", "            new_bins.extend(test_cut)", "            # there are still cuts remaining", "            cuts_remain = True", "    # assign the list of new_bins to the list of bins", "    bins = new_bins", "    ", "" ],
          "end" : 53,
          "start" : 20
        },
        "description" : " \nRecursive Panelization\nLook through possible cuts for a given polygon and create a list of finished cuts. Limit to the amount of possibilities counted. A recursive method of trying out different cuts, until a maximum value is reached, or until the possibilities are exhausted.\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.03.F02e", "Given a base PGon, a material width, and a maximum number of options, look through possible cuts for and create a list of finished cuts." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Dennis Shelden/4.03.F02e.py",
      "name" : "4.03.F02e.py",
      "references" : {
        "classes" : {
          "SBin" : 1
        }
      },
      "required" : [ "SBin (class) A cut bin class.", "p_gon (PGon) A base panel.", "mat_width (float) Width of subpanels.", "max_options (int) Maximum variations.", "panel_cut (func) A function to cut panels." ],
      "result" : [ "ret ([SBins]) A list of SBin classes." ]
    },
    "906cc42d-2138-44d2-a558-45afd163bf6b" : {
      "documentation" : {
        "description" : [ "3.09.E02b", "Contruct a translational surface from a set of points" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Classical Surfaces/3.09.E02b.py",
      "name" : "3.09.E02b.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Curve" : 2,
          "Surface" : 1
        }
      },
      "required" : [ "curve points for a directerix (pts)", "curve points for a generatrix (pts)" ],
      "result" : [ "a translational surface (surface)" ]
    },
    "90d42640-ce7a-458b-89ac-fc7d6e81bd2d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def deval_normal(u,v):", "    pt_uv = surf.deval(u,v)", "    pt, u_pos, u_neg, v_pos, v_neg = surf._nudged(u,v,True)", "    ngbr = Mesh()", "    ngbr.append(pt_uv)", "    ngbr.append(pt_uv +  u_pos )", "    ngbr.append(pt_uv +  u_pos  +  v_pos)", "    ngbr.append(pt_uv +  v_pos )", "    ngbr.append(pt_uv +  u_neg  +  v_pos)", "    ngbr.append(pt_uv +  u_neg )", "    ngbr.append(pt_uv +  u_neg  +  v_neg)", "    ngbr.append(pt_uv +  v_neg )", "    ngbr.append(pt_uv +  u_pos  +  v_neg)", "    ", "", "    #Triangular mesh", "    ngbr.add_face(0,1,2)", "    ngbr.add_face(0,2,3)", "    ngbr.add_face(0,3,5)", "    ngbr.add_face(0,5,6)", "    ngbr.add_face(0,6,7)", "    ngbr.add_face(0,7,1)", "", "    N_vec = Vec.average([ngbr.face_normal(k) for k in range(len(ngbr.faces))])", "    return N_vec.normalized()", "   ", " " ],
          "end" : 45,
          "start" : 18
        },
        "description" : "\nNormal Evaluation\n",
        "end" : 18,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def deviation_from_plane(vecs):", "    avg_v = Vec.average(vecs)", "    dev = []", "    for v in vecs:", "        dev.append((v - v.projected(avg_v)).length)", "    return max(dev)", "        ", "    ", "count_u = int(res_u)", "count_v = int(res_v)", "msh = surf.to_mesh(divs_u=count_u,divs_v=count_v)", "", "u_val = Interval(surf.u0, surf.u1).divide(count_u,True)", "v_val = Interval(surf.v0, surf.v1).divide(count_v,True)", "" ],
          "end" : 63,
          "start" : 48
        },
        "description" : "\nDeviation from a Plane\n",
        "end" : 48,
        "start" : 46
      }, {
        "code" : {
          "content" : [ "# Evaluate the normals at each vertex of the mesh", "normals = []", "for v in v_val:", "   for u in u_val:", "        N_vec = deval_normal(u,v)", "        normals.append(N_vec)", "", "dev_plane = []", "for k in range(len(msh.faces)):", "    vert_normals = [normals[i] for i in msh.faces[k]]", "    dev_plane.append(deviation_from_plane(vert_normals))", "" ],
          "end" : 77,
          "start" : 66
        },
        "description" : "\nDeviation from a Plane\n",
        "end" : 66,
        "start" : 64
      } ],
      "documentation" : {
        "description" : [ "4.03.F02a", "Deviation of a Surface from a Plane" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Dennis Shelden/4.03.F02a.py",
      "name" : "4.03.F02a.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Mesh" : 1,
          "N_vec" : 4,
          "Vec" : 2
        }
      },
      "required" : [ "surf (Surface) A Surface to test", "res_u (int) resolution in u-direction", "res_v (int) resolution in v-direction" ],
      "result" : [ "ret ([Surface]) List of Surfaces." ]
    },
    "9153bb36-b8bf-46e8-9eb1-538dbabcf8c9" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_intersection.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"Intersection Constructor.", "        ", "            :result: Intersection Object.", "            :rtype: None", "            ", "        \"\"\"", "        self._geom = []", "        self.log = None", "        self.tol = EPSILON", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Intersection Constructor." ],
          "rtype" : "None",
          "rvalue" : "Intersection Object.\n"
        },
        "end" : 20,
        "name" : "__init__",
        "start" : 11
      }, {
        "code" : [ "        \"\"\"Returns intersection geometry at given index.", "        ", "            :param slice: Index of intersection geometry.", "            :type slice: int", "            :result: Intersection geometry.", "            :rtype: Intersector", "            ", "        \"\"\"", "        return self._geom[slice]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns intersection geometry at given index." ],
          "parameters" : {
            "slice" : "Index of intersection geometry.\n"
          },
          "rtype" : "Intersector",
          "rvalue" : "Intersection geometry.\n",
          "types" : {
            "slice" : "int\n"
          }
        },
        "end" : 31,
        "name" : "__getitem__",
        "start" : 22
      }, {
        "code" : [ "    def results(self):", "        \"\"\"Returns list of intersection geometries. ", "        ", "            :result: List of intersection geometries.", "            :rtype: [Intersector]", "            ", "        \"\"\"", "        return self._geom", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns list of intersection geometries." ],
          "rtype" : "[Intersector]",
          "rvalue" : "List of intersection geometries.\n"
        },
        "end" : 41,
        "name" : "results",
        "start" : 33
      }, {
        "code" : [ "        \"\"\" Appends item to list of intersection geometries.", "        ", "            :result: Appended item to list of intersection geometries.", "            :rtype: None", "            ", "        \"\"\"", "        ", "        #ATTENTION! This function doesn't really make sense for intersections.", "        ", "        self._geom.append(item)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Appends item to list of intersection geometries." ],
          "rtype" : "None",
          "rvalue" : "Appended item to list of intersection geometries.\n"
        },
        "end" : 53,
        "name" : "append",
        "start" : 43
      }, {
        "code" : [ "        \"\"\"Clears all intersection geometries from results list.", "        ", "            :result: Empty list of intersections.", "            :rtype: None", "            ", "        \"\"\"", "    ", "        del self._geom[:]", "        self.log = None", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Clears all intersection geometries from results list." ],
          "rtype" : "None",
          "rvalue" : "Empty list of intersections.\n"
        },
        "end" : 64,
        "name" : "clear",
        "start" : 55
      }, {
        "code" : [ "        \"\"\"Returns the length of the list of intersection geometries.", "        ", "            :result: Length of list.", "            :rtype: int", "            ", "        \"\"\"", "        ", "        return len(self._geom)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the length of the list of intersection geometries." ],
          "rtype" : "int",
          "rvalue" : "Length of list.\n"
        },
        "end" : 74,
        "name" : "__len__",
        "start" : 66
      }, {
        "code" : [ "        \"\"\"| Pass in two pieces of decodes geometry (a & b), and i'll have a go at intersecting them.", "           | Results will be stored in this xsec object.", "           | Extras (such as distance to intersection points) will be assigned as attributes to this xsec object.", "           | Function returns success, True or False        ", "           ", "           :param a: First geometry to intersect. May be any decodes geometry.", "           :type a: Geometry", "           :param b: Second geometry to intersect. May be any decodes geometry.", "           :type b: Geometry", "           :param \\**kargs: Two geometries to intersect.", "           :type \\**kargs: Geometry, Geometry", "           :result: Boolean Value", "           :rtype: bool", "            ", "        \"\"\"", "        ", "        return self.intersect(a,b,**kargs)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Pass in two pieces of decodes geometry (a & b), and i'll have a go at intersecting them.", "| Results will be stored in this xsec object.", "| Extras (such as distance to intersection points) will be assigned as attributes to this xsec object.", "| Function returns success, True or False" ],
          "parameters" : {
            "\\**kargs" : "Two geometries to intersect.\n",
            "a" : "First geometry to intersect. May be any decodes geometry.\n",
            "b" : "Second geometry to intersect. May be any decodes geometry.\n"
          },
          "rtype" : "bool\n ",
          "rvalue" : "Boolean Value\n",
          "types" : {
            "\\**kargs" : "Geometry, Geometry\n",
            "a" : "Geometry\n",
            "b" : "Geometry\n"
          }
        },
        "end" : 93,
        "name" : "of",
        "start" : 76
      }, {
        "code" : [ "        \"\"\"| Pass in two pieces of decodes geometry (a & b), and I'll have a go at intersecting them.", "           | Results will be stored in this xsec object.", "           | Extras (such as distance to intersection points) will be assigned as attributes to this xsec object.", "           | Function returns success, True or False.", "        ", "           :param a: First geometry to intersect. May be any decodes geometry.", "           :type a: Geometry", "           :param b: Second geometry to intersect. May be any decodes geometry.", "           :type b: Geometry", "           :param \\**kargs: Two geometries to intersect.", "           :type \\**kargs: Geometry, Geometry", "           :result: Boolean Value.", "           :rtype: bool", "        ", "        \"\"\"", "        self.clear()", "        ", "        # a whitelist of types we support", "        good_types = [Plane, Circle, PGon, RGon, Line, Ray, Segment, PLine, Arc]", "        bad_types = [Bounds,Color,Interval,Point,Xform]", "        if any([type(obj) in bad_types for obj in [a,b]]) : raise NotImplementedError(\"It isn't possible to intersect the following types: %s\"%([typ.__name__ for typ in bad_types]))", "        if any([type(obj) not in good_types for obj in [a,b]]) : raise NotImplementedError(\"I can only intersect the following types: %s\"%([typ.__name__ for typ in good_types]))", "        # sort by order found in whitelist collection", "        a,b = sorted( [a,b], key = lambda obj: good_types.index(type(obj)) )", "        type_a, type_b = type(a), type(b)", "                ", "        # INTERSECTIONS WITH A PLANE", "        if type_a == Plane:", "            plane, other = a,b", "", "            if type_b == Vec : return self._ray_plane(Ray(Point(),other),plane,**kargs)", "            if type_b == Line : return self._line_plane(other,plane,**kargs)", "            if type_b == Ray : return self._ray_plane(other,plane,**kargs)", "            if type_b == Segment : return self._seg_plane(other,plane)", "            if type_b == PLine : return self._pline_plane(other,plane)", "            if type_b == Circle : return self._circle_plane(other,plane)", "            if type_b == Arc : return self._arc_plane(other,plane)", "            if type_b == Plane : return self._plane_plane(other,plane)", "            ", "            raise NotImplementedError(\"I don't know how to intersect a Plane with a %s\"%(type_other.__name__))", "", "        # INTERSECTIONS WITH A CIRCLE", "        if type_a == Circle:", "            circ, other = a,b", "            if type_b == Circle : return self._circle_circle(other,circ)", "            if isinstance(other, LinearEntity) : return self._line_circle(other, circ)", "", "        # INTERSECTIONS WITH A PGON", "        if type_a == RGon or type_a == PGon:", "            pgon, other = a,b", "            if isinstance(other,LinearEntity) : return self._line_pgon(other,pgon,**kargs)", "", "        # INTERSECTIONS WITH A LINE", "        # last resort for Line-Line intersections", "        if all(isinstance(item,LinearEntity) for item in [a,b]) : ", "            return self._line_line(a,b)", "", "        raise NotImplementedError(\"I don't know how to intersect a %s with a %s\"%(type_a.__name__,type_b.__name__))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Pass in two pieces of decodes geometry (a & b), and I'll have a go at intersecting them.", "| Results will be stored in this xsec object.", "| Extras (such as distance to intersection points) will be assigned as attributes to this xsec object.", "| Function returns success, True or False." ],
          "parameters" : {
            "\\**kargs" : "Two geometries to intersect.\n",
            "a" : "First geometry to intersect. May be any decodes geometry.\n",
            "b" : "Second geometry to intersect. May be any decodes geometry.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "\\**kargs" : "Geometry, Geometry\n",
            "a" : "Geometry\n",
            "b" : "Geometry\n"
          }
        },
        "end" : 153,
        "name" : "intersect",
        "start" : 95
      }, {
        "code" : [ "        \"\"\" Intersects a Polygon with a Plane. Upon success, the Intersector.dist property will be set to the distance between line.spt and the point of intersection.", "        ", "            :param line: Line to intersect.", "            :type line: Line", "            :param plane: Plane to intersect.", "            :type plane: Plane", "            :param ignore_backface: Boolean Value.", "            :type ignore_backface: bool", "            :result: Boolean Value.", "            :rtype: bool", "        ", "        ", "        ", "            .. warning:: This method has not been implemented.", "        ", "        \"\"\"", "        # TODO", "        return False", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a Polygon with a Plane. Upon success, the Intersector.dist property will be set to the distance between line.spt and the point of intersection." ],
          "parameters" : {
            "ignore_backface" : "Boolean Value.\n",
            "line" : "Line to intersect.\n",
            "plane" : "Plane to intersect.\n"
          },
          "rtype" : "bool\n\n\n\n.. warning",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "ignore_backface" : "bool\n",
            "line" : "Line\n",
            "plane" : "Plane\n"
          }
        },
        "end" : 174,
        "name" : "_pgon_plane",
        "start" : 156
      }, {
        "code" : [ "        \"\"\" Intersects a  LinearEntity with a PGon. If the LinearEntity lies in the Plane of PGon, all Segments of intersection will be returned and Intersector.dist property will be set to 0. If the line and plane of PGon intersect at a Point, the Intersector.dist property to the distance between line.spt and the point of intersection. ", "        TODO - once line_line_collinear is incorporated, this will be able to handle the case when the LinearEntity overlaps any of the PGon edges", "    ", "        :param line: Line to intersect.", "        :type line: Line", "        :param pgon: Polygon to intersect.", "        :type pgon: PGon", "        :param ignore_backface: Boolean Value.", "        :type ignore_backface: bool", "        :result: Boolean Value.", "        :rtype: bool", "            ", "        \"\"\"", "        ignore_backface = False", "        if \"ignore_backface\" in kargs: ignore_backface = kargs['ignore_backface']", "    ", "        #first find intersection between LinearEntity and Plane of PGon", "        xsec = Intersector()", "        basis_success = xsec.of(pgon.basis.xy_plane,line,ignore_backface = ignore_backface)", "", "        #if LinearEntity and Plane do not intersect", "        if not basis_success:", "            self.log = \"LinearEntity does not intersect PGon.basis.\"", "            return False", "", "        #if LinearEntity lies in the Plane of PGon", "        if pgon.basis.xy_plane.contains(line.spt) and pgon.basis.xy_plane.contains(line.spt+line.vec):", "            self.log = \"LinearEntity in Plane of PGon\"", "            self.dist = 0", "            success = False", "            results = [] #stores tuples (t-value, point) used to find intersecting segments", "            if pgon.contains_pt(line.spt): ", "                results.append((0,line.spt))", "            #for each edge of PGon", "            for edge in pgon.edges:", "                #find intersection between LinearEntity and edge ", "                xsec = Intersector()", "                edge_success = xsec.of(line,edge)", "                #if Line-Line intersection is successful", "                if edge_success:", "                    #add intersection to results", "                    results.append((xsec.ta, xsec[0]))", "            if type(line)==Segment and pgon.contains_pt(line.ept): ", "                results.append((1,line.ept))", "            #sort points by t-value along LinearEntity", "            results = sorted(results)", "            #find all segments between ordered pairs of points that lie in PGon", "            for i in range(len(results)-1):", "                seg = Segment(results[i][1],results[i+1][1])", "                if pgon.contains_pt(seg.midpoint):", "                    self.append(seg)", "                    #return True if there is any segment that lies in the PGon", "                    success = True", "            return success", "        ", "        #if LinearEntity intersects Plane of PGon at a Point", "        self.log = \"LinearEntity intersects Plane of PGon at a Point\"", "        #if Point is contained in the PGon", "        if pgon.contains_pt(xsec[0]):", "            #add point of intersection to results" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a  LinearEntity with a PGon. If the LinearEntity lies in the Plane of PGon, all Segments of intersection will be returned and Intersector.dist property will be set to 0. If the line and plane of PGon intersect at a Point, the Intersector.dist property to the distance between line.spt and the point of intersection.", "TODO - once line_line_collinear is incorporated, this will be able to handle the case when the LinearEntity overlaps any of the PGon edges" ],
          "parameters" : {
            "ignore_backface" : "Boolean Value.\n",
            "line" : "Line to intersect.\n",
            "pgon" : "Polygon to intersect.\n"
          },
          "rtype" : "bool\n    ",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "ignore_backface" : "bool\n",
            "line" : "Line\n",
            "pgon" : "PGon\n"
          }
        },
        "end" : 235,
        "name" : "_line_pgon",
        "start" : 176
      }, {
        "code" : [ "        \"\"\" Intersects a Line with a Plane. Upon success, the Intersector.dist property will be set to the distance between line.spt and the point of intersection.", "        ", "            :param line: Line to intersect.", "            :type line: Line", "            :param plane: Plane to intersect.", "            :type plane: Plane", "            :param ignore_backface: Boolean Value.", "            :type ignore_backface: bool", "            :result: Boolean Value", "            :rtype: bool", "            ", "        \"\"\"", "        ignore_backface = False", "        if \"ignore_backface\" in kargs: ignore_backface = kargs['ignore_backface']", "        ", "        if plane.contains(line.spt) and plane.contains(line.spt+line.vec):", "            self.log = \"LinearEntity lies in the Plane\"", "            self.dist = 0.0", "            self.append(line)", "            return True", "        pln_norm = plane.normal", "        line_vec = line.vec", "        denom = pln_norm.dot(line_vec) # note, plane normal faces outward in the direction of the 'front' of the plane.  this may not be standard. ", "        # pos denom indicates ray behind plane", "        if ignore_backface and denom >= 0 : ", "            self.log = \"Backfaces ignored. LinearEntity lies behind Plane\"", "            return False ", "        # denom of zero indicates no intersection", "        if denom == 0 : ", "            self.log = \"No intersection\"", "            return False", "        t = pln_norm.dot(plane.origin-line.spt) / denom", "        self.dist = t # t < 0 indicates plane behind ray", "        self.append(line.eval(t))", "        self.log = \"Intersection found.\"", "        return True", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a Line with a Plane. Upon success, the Intersector.dist property will be set to the distance between line.spt and the point of intersection." ],
          "parameters" : {
            "ignore_backface" : "Boolean Value.\n",
            "line" : "Line to intersect.\n",
            "plane" : "Plane to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value\n",
          "types" : {
            "ignore_backface" : "bool\n",
            "line" : "Line\n",
            "plane" : "Plane\n"
          }
        },
        "end" : 278,
        "name" : "_line_plane",
        "start" : 242
      }, {
        "code" : [ "        \"\"\" Intersects a Ray with a Plane. Upon success the Intersector.dist property will be set to the distance between the ray.spt and the point of intersection.", "        ", "            :param ray: Ray to intersect.", "            :type ray: Ray", "            :param plane: Plane to intersect.", "            :type plane: Plane", "            :param ignore_backface: Boolean Value.", "            :type ignore_backface: bool", "            :result: Boolean Value.", "            :rtype: bool", "            ", "        \"\"\"", "        ignore_backface = False", "        if \"ignore_backface\" in kargs: ignore_backface = kargs['ignore_backface']", "    ", "        xsec = Intersector()", "        line_success = xsec._line_plane(ray,plane,ignore_backface = ignore_backface)", "        if not line_success : ", "            self.log = xsec.log", "            return False", "        if xsec.dist < 0 : ", "            self.log = \"Ray is directed away from Plane\"", "            return False", "        self._geom = xsec._geom", "        self.dist = xsec.dist", "        self.log = \"Intersection found.\"", "        return True", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a Ray with a Plane. Upon success the Intersector.dist property will be set to the distance between the ray.spt and the point of intersection." ],
          "parameters" : {
            "ignore_backface" : "Boolean Value.\n",
            "plane" : "Plane to intersect.\n",
            "ray" : "Ray to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "ignore_backface" : "bool\n",
            "plane" : "Plane\n",
            "ray" : "Ray\n"
          }
        },
        "end" : 308,
        "name" : "_ray_plane",
        "start" : 281
      }, {
        "code" : [ "        \"\"\" Intersects a Segment with a Plane. Upon success the Intersector.dist property will be set to the distance between the seg.spt and the point of intersection.", "            ", "            :param seg: Segment to intersect.", "            :type seg: Segment", "            :param plane: Plane to intersect.", "            :type plane: PLane", "            :result: Boolean Value", "            :rtype: bool", "            ", "        \"\"\"", "    ", "        xsec = Intersector()", "        line_success = xsec._line_plane(seg,plane,ignore_backface = False)", "        if not line_success : ", "            self.log = xsec.log", "            return False", "        if xsec.dist < 0 : ", "            self.log = \"While pointing in the right direction, this Segment does cross Plane\"", "            return False", "        if xsec.dist > seg.length : ", "            self.log = \"Segment points in the wrong direction, and does not cross Plane\"", "            return False", "        self._geom = xsec._geom", "        self.dist = xsec.dist", "        self.log = \"Intersection found.\"", "        return True", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a Segment with a Plane. Upon success the Intersector.dist property will be set to the distance between the seg.spt and the point of intersection." ],
          "parameters" : {
            "plane" : "Plane to intersect.\n",
            "seg" : "Segment to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value\n",
          "types" : {
            "plane" : "PLane\n",
            "seg" : "Segment\n"
          }
        },
        "end" : 337,
        "name" : "_seg_plane",
        "start" : 311
      }, {
        "code" : [ "        \"\"\" Intersects a Polyline with a Plane. ", "        ", "            :param pline: Polyline to intersect.", "            :type pline: PLine", "            :param plane: Plane to intersect.", "            :type plane: Plane", "            :result: Boolean value.", "            :rtype: bool", "            ", "        \"\"\"", "        self.edges = []", "        self.verts = []", "        xsec = Intersector()", "        pts = pline.pts", "        for pt in pts:", "            pt.side = 0", "            line = Line(plane.origin, plane.normal)", "            t = line.near(pt)[1]", "            if t < 0 : pt.side = -1", "            if t > 0 : pt.side = 1", "", "        ret = False", "        for n in range(len(pts)):", "            if n< len(pts)-1 and pts[n].side != pts[n+1].side and pts[n].side !=0 and pts[n+1].side !=0:", "                if xsec.of(pline.edges[n],plane):", "                    self.append(xsec[0])", "                    self.edges.append(n)", "                    self.verts.append(False)", "                    ret = True", "            if pts[n].side == 0 :", "                #if self.log is None: self.log = \"\"", "                #self.log += \"Found an intersection at a polyline vertex %s\\n\"%(n)", "                self.append(pts[n])", "                self.edges.append(False)", "                self.verts.append(n)", "                ret = True", "", "        return ret", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a Polyline with a Plane." ],
          "parameters" : {
            "plane" : "Plane to intersect.\n",
            "pline" : "Polyline to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "plane" : "Plane\n",
            "pline" : "PLine\n"
          }
        },
        "end" : 378,
        "name" : "_pline_plane",
        "start" : 340
      }, {
        "code" : [ "        \"\"\" Intersects two planes.", "        ", "            :param pln_a: First plane to intersect.", "            :type pln_a: Plane", "            :param pln_b: Second plane to intersect.", "            :type pln_b: Plane", "            :result: Boolean value.", "            :rtype: bool", "            ", "        \"\"\"", "        #TODO - return plane if coincident or coplanar", "        if pln_a.normal.is_parallel(pln_b.normal) :", "            self.log = \"Planes are parallel, no intersection found.\"", "            return False", "        n1, n2 = pln_a.normal, pln_b.normal", "        n1dotn2, r1, r2 = n1.dot(n2), n1.dot(pln_a.origin), n2.dot(pln_b.origin)", "        vec = n1.cross(pln_b.normal)", "        denom = 1-n1dotn2*n1dotn2", "        c1 = (r1 - n1dotn2*r2)/denom", "        c2 = (r2 - n1dotn2*r1)/denom", "        p0 = n1*c1 + n2*c2", "        self.append(Line(p0, vec))    ", "        return True", "        \"\"\"", "        vec = pln_a.normal.cross(pln_b.normal)    ", "        ldir = pln_b.normal.cross(vec)", "        denom = pln_a.normal.dot(ldir)", "        tvec = pln_a.origin - pln_b.origin", "        t = pln_a.normal.dot(tvec) / denom", "        pt = pln_b.origin + ldir * t   ", "        self.append( Line(pt,vec) )", "        return True", "        \"\"\"", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects two planes." ],
          "parameters" : {
            "pln_a" : "First plane to intersect.\n",
            "pln_b" : "Second plane to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "pln_a" : "Plane\n",
            "pln_b" : "Plane\n"
          }
        },
        "end" : 413,
        "name" : "_plane_plane",
        "start" : 380
      }, {
        "code" : [ "        \"\"\" Intersects a circle and a plane.", "        ", "            :param circ: circle to intersect.", "            :type circ: Circle", "            :param pln: plane to intersect.", "            :type pln: Plane", "            :result: Boolean value.", "            :rtype: bool", "            ", "        \"\"\"", "        xsec = Intersector()", "        plane_success = xsec._plane_plane(circ,plane)", "        if not plane_success : ", "            self.log = xsec.log", "            return False", "        ", "        self.line = xsec[0] # add plane-plane intersection line", "        npt, t, dist = self.line.near(circ.origin)       ", "        R = circ.rad", "        # dist == R within set tolerance", "        if (abs(dist-R) < self.tol):", "            self.log = \"One intersection point found\"", "            self.append(npt)", "            return True   ", "        if dist > R:", "            self.log = \"No intersection found\"", "            return False   ", "        if dist < R:", "            self.log = \"Two intersection points found\"", "            factor = math.sqrt(R**2-dist**2)/self.line.vec.length", "            self.append(npt-self.line.vec*factor)", "            self.append(npt+self.line.vec*factor)", "            return True", "        \"\"\"", "        x_vec = Vec(circ.origin,npt)", "        if x_vec.length < self.tol : x_vec = Vec(circ.origin,self.line.pt+self.line.vec)", "        if x_vec.length < self.tol : x_vec = Vec(circ.origin,self.line.pt)", "", "        cs = CS(circ.origin,x_vec,circ.normal.cross(x_vec))", "        p0 = cs.deval(self.line.spt)", "        p1 = cs.deval(self.line.spt+self.line.vec)", "", "        # circle-line intersection", "        # TODO: move this to its own method", "        dx = p1.x - p0.x", "        dy = p1.y - p0.y", "        dr = math.sqrt(dx**2+dy**2)", "        d = (p0.x*p1.y) - (p1.x*p0.y)", "", "        discr = circ.rad**2 * dr**2 - d**2", "        if discr < 0 :", "            self.log = \"Circle does not intersect with given Plane\"", "            return False", "        elif discr == 0:", "            self.log = \"Circle intersects Plane at a tangent Point\"", "            self.append(npt)", "            return True", "        elif discr > 0:", "            self.log = \"Circle intersects Plane at two Points\"", "            discr2 = math.sqrt(discr)", "            dr2 = dr**2", "            def sgn(x):", "                if x > 0 : return -1", "                return 1", "", "            x0 = (d * dy + sgn(dy) * dx * discr2) / dr2", "            x1 = (d * dy - sgn(dy) * dx * discr2) / dr2", "            y0 =(-d * dx + abs(dy) * discr2) / dr2", "            y1 =(-d * dx - abs(dy) * discr2) / dr2", "", "            self.append(cs.eval(x0,y0))", "            self.append(cs.eval(x1,y1))", "            return True", "        return False", "        \"\"\"", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a circle and a plane." ],
          "parameters" : {
            "circ" : "circle to intersect.\n",
            "pln" : "plane to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "circ" : "Circle\n",
            "pln" : "Plane\n"
          }
        },
        "end" : 490,
        "name" : "_circle_plane",
        "start" : 415
      }, {
        "code" : [ "        xsec = Intersector()", "        circ = Circle(arc.basis.xy_plane,arc.rad)", "        circle_success = xsec._circle_plane(circ,plane)", "        if not circle_success : ", "            self.log = xsec.log", "            self.log = \"Plane failed to intersect with Circle derived from given Arc: \"+xsec.log", "            return False", "        else:", "            self.angs = []", "            for pt in xsec.results:", "                ang = arc.basis.deval_cyl(pt)[1]", "                '''", "                n+=1", "                vec = Vec(arc.origin,pt)", "                ang = vec.angle(arc.basis.x_axis)", "                if ang == 0:", "                    self.append(pt)", "                    continue", "                if not CS(arc.origin,arc.basis.x_axis,vec).z_axis.is_coincident(arc.basis.z_axis):", "                    # look here!", "                    pass", "                    ang = math.pi*2 - ang", "                '''", "", "                if ang <= arc.angle:             ", "                    self.append(pt)", "                    self.angs.append(ang)", "                else:", "                    self.log = \"One of the intersection Points do not fall within sweep angle of this Arc: pt_angle={0} arc_angle={1}\".format(ang,arc.angle)", "        ", "        if len(self)==0:", "            self.log = \"Intersection Points do not fall within sweep angle of this Arc\"", "", "        return len(self)>0 ", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 526,
        "name" : "_arc_plane",
        "start" : 492
      }, {
        "code" : [ "        \"\"\" Intersects a LinearEntity with a Circle. ", "        ", "            :param circ: circle to intersect.", "            :type circ: Circle", "            :param pln: LinearEntity to intersect.", "            :type pln: Line, Seg or Ray", "            :result: Boolean value.", "            :rtype: bool", "            ", "        \"\"\"", "        xsec = Intersector()", "        if not xsec.of(line, circ.plane): ", "            self.log = \"Line and Plane of Circle don't intersect\"", "            return False", "        if type(xsec[0])==Point:", "            self.log = \"Line and Plane of Circle intersect at one point\"", "            pt, self.t = xsec[0], xsec.dist", "            if not circ.contains(pt) and not (circ.origin.distance(pt) == R):", "                return False", "            if type(line) == Ray and self.t < 0.0: return False", "            if type(line) == Segment and ((self.t < 0.0) or (self.t > 1.0)): return False", "            self.log = \"Intersection found\"", "            self.append(pt)", "            return True", "        self.log = \"Line lies in Plane of Circle\"", "        R, center = circ.rad, circ.origin", "        npt, t, dist = Line(line.spt, line.vec).near(center) #projection onto the extended line", "        #if dist is \"equal\" to R", "        if (abs(dist-R) < self.tol):", "            self.log = \"Case of one possible intersection point\"", "            self.t = t", "            if type(line) == Ray and self.t < 0.0: return False", "            if type(line) == Segment and ((self.t < 0.0) or (self.t > 1.0)): return False", "            self.append(npt)", "            return True", "        if dist > R:", "            self.log = \"Case of no intersection point\"", "            return False", "        if dist < R:", "            self.log = \"Case of two possible intersection points\"" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects a LinearEntity with a Circle." ],
          "parameters" : {
            "circ" : "circle to intersect.\n",
            "pln" : "LinearEntity to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "circ" : "Circle\n",
            "pln" : "Line, Seg or Ray\n"
          }
        },
        "end" : 568,
        "name" : "_line_circle",
        "start" : 529
      }, {
        "code" : [ "        \"\"\"Intersects two lines, returning False for non-intersecting lines but ", "        calculates/records the shortest segment between the two lines if that exists", "            ", "            :param ln_a: First line to intersect.", "            :type ln_a: Line", "            :param ln_b: Second line to intersect.", "            :type ln_b: Line", "            :result: Boolean value", "            :rtype: bool            ", "        \"\"\"    ", "        if ln_a.is_collinear(ln_b):", "            self.log = \"Lines are collinear, attempting to find intersection\"", "            return False", "            #return self._line_line_collinear(ln_a,ln_b) #TODO", "        if ln_a.is_parallel(ln_b, self.tol):", "            self.log = \"Lines are parallel, no intersection found.\"", "            return False   ", "        p0, v1 = ln_a.spt, ln_a.vec", "        q0, v2 = ln_b.spt, ln_b.vec       ", "        if v1.length2 < self.tol or v2.length2 < self.tol: ", "            self.log(\"Length of one of the lines is below the tolerance\")", "            return False", "        v_q0p0 = Vec(p0-q0)", "        v1dotv2 = v1.dot(v2)", "        denom = - v1.length2*v2.length2 + v1dotv2*v1dotv2", "        self.ta = (v2.length2*(v1.dot(v_q0p0)) - v1dotv2*(v2.dot(v_q0p0)))/denom", "        self.tb = (v1dotv2*(v1.dot(v_q0p0)) - v1.length2*(v2.dot(v_q0p0)))/denom", "        pa = ln_a.eval(self.ta)", "        pb = ln_b.eval(self.tb)   ", "        ", "        if pa.is_equal(pb, self.tol) :", "            if type(ln_a) == Ray and self.ta < 0.0 : return False" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects two lines, returning False for non-intersecting lines but", "calculates/records the shortest segment between the two lines if that exists" ],
          "parameters" : {
            "ln_a" : "First line to intersect.\n    ",
            "ln_b" : "Second line to intersect.\n    "
          },
          "rtype" : "bool            ",
          "rvalue" : "Boolean value\n    ",
          "types" : {
            "ln_a" : "Line\n    ",
            "ln_b" : "Line\n    "
          }
        },
        "end" : 616,
        "name" : "_line_line",
        "start" : 585
      }, {
        "code" : [ "        \"\"\"Intersects two lines, returning False for any pair of non-intersecting lines", "            ", "            :param ln_a: First line to intersect.", "            :type ln_a: Line", "            :param ln_b: Second line to intersect.", "            :type ln_b: Line", "            :result: Boolean value", "            :rtype: bool", "            ", "        \"\"\"", "        #first three if blocks deal with special cases (lines are coplanar, collinear, parallel)", "        if not ln_a.is_coplanar(ln_b, self.tol):", "            self.log = \"Lines don't lie on same plane, no intersection found.\"", "            return False       ", "        if ln_a.is_collinear(ln_b):", "            self.log = \"Lines are collinear, attempting to find intersection\"", "            return False", "            #return self._line_line_collinear(ln_a,ln_b) #TODO", "        if ln_a.is_parallel(ln_b, self.tol):", "            self.log = \"Lines are parallel, no intersection found.\"", "            return False", "        ", "        #Everything that follows deals with the case where the intersection, if there is any, is a point", "        p0, v1 = ln_a.spt, ln_a.vec", "        q0, v2 = ln_b.spt, ln_b.vec    ", "        if v1.length2 < self.tol or v2.length2 < self.tol: ", "            self.log(\"Length of one of the lines is below the tolerance\")", "            return False", "        n_vec = v1.cross(v2)", "        v2_perp = v2.cross(n_vec)", "        v_q0p0 = Vec(p0-q0)", "        #parameter of intersection along ln_a", "        self.ta = -v2_perp.dot(v_q0p0)/(v2_perp.dot(v1))", "        v1_perp = v1.cross(n_vec)", "        #parameter of intersection along ln_b", "        self.tb = v1_perp.dot(v_q0p0)/(v1_perp.dot(v2))", "        if type(ln_a) == Ray and self.ta < 0.0 : return False", "        if type(ln_b) == Ray and self.tb < 0.0 : return False  ", "        if type(ln_a) == Segment and (self.ta < 0.0 or self.ta > 1.0) : return False", "        if type(ln_b) == Segment and (self.tb < 0.0 or self.tb > 1.0) : return False", "        self.log = \"Intersection found.\"", "        self.append(ln_a.eval(self.ta))", "        return True", " " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects two lines, returning False for any pair of non-intersecting lines" ],
          "parameters" : {
            "ln_a" : "First line to intersect.\n",
            "ln_b" : "Second line to intersect.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value\n",
          "types" : {
            "ln_a" : "Line\n",
            "ln_b" : "Line\n"
          }
        },
        "end" : 673,
        "name" : "_line_line_SAVE",
        "start" : 630
      }, {
        "code" : [ "        \"\"\"Intersects two lines that are collinear", "            ", "            :param ln_a: First line to intersect.", "            :type ln_a: Line", "            :param ln_b: Second line to intersect.", "            :type ln_b: Line", "            :result: Boolean value", "            :rtype: bool", "            ", "            ", "            TODO - implemented, not yet incorporated", "        \"\"\"", " ", "        if not ln_a.is_collinear(ln_b):", "            self.log = \"Lines are not collinear\"", "            return False", "        if type(ln_a) == Line:", "            self.append(ln_b)", "            return True", "        if type(ln_b) == Line:", "            self.append(ln_a)", "            return True", "        if type(ln_a) == Ray and type(ln_b) == Ray:", "            #if rays overlap", "            if ln_a.contains(ln_b.spt) or ln_b.contains(ln_a.spt):", "                #if rays have same direction", "                if ln_a.vec.is_coincident(ln_b.vec):", "                    if ln_a.near(ln_b.spt)[1] > 0: self.append(Ray(ln_b.spt, ln_b.vec))", "                    if ln_b.near(ln_a.spt)[1] >= 0: self.append(Ray(ln_a.spt, ln_a.vec))", "                else:", "                    return Segment(ln_a.spt, ln_b.spt)", "                return True", "            else:", "                self.log = \"Rays don't overlap\"", "                return False    ", "        if type(ln_a) == Ray and type(ln_b) == Segment:", "            if ln_a.contains(ln_b.spt) and ln_a.contains(ln_b.ept):", "                self.append(ln_b)", "                return True", "            if ln_a.contains(ln_b.spt): ", "                self.append(Segment(ln_b.spt, ln_a.spt))", "                return True", "            if ln_a.contains(ln_b.ept): ", "                self.append(Segment(ln_a.spt, ln_b.ept))", "                return True", "            self.log = \"Ray and Segment don't overlap\"    ", "            return False", "        if type(ln_a) == Segment and type(ln_b) == Ray:", "            if ln_b.contains(ln_a.spt) and ln_b.contains(ln_a.ept): ", "                self.append(ln_a)", "                return True", "            if ln_b.contains(ln_a.spt):", "                self.append(Segment(ln_a.spt, ln_b.spt))", "                return True", "            if ln_b.contains(ln_a.ept): ", "                self.append(Segment(ln_b.spt, ln_a.ept))", "                return True", "            self.log = \"Segment and Ray don't overlap\" ", "            return False", "        if type(ln_a) == Segment and type(ln_b) == Segment:", "            if not ln_a.is_overlapping(ln_b):", "                self.log = \"Segments don't overlap\"", "                return False", "            ln_ext = ln_a.to_line()", "            pts = [ln_a.spt, ln_a.ept, ln_b.spt, ln_b.ept]", "            t_vals = sorted([ln_ext.near(p)[1] for p in pts])", "            self.append(Segment(ln_ext.eval(t_vals[1]), ln_ext.eval(t_vals[2])))", "            return True", "        return False", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Intersects two lines that are collinear" ],
          "parameters" : {
            "ln_a" : "First line to intersect.\n",
            "ln_b" : "Second line to intersect.\n"
          },
          "rtype" : "bool\n\n\nTODO - implemented, not yet incorporated",
          "rvalue" : "Boolean value\n",
          "types" : {
            "ln_a" : "Line\n",
            "ln_b" : "Line\n"
          }
        },
        "end" : 745,
        "name" : "_line_line_collinear",
        "start" : 676
      }, {
        "code" : [ "        \"\"\"| Intersects two circles.", "           | Upon success, the Intersector.dist property will be set to the distance between the pair of points of intersection.", "           | Dist of zero when circles intersect at just one point.", "            ", "           :param cir_a: First circle to intersect.", "           :type cir_a: Circle", "           :param cir_b: Second circle to intersect.", "           :type cir_b: Circle", "           :result: Boolean value.", "           :rtype: bool", "            ", "        \"\"\"", "        # TODO: this func currently only works on co-planar circles", "", "        if not cir_a.plane.is_coplanar( cir_b.plane ) : ", "            self.log = \"Circles are not coplanar. Try checking the normal direction of the circle base planes, as these must align in order to be coplanar.\"", "            return False", "        d = cir_a.origin.distance(cir_b.origin)", "        if d == 0 : ", "            self.log = \"Coplanar circles share a center point - no intersections possible.\"", "            return False", "        a = (cir_a.rad**2 - cir_b.rad**2 + d**2)/(2*d)", "        h2 = cir_a.rad**2 - a**2", "        if h2 < 0 : ", "            self.log = \"Coplanar circles do not intersect.\"", "            return False", "        self.dist = math.sqrt(h2)", "        pt = ( cir_b.origin - cir_a.origin ) * (a/d) + cir_a.origin", "        if self.dist == 0 : self.append(pt)", "        else:", "            vec = Vec(cir_a.origin,pt).cross(cir_a.plane.normal).normalized(self.dist)", "            self.append(pt - vec)", "            self.append(pt + vec)", "        return True", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Intersects two circles.", "| Upon success, the Intersector.dist property will be set to the distance between the pair of points of intersection.", "| Dist of zero when circles intersect at just one point." ],
          "parameters" : {
            "cir_a" : "First circle to intersect.\n",
            "cir_b" : "Second circle to intersect.\n"
          },
          "rtype" : "bool\n ",
          "rvalue" : "Boolean value.\n",
          "types" : {
            "cir_a" : "Circle\n",
            "cir_b" : "Circle\n"
          }
        },
        "end" : 782,
        "name" : "_circle_circle",
        "start" : 748
      } ],
      "documentation" : {
        "description" : [ "Intersection results class." ]
      },
      "end" : 782,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_intersection.py",
      "name" : "Intersector",
      "references" : {
        "classes" : {
          "Arc" : 2,
          "Bounds" : 1,
          "Circle" : 5,
          "Color" : 1,
          "EPSILON" : 1,
          "Intersector" : 9,
          "Interval" : 1,
          "Line" : 7,
          "LinearEntity" : 3,
          "PGon" : 2,
          "PLine" : 2,
          "Plane" : 3,
          "Point" : 3,
          "R" : 10,
          "RGon" : 2,
          "Ray" : 16,
          "Segment" : 22,
          "Vec" : 4,
          "Xform" : 1
        },
        "functions" : {
          "__getitem__" : 1,
          "__init__" : 1,
          "__len__" : 1,
          "_arc_plane" : 1,
          "_circle_circle" : 1,
          "_circle_plane" : 1,
          "_line_circle" : 1,
          "_line_line" : 1,
          "_line_line_SAVE" : 1,
          "_line_line_collinear" : 1,
          "_line_pgon" : 1,
          "_line_plane" : 1,
          "_pgon_plane" : 1,
          "_plane_plane" : 1,
          "_pline_plane" : 1,
          "_ray_plane" : 1,
          "_seg_plane" : 1,
          "append" : 1,
          "clear" : 1,
          "intersect" : 1,
          "of" : 1,
          "results" : 1
        }
      },
      "start" : 7
    },
    "923d555b-0c10-4f86-864f-e843730bbdfd" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def circle(t):", "    # set x and y values for the Point", "    c = math.cos(t)", "    s = math.sin(t)", "    # create a Point, and translate it with a Vec", "    pt_out = Point(rad*c, rad*s)+Vec(center)", "    # return the Point", "    return pt_out", "     " ],
          "end" : 27,
          "start" : 17
        },
        "description" : "\nMethod that generates Points describing a Circle, based on t values.\n[noprint] \n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "def rectangle(t):", "    # set x and y values for the Point", "    c = math.cos(t)", "    s = math.sin(t)", "    alpha = math.atan(rec_h/rec_w)", "    pi = math.pi", "    pi_over_2 = 0.5*pi", "    # if t is larger than 0 and smaller than alpha:", "    if (t >=0) and (t < alpha):", "        # the Point is on the right side of the CS", "        l_coord = 0.5*rec_w*s/c", "        pt_out = Point(rec_w/2, l_coord)", "    # elif t is larger than alpha and smaller than pi-alpha:", "    elif (t >= alpha) and (t < pi-alpha):", "        # the Point is on the right side of the CS", "        l_coord = 0.5*rec_h*c/s", "        pt_out = Point(l_coord, rec_h/2)", "    # t is larger than pi-alpha and smaller than pi+alpha:", "    elif (t >= pi-alpha) and (t < pi + alpha):", "        # the Point is on the left side of the CS", "        l_coord = -0.5*rec_w*s/c", "        pt_out = Point(-rec_w/2, l_coord)", "    # t is larger than pi+alpha and smaller than pi-alpha:", "    elif (t >= pi + alpha) and (t < 2*pi - alpha):", "        # the Point is on the left side of the CS", "        l_coord = -0.5*rec_h*c/s", "        pt_out = Point(l_coord, -rec_h/2)", "    # t is larger than pi-alpha and smaller than two pi:", "    elif (t >= 2*pi-alpha) and (t <= 2*pi):", "        # the Point is on the right side of the CS", "        l_coord = 0.5*rec_w*s/c", "        pt_out = Point(rec_w/2, l_coord)", "    # else: its not valid", "    else:", "        print \"Out-of-bounds!\"   ", "    # return the Point for a rectangle", "    return pt_out", "    " ],
          "end" : 69,
          "start" : 31
        },
        "description" : "\nA Carefully Parametrized Rectangle\nMethod that generates Points describing a rectangle, based on t values. \n",
        "end" : 31,
        "start" : 28
      }, {
        "code" : {
          "content" : [ "def func(u,v):", "    # interpolate between Circle and rectangle functions", "    pt_out = circle(u)*(1-v) + rectangle(u)*v ", "    # assign a height to the Point", "    pt_out.z = math.sin(v*math.pi)*height", "    # return the translated Point", "    return pt_out", "", "" ],
          "end" : 81,
          "start" : 73
        },
        "description" : "\nGreat Court Roof Surface\nMethod that interpolated between 2 Curve functions, and assign a Z height to the Point. \n",
        "end" : 73,
        "start" : 70
      } ],
      "documentation" : {
        "description" : [ "4.07.F01a", "Given a roof height, and a center, produce a triangulated Mesh that approximates the great court roof with a modified center position." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Great Court Roof Relaxation/4.07.F01a.py",
      "name" : "4.07.F01a.py",
      "references" : {
        "classes" : {
          "Point" : 6,
          "Vec" : 1
        }
      },
      "required" : [ "height (float) A maximum height.", "center (Vec) An offset Vec." ],
      "result" : [ "surf (Surface) A Surface interpolated between a Circle and a rectangle." ]
    },
    "92da57c6-f031-41f4-820e-bce66bbdd9db" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def ellipse_tan(t):", "    c = math.cos(2*math.pi*t)", "    s = math.sin(2*math.pi*t)", "    pt_a = Point(len_x*c, len_y*s)", "    ", "    c = math.cos(2*math.pi*(t+nudge))", "    s = math.sin(2*math.pi*(t+nudge))", "    pt_b = Point(len_x*c, len_y*s)", "    ", "    vec = Vec(pt_a,pt_b).normalized()", "    return pt_a,vec", "    " ],
          "end" : 27,
          "start" : 15
        },
        "description" : "\nEllipse Function\nReturns a point and a tangent vector on an ellipse\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "pt,vec = ellipse_tan(t)", "tan_ray = Ray(pt,vec)", "", "#crs_vec = Vec(0,1)", "#crs_vec = Vec(1,0)", "#crs_vec = Vec(Point(), pt)", "#crs_vec = vec.cross(Vec(0,0,1))", "", "", "perp_vec = vec.cross(crs_vec).normalized()", "perp_ray = Ray(pt,perp_vec)", "" ],
          "end" : 42,
          "start" : 31
        },
        "description" : "\nLooks at the direction of the resulting cross product between the tangent vector and a vector in the plane\n[noprint]\n",
        "end" : 31,
        "start" : 28
      } ],
      "documentation" : {
        "description" : [ "3.02.E01b", "todo" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/Cross Products/3.02.E01b.py",
      "name" : "3.02.E01b.py",
      "references" : {
        "classes" : {
          "Point" : 2,
          "Ray" : 2,
          "Vec" : 1
        }
      }
    },
    "940c41a6-1e57-47ad-8a61-fbbb7f91ab23" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Tile(object):", "    def __init__(self, shape, sides):", "        self.shape = shape", "        self.basis = shape.basis", "        self.sides = sides", "        self.tool_width = 1/8", "    ", "    def tool_path(self, side, offset=False):", "        # create a base plane for toolpaths", "        base_plane = Plane(self.basis.origin, self.basis.z_axis)", "        # create the plane for the adjoining side", "        int_plane = Plane(self.sides[side].origin, self.sides[side].z_axis)", "        # set direction vector for toolpaths", "        vec = Vec(self.basis.z_axis + self.sides[side].z_axis).normalized(0.3)", "        # if the current face has four sides:", "        if len(self.sides) == 4:", "            edge = self.shape.edges[-side-1]", "        # if the current face is a prism cap:", "        else:", "            edge = self.shape.edges[side-1]", "        # calculate the spacing between toolpaths", "        teeth = int(edge.length/self.tool_width)", "        xsec = Intersector()", "        # if the two planes intersect:", "        if xsec.of(base_plane, int_plane):", "            # create finger joint along intersecting segment ", "            pts = [edge.eval(i) for i in Interval().divide(teeth, True)]", "            return [[Segment(pt, pt+vec) for pt in pts], edge]", "" ],
          "end" : 48,
          "start" : 19
        },
        "description" : "\nTile Toolpather Class\nCreates toolpaths for finger joint-type connections along edges of flat polygonal tiles\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "   ", "tiles = []", "new_shell = shell(pl_a, pl_b, height, trunc)", "# for every face:", "for s in new_shell:", "    #  create a tile object", "    tiles.append(Tile(s, s.edge_planes))", "# create toolpaths for joint along given side", "paths = tiles[tile].tool_path(side)", "" ],
          "end" : 61,
          "start" : 52
        },
        "description" : "\nSand Dollar Shell Toolpaths\nCreates a shell with tiles that have toolpaths for connections along edges\n",
        "end" : 52,
        "start" : 49
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Sanddollar/4.05.F03c.py",
      "name" : "4.05.F03c.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "Interval" : 1,
          "Plane" : 2,
          "Segment" : 1,
          "Tile" : 2,
          "Vec" : 1
        }
      }
    },
    "969ff47a-23c5-41f9-bcf5-faa3db768efe" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# initialize an empty container for the Points", "pts = []", "# for every ri value in an Interval:", "for ri in Interval().divide(res,include_last=True):", "    # for every gi value in an Interval:", "    for gi in Interval().divide(res,include_last=True):", "        # for every bi value in an Interval:", "        for bi in Interval().divide(res,include_last=True):", "            # create a Surface from those three values", "            surf = make_surf(ri,gi,bi)", "            # check the fitness of the current Surface", "            fit = fac_area(surf)/flr_area(surf)", "            clr = Color(ri,gi,bi)# surface color", "            # create a Point at the corresponding location ", "            pt = Point(ri,gi,bi)", "            # set its Color", "            pt.set_color(clr)", "            pt_weight = 0", "            # if the value is larger than 0:", "            if fit > 0 : ", "                # change the weight of the Point based on fitness", "                int1 = Interval(1.5,2.5)", "                int2 = Interval(7,0)", "                pt_weight = Interval.remap(min([fit,2.5]),int1,int2)", "            # add a weighted Point to the list", "            pts.append(pt.set_weight(pt_weight))" ],
          "end" : 44,
          "start" : 18
        },
        "description" : "\nBrute Force Floor-to-Facade Area Optimization\nGiven Surface, facade area, and floor area functions, look for the optimal floor to facade area ratio, and visualize the results\n",
        "end" : 18,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "4.07.L02c", "Given Surface, facade area, and floor area functions, perform a brute force search of the solution space of cylindrical facade shapes that produces the optimal facade area to floor area ratio." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Floor-Facade Area Optimization/4.07.L02c.py",
      "name" : "4.07.L02c.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Interval" : 6,
          "Point" : 1
        }
      },
      "required" : [ "make_surf (function) A function that generates cylindrical Surfaces.", "fac_area (function) A function that calculates facade area.", "flr_area (function) A function that calculates floor area.", "res (int) Resolution of the solution space grid to compute." ],
      "result" : [ "pts ([Point]) A Point visualization of the weighted values of every possibility within the solution space." ]
    },
    "96a16265-1aaa-47ab-9470-2e4c1f8b00c5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def leastSquaresLine(pts_in):", "    # create and set variables to 0", "    x_m, y_m, xsq_m, xy_m = 0,0,0,0", "    ", "    # for every point in pts_in:", "    for pt in pts_in :", "        # create the average of all the variables", "        x_m += pt.x/len(pts_in)", "        y_m += pt.y/len(pts_in)", "        xsq_m += pt.x**2/len(pts_in)", "        xy_m += pt.x*pt.y/len(pts_in)", "    ", "    # if the value is different than the square of x_m: ", "    if (xsq_m != x_m**2):", "        # find u_ls and p_ls", "        m = (xy_m - x_m*y_m)/(xsq_m - x_m**2)", "        y_coeff = y_m - m*x_m", "        p_ls = Point(0, y_coeff)", "        u_ls = Vec(1, m).normalized()", "    # else:", "    else:", "        p_ls = Point(x_m, 0)", "        u_ls = Vec(0,1)", "    ", "    d_min = Vec(pts_in[0]-p_ls).dot(u_ls)", "    d_max = d_min", "    # for every point in pts_in:", "    for pt in pts_in:", "        d = Vec(pt - p_ls).dot(u_ls)", "        if (d > d_max): d_max = d", "        elif (d < d_min): d_min = d", "    # start and end Points for the Segment", "    start_pt = p_ls + u_ls*d_min", "    end_pt = p_ls + u_ls*d_max", "    return Segment(start_pt, end_pt)", "" ],
          "end" : 51,
          "start" : 16
        },
        "description" : "\nBest Fit by Least Squares\nReturns a best fit Segment defined by ordinary least squares.\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L06a", "Methods that returns a best fit Segment defined by ordinary least squares." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Best Fit/4.07.L06a.py",
      "name" : "4.07.L06a.py",
      "references" : {
        "classes" : {
          "Point" : 2,
          "Segment" : 1,
          "Vec" : 4
        }
      },
      "required" : [ "pts_in ([Point]) A list of Points." ],
      "result" : [ "(seg) A segment." ]
    },
    "96b29541-44b3-4a97-a68d-04d507bec376" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# create an Interval with the size of a sheet ", "sheet_size = Interval(w,h)", "# sort the PGons", "shapes_sorted = sort_polygons(rec)", "# Bin the PGons", "sheets_filled = bin_polygons(shapes_sorted, sheet_size)", "", "# for every sheet in the sheets Binned:", "for sheet in sheets_filled:", "    pt = Point(sheet_size.a/2,sheet_size.b/2)", "    # create a PGon sheet", "    new_sheet = PGon.rectangle(pt,sheet_size.a,sheet_size.b)", "    # get the binned PGons", "    poly = sheet.get_polygons()", "    bnds = []", "    # for every polygon in poly:", "    for p in poly:", "        # get bound PGon", "        r = p.bounds.to_polyline()", "        r.basis = p.basis", "        bnds.append(r)" ],
          "end" : 40,
          "start" : 20
        },
        "description" : "\nPack Polygons by Bounding Box\nGiven a sheet size and a list of PGons, pack the PGons onto a number of sheets.\n",
        "end" : 20,
        "start" : 17
      } ],
      "documentation" : {
        "description" : [ "4.05.L01e", "Given a set of PGons of random sizes, fit them onto Bins with a standard size." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Packing/4.05.L01e.py",
      "name" : "4.05.L01e.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "PGon" : 1,
          "Point" : 1
        }
      },
      "required" : [ "Bin (Bin) Bin class for packing", "w (float) Width of the Bin", "h (float) Height of the Bin", "shapes  ([PGon]) List of PGons to be placed onto the sheets." ],
      "result" : [ "new_sheet (PGon) Sheet PGon.", "packed_item (PGon) PGon placed onto the sheets." ]
    },
    "97df14fe-b884-42aa-9603-4d4d42ef0505" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def panel_cut(pgon, panel_width, ei) :", "    # orient the PGon to the chosen edge ", "    pgon.rotate(ei)", "    # choose the initial edge and adjacent edges", "    edge = pgon.edges[0]", "    lhedge = pgon.edges[1]", "    rhedge = pgon.edges[-1]", "    # define a the number of edges not being used ", "    rem_edge = len(pgon.edges)-2", "    ", "    # create an Intersector ", "    xsec = Intersector()", "    # create a vector to offset the edge ", "    off_vec = edge.vec.cross(Vec(edge.spt,pgon.centroid)).cross(edge.vec)", "    # create a new Line by translating the original  ", "    line = Line(edge.spt + off_vec.normalized(panel_width), edge.vec)", "    lh_step = False", "    rh_step = False", "    p0, p1 = None, None", "    ", "    # if there is an intersection between edges: ", "    if xsec.of(line,lhedge) and 0 <= xsec.tb <= 1 : ", "        # define an intersection Point", "        p0 = xsec[0]", "    else :", "        # subtract one number to the remaining edges counter", "        rem_edge -= 1", "        # if there are no remaining edges: return False", "        if rem_edge == 0 : return [False, False, False]", "        lhedge = pgon.edges[2]", "        lh_step = True", "        # if there is an intersection between edges:", "        if xsec.of(line,lhedge) and 0 <= xsec.tb <= 1 : ", "            # define an intersection Point", "            p0 = xsec[0]", "    # if there is an intersection between edges: ", "    if xsec.of(line,rhedge) and 0 <= xsec.tb <= 1 : \\", "        # define an intersection Point", "        p1 = xsec[0]", "    else :", "        rem_edge -= 1", "        # if there are no remaining edges: return False", "        if rem_edge == 0 : return [False, False, False]", "        rhedge = pgon.edges[-2]", "        rh_step = True", "        # if there is an intersection between edges:", "        if xsec.of(line,rhedge) and 0 <= xsec.tb <= 1 : ", "            # define an intersection Point", "            p1 = xsec[0]", "    # if there are no remaining panels to be cut: return", "    if p0 == None or p1 == None : return [False, False, False]", "    ", "    # create a list with the Points for the panel", "    pts = pgon.pts ", "    panelpts = [p0,p1,pts[0],pts[1]]", "    if lh_step and not rh_step: panelpts =  [pts[0],pts[1],pts[2],p0,p1]", "    if rh_step and not lh_step: panelpts = [pts[-1],pts[0],pts[1],p0,p1]", "    if lh_step and rh_step : panelpts = [pts[-1],pts[0],pts[1],pts[2],p0,p1]", "    # create a PGon with the list of Points", "    panel = PGon(panelpts)", "    ", "    # set up the next PGon ", "    npgonpts = [p0,p1]", "    # for every edge number in the remaining edges:", "    for r in range(rem_edge) : ", "        # add a number to the edge number", "        r+=1", "        # if there is a rh_step: add a number to the edge number", "        if rh_step : r+=1", "        # add the last vertice to the list of Points", "        npgonpts.append(pts[-r])", "    # create a PGon with the list of Points", "    npgon = PGon(npgonpts)", "    # go back to global orientation", "    npgon.rotate(-ei)", "    return [panel, npgon, True]", " " ],
          "end" : 96,
          "start" : 18
        },
        "description" : "\nMethod to recursively subdivide a panel based on material width.\n[pseudo]\n",
        "end" : 18,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "", "# create an empty list for the panels     ", "panels = []", "group = [True,pgon,True]", "", "# while there are edges remaining:", "while group[2] == True:", "    # with a PGon, width and edge number, cut the panel", "    group = panel_cut(p_gon, mat_width, edg_num) ", "    # append the new panel to the list", "    panels.append(group[0])", "    # define the p_gon as the remaining part of the PGon", "    p_gon = group[1]", "" ],
          "end" : 112,
          "start" : 99
        },
        "description" : "\nPanel Subdivision\n",
        "end" : 99,
        "start" : 97
      } ],
      "documentation" : {
        "description" : [ "4.03.F02b", "Methods to recursively subdivide a panel based on material width." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Dennis Shelden/4.03.F02b.py",
      "name" : "4.03.F02b.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "Line" : 1,
          "PGon" : 2,
          "Vec" : 1
        }
      },
      "required" : [ "p_gon (PGon) Panel to subdivide.", "mat_width (float) Material width.", "edg_num (int) Initial edge of the PGon." ],
      "result" : [ "ret [PGons] Sub panels." ]
    },
    "981c6345-899d-4358-a164-8f1cb78dd8f6" : {
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/Loose Examples/2.XX.XX - Spirograph/2.E02a.py",
      "name" : "2.E02a.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 1
        }
      }
    },
    "9976cd54-4fe1-4c9b-925e-5240a6dff1e5" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Evaluates a point in Basis coordinates and returns a Vec containing the coordinates of a corresponding Point defined in World coordinates.", "        ", "            .. warning:: This method is not yet implemented. ", "        \"\"\"", "        raise NotImplementedError(\"Evalutate not implemented.    I am a BAD basis!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates a point in Basis coordinates and returns a Vec containing the coordinates of a corresponding Point defined in World coordinates.", ".. warning:: This method is not yet implemented." ]
        },
        "end" : 141,
        "name" : "eval",
        "start" : 136
      }, {
        "code" : [ "        \"\"\" Evaluates a point in World coordinates and returns a Vec containing the coordinates of a corresponding Point defined in Basis coordinates", "            ", "            .. warning:: This method is not yet implemented. ", "            ", "        \"\"\"", "        raise NotImplementedError(\"Devalutate not implemented.    I am a BAD basis!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates a point in World coordinates and returns a Vec containing the coordinates of a corresponding Point defined in Basis coordinates", ".. warning:: This method is not yet implemented." ]
        },
        "end" : 149,
        "name" : "deval",
        "start" : 143
      } ],
      "documentation" : {
        "description" : [ "A base class for anything that wants to call itself a basis. Bases must implement the following methods:" ]
      },
      "end" : 149,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "Basis",
      "references" : {
        "classes" : {
          "Basis" : 1
        },
        "functions" : {
          "deval" : 1,
          "eval" : 1
        }
      },
      "start" : 131
    },
    "99b5a289-80b8-4b6f-a87f-eb5187f404ec" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_cs.py",
      "definitions" : [ {
        "code" : [ "        self.origin = pt", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 394,
        "name" : "__init__",
        "start" : 393
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 394,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_cs.py",
      "name" : "ShearedCS",
      "references" : {
        "classes" : {
          "Basis" : 1,
          "Geometry" : 1,
          "Point" : 1,
          "ShearedCS" : 1,
          "Vec" : 2
        },
        "functions" : {
          "__init__" : 1
        }
      },
      "start" : 392
    },
    "9a60c79a-d278-4651-805d-4c0bb0ccf68f" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_plane.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Plane constructor.", "", "            :param point: Base point for a plane. ", "            :type point: Point", "            :param normal: Normal direction of the new Plane. Defaults to Vec(0,0,1).", "            :type normal: Vec", "            :result: Plane object.", "            :rtype: Plane", "            ", "            ::", "            ", "                pln_1=Plane(Point(0,0,0), Vec(1,1,1))", "                ", "                pln_2=Plane(Point(0,0,0), Point(0,1,1), Point(1,0,1))", "        \"\"\"", "        if normal.length == 0 : raise GeometricError(\"Cannot construct a plane with a normal vector of length zero: %s\"%(normal))", "        # super(Plane,self).__init__(point) Plane class used to override Vec class", "        o = Vec(point)", "        self.x = o.x", "        self.y = o.y", "        self.z = o.z", "        self._vec = normal.normalized()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Plane constructor." ],
          "parameters" : {
            "normal" : "Normal direction of the new Plane. Defaults to Vec(0,0,1).\n",
            "point" : "Base point for a plane. \n"
          },
          "rtype" : "Plane\n\n",
          "rvalue" : "Plane object.\n",
          "types" : {
            "normal" : "Vec\n",
            "point" : "Point\n"
          }
        },
        "end" : 34,
        "name" : "__init__",
        "start" : 12
      }, {
        "code" : [ "    def d(self):", "        \"\"\" The distance of this plane from the origin.", "            ", "            :result: Distance from origin.", "            :rtype: float", "            ", "            ::", "                ", "                pln_1.d", "        ", "        ", "        \"\"\"", "        from .dc_line import Line", "        line = Line(self.origin, self._vec)", "        t = line.near(Point())[1]", "        tvec = self._vec*-t", "        return tvec.length", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "The distance of this plane from the origin." ],
          "rtype" : "float\n\n",
          "rvalue" : "Distance from origin.\n"
        },
        "end" : 53,
        "name" : "d",
        "start" : 36
      }, {
        "code" : [ "        \"\"\" Overloads the equal **(==)** operator for Plane identity.", "        ", "            :param other: Plane to be compared.", "            :type other: Plane", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"    ", "        return self.is_equal(other)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the equal **(==)** operator for Plane identity." ],
          "parameters" : {
            "other" : "Plane to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n"
          }
        },
        "end" : 64,
        "name" : "__eq__",
        "start" : 55
      }, {
        "code" : [ "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 66,
        "name" : "__repr__",
        "start" : 66
      }, {
        "code" : [ "    def normal(self): ", "        \"\"\" Returns the plane's normal.", "", "            :result: Plane's normal.", "            :rtype: Vec", "            ", "            ::", "            ", "                pln_1.normal", "        \"\"\"", "        return self._vec", "    @normal.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the plane's normal." ],
          "rtype" : "Vec\n\n",
          "rvalue" : "Plane's normal.\n"
        },
        "end" : 79,
        "name" : "normal",
        "start" : 68
      }, {
        "code" : [ "    def normal(self, v): ", "        \"\"\" Sets the plane's normal.", "", "            :param v: Sets the normal of the plane .", "            :type v: Vec", "            :result: Plane object.", "            :rtype: Plane", "        \"\"\"", "        self._vec = v.normalized()", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the plane's normal." ],
          "parameters" : {
            "v" : "Sets the normal of the plane .\n"
          },
          "rtype" : "Plane",
          "rvalue" : "Plane object.\n",
          "types" : {
            "v" : "Vec\n"
          }
        },
        "end" : 89,
        "name" : "normal",
        "start" : 80
      }, {
        "code" : [ "    def origin(self): ", "        \"\"\" Returns the plane's origin point.", "", "            :result: Plane's origin point.", "            :rtype: Point", "            ", "            ::", "            ", "                pln_1.origin", "        \"\"\"", "        return Point(self.x,self.y,self.z)", "    @origin.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the plane's origin point." ],
          "rtype" : "Point\n\n",
          "rvalue" : "Plane's origin point.\n"
        },
        "end" : 102,
        "name" : "origin",
        "start" : 91
      }, {
        "code" : [ "    def origin(self, pt): ", "        \"\"\" Sets the plane's origin point.", "", "            :param pt: Sets the origin point of the plane.", "            :type pt: Point", "            :result: Plane object.", "            :rtype: Plane", "        \"\"\"", "        self.x, self.y, self.z = point.tup", "        " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the plane's origin point." ],
          "parameters" : {
            "pt" : "Sets the origin point of the plane.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "Plane object.\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 112,
        "name" : "origin",
        "start" : 103
      }, {
        "code" : [ "    def pt(self): ", "        \"\"\" Returns the plane's origin point.", "", "            :result: Plane's origin point.", "            :rtype: Point", "            ", "            ::", "            ", "                pln_1.origin", "        \"\"\"", "        return Point(self.x,self.y,self.z)", "    @pt.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the plane's origin point." ],
          "rtype" : "Point\n\n",
          "rvalue" : "Plane's origin point.\n"
        },
        "end" : 125,
        "name" : "pt",
        "start" : 114
      }, {
        "code" : [ "    def pt(self, point): ", "        \"\"\" Sets the plane's origin point.", "", "            :param pt: Sets the origin point of the plane.", "            :type pt: Point", "            :result: Plane object.", "            :rtype: Plane", "        \"\"\"", "        self.x, self.y, self.z = point.tup", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the plane's origin point." ],
          "parameters" : {
            "pt" : "Sets the origin point of the plane.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "Plane object.\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 135,
        "name" : "pt",
        "start" : 126
      }, {
        "code" : [ "        \"\"\" Returns True if the given Plane shares a reference Point and normal direction with this Plane", "        ", "            :param other: Plane to be compared.", "            :type other: Plane", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pln.is_equal(other_pln)", "        \"\"\"", "        return self.origin.is_equal(other.origin,pt_tol) and self.normal.is_coincident(other.normal,vec_tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Plane shares a reference Point and normal direction with this Plane" ],
          "parameters" : {
            "other" : "Plane to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float\n"
          }
        },
        "end" : 153,
        "name" : "is_equal",
        "start" : 137
      }, {
        "code" : [ "        \"\"\" Returns True if the given Plane shares any contained Point, and if the two normal directions are coincident", "        ", "            :param other: Plane to be compared.", "            :type other: Plane", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float          ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pln.is_coincident(other_pln)", "        \"\"\"   ", "        if self.normal.is_coincident(other.normal,vec_tol): ", "            if pt_tol is None: pt_tol = EPSILON", "            if self.near(other.origin)[2] <= pt_tol and other.near(self.origin)[2] <= pt_tol: return True", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Plane shares any contained Point, and if the two normal directions are coincident" ],
          "parameters" : {
            "other" : "Plane to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float          \n"
          }
        },
        "end" : 174,
        "name" : "is_coincident",
        "start" : 155
      }, {
        "code" : [ "        \"\"\" Returns True if the given Plane shares any contained Point, and if the two normal directions are parallel", "        ", "            :param other: Plane to be compared.", "            :type other: Plane", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float          ", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_pln.is_coplanar(other_pln)", "        \"\"\"   ", "        if self.normal.is_parallel(other.normal,vec_tol): ", "            if pt_tol is None: pt_tol = EPSILON", "            if self.near(other.origin)[2] <= pt_tol and other.near(self.origin)[2] <= pt_tol: return True", "        return False        ", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Plane shares any contained Point, and if the two normal directions are parallel" ],
          "parameters" : {
            "other" : "Plane to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float          \n"
          }
        },
        "end" : 195,
        "name" : "is_coplanar",
        "start" : 176
      }, {
        "code" : [ "        \"\"\" Returns True if the normal directions of this Plane and the given Plane are parallel", "", "            :param other: Plane to be compared.", "            :type other: Plane", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float          ", "            :result: Boolean result of comparison.", "            :rtype: bool", "        ", "            ", "        \"\"\"", "        return self.normal.is_parallel(other.normal,vec_tol)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the normal directions of this Plane and the given Plane are parallel" ],
          "parameters" : {
            "other" : "Plane to be compared.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n",
            "vec_tol" : "float          \n"
          }
        },
        "end" : 209,
        "name" : "is_parallel",
        "start" : 197
      }, {
        "code" : [ "        \"\"\" Returns True if the normal directions of this Plane and the given Plane are perpendicular", "           ", "            :param other: Plane to be compared.", "            :type other: Plane", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float          ", "            :result: Boolean result of comparison.", "            :rtype: bool", "                     ", "        \"\"\"", "        return self.normal.is_perpendicular(other.normal,vec_tol)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the normal directions of this Plane and the given Plane are perpendicular" ],
          "parameters" : {
            "other" : "Plane to be compared.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n         ",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Plane\n",
            "vec_tol" : "float          \n"
          }
        },
        "end" : 222,
        "name" : "is_perpendicular",
        "start" : 211
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given Plane, its t value, and the distance from the given point to the near point.", "       ", "            :param p: Point to look for a near point on the plane.", "            :type p: Point", "            :result: Tuple of near point on plane, t value and distance from given point to near point.", "            :rtype: (Point, float, float)", "            ", "            ::", "                ", "                pln_1.near(Point(1,1,1))", "        \"\"\"", "        from .dc_line import Line", "        line = Line(self.origin, self._vec)", "        t = line.near(p)[1]", "        tvec = self._vec*-t", "        point = p + tvec", "        return (point,t,tvec.length)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given Plane, its t value, and the distance from the given point to the near point." ],
          "parameters" : {
            "p" : "Point to look for a near point on the plane.\n"
          },
          "rtype" : "(Point, float, float)\n\n",
          "rvalue" : "Tuple of near point on plane, t value and distance from given point to near point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 242,
        "name" : "near",
        "start" : 225
      }, {
        "code" : [ "        \"\"\" Returns the closest point to the point provided on a given Plane.", "       ", "            :param p: Point to look for a near Point on the Plane.", "            :type p: Point", "            :result: Near point on Plane.", "            :rtype: Point", "        \"\"\"", "        return self.near(p)[0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point to the point provided on a given Plane." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the Plane.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Near point on Plane.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 252,
        "name" : "near_pt",
        "start" : 244
      }, {
        "code" : [ "        \"\"\" Returns True if the given Point lines in the Plane within a given tolerance", "", "            :param other: Point to be appraised.", "            :type other: Point             ", "            :param tol: Tolerance of point projection.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_plane.contains(pt)", "        \"\"\"", "        if tol is None: tol = EPSILON", "        if self.near(pt)[2] < tol: return True", "        return False    ", " " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Point lines in the Plane within a given tolerance" ],
          "parameters" : {
            "other" : "Point to be appraised.\n",
            "tol" : "Tolerance of point projection.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Point             \n",
            "tol" : "float\n"
          }
        },
        "end" : 270,
        "name" : "contains",
        "start" : 254
      }, {
        "code" : [ "        \"\"\" Returns a CS aligned with this Plane, with the x-axis oriented toward the given guide Vec.", "       ", "            :param guide_vec: Vec that guides the orientation of the x-axis of the resulting CS.", "            :type p: Vec", "        \"\"\"", "        from .dc_cs import CS", "        y_vec = self.normal.cross(guide_vec)", "        x_vec = self.normal.cross(y_vec).inverted()", "        return CS(self.origin, x_vec, y_vec)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a CS aligned with this Plane, with the x-axis oriented toward the given guide Vec." ],
          "parameters" : {
            "guide_vec" : "Vec that guides the orientation of the x-axis of the resulting CS.\n"
          },
          "types" : {
            "p" : "Vec"
          }
        },
        "end" : 282,
        "name" : "to_cs",
        "start" : 273
      }, {
        "code" : [ "    def from_pts(a,b=None,c=None):", "        \"\"\" Constructs plane from points. A plane cannot be constructed from collinear points.", "            ", "            :param pt_a: First point.", "            :type pt_a: Point", "            :param pt_b: Second point.", "            :type pt_b: Point", "            :param pt_c: Third point.", "            :type pt_c: Point", "            :result: Plane object.", "            :rtype: Plane", "            ", "            ::", "            ", "                pln_2=Plane(Point(0,0,0), Point(0,1,1), Point(1,0,1))", "        \"\"\"", "        pt_a, pt_b, pt_c = a,b,c", "        if b is None and c is None:", "            pt_a, pt_b, pt_c = a[0],a[1],a[2]", "        ", "        pt = Point.centroid([pt_a,pt_b,pt_c])", "        try:", "            nml = Vec(pt_a,pt_b).cross(Vec(pt_a,pt_c))", "        except:", "            raise GeometricError(\"Cannot create a Plane from collinear Points.\")", "        return Plane(pt,nml)", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs plane from points. A plane cannot be constructed from collinear points." ],
          "parameters" : {
            "pt_a" : "First point.\n",
            "pt_b" : "Second point.\n",
            "pt_c" : "Third point.\n"
          },
          "rtype" : "Plane\n\n",
          "rvalue" : "Plane object.\n",
          "types" : {
            "pt_a" : "Point\n",
            "pt_b" : "Point\n",
            "pt_c" : "Point\n"
          }
        },
        "end" : 311,
        "name" : "from_pts",
        "start" : 285
      } ],
      "documentation" : {
        "description" : [ "a simple plane class" ]
      },
      "end" : 311,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_plane.py",
      "name" : "Plane",
      "references" : {
        "classes" : {
          "CS" : 1,
          "EPSILON" : 3,
          "Geometry" : 1,
          "Line" : 2,
          "Plane" : 2,
          "Point" : 5,
          "Vec" : 4
        },
        "functions" : {
          "__eq__" : 1,
          "__init__" : 1,
          "__repr__" : 1,
          "contains" : 1,
          "d" : 1,
          "from_pts" : 1,
          "is_coincident" : 1,
          "is_coplanar" : 1,
          "is_equal" : 1,
          "is_parallel" : 1,
          "is_perpendicular" : 1,
          "near" : 1,
          "near_pt" : 1,
          "normal" : 2,
          "origin" : 2,
          "pt" : 2,
          "to_cs" : 1
        }
      },
      "start" : 7
    },
    "9b26c70f-db44-4bfc-b955-cbd16ef0a12c" : {
      "documentation" : {
        "description" : [ "3.09.E02c", "Construct a hyperboloid tower as a ruled surface" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Classical Surfaces/3.09.E02c.py",
      "name" : "3.09.E02c.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Point" : 1,
          "Segment" : 1,
          "Surface" : 1,
          "Vec" : 3,
          "Xform" : 1
        }
      },
      "required" : [ "length of lines (float)", "radius of base circle (float)", "angle of twist (float)", "u_divs (int)", "v_divs (int)" ],
      "result" : [ "a hyperboloid surface (surface)" ]
    },
    "9bc4e48e-eb89-48d3-be5f-e272e0434cef" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "res = 100", "pts = []", "off = (pi * 2 / hump_count) * t", "twopi = Interval.twopi()", "for y in Interval().divide(res,True):", "    pt_a = seg_a.eval(y)", "    pt_b = seg_b.eval(y)", "    theta = twopi.eval(y)+off", "    tt = (1.0 + sin(theta*hump_count))/2", "    pts.append(Point.interpolate(pt_a,pt_b,tt))", "    ", "chain = []", "for n in range(len(pts)-1): ", "    chain.append(Segment(pts[n],pts[n+1]))", "", "   " ],
          "end" : 34,
          "start" : 19
        },
        "description" : "\nWavy Chain\nChain is bound between two line segments\n",
        "end" : 19,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "3.03.E01a", "Creates a wavy chain bound between two line segments. The chain is made up of connected line segments." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Line/Guilloche/3.03.E01a.py",
      "name" : "3.03.E01a.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Point" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "seg_a (Segment) line segment representing a boundary for the chain", "seb_b (Segment) line segment representing the other boundary for the chain", "hump_count (int) number of complete waves", "t (float) determines the offset of the initial wave" ],
      "result" : [ "chain ([Segment]) connected line segments" ]
    },
    "9d41c4cb-c5f9-4276-8808-6d34e6cce6e1" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class DirectedWalker():", "    ", "    def __init__(self, graph, choice_func, taken_nodes=[]):", "        self.graph = graph", "        self.no_go = taken_nodes", "        self.is_alive = True", "        self.choice_func = choice_func", "        ", "        # strip out taken nodes from possible starting nodes", "        possible = list(set(range(len(graph.nodes)))-set(taken_nodes))", "        # choose a random starting node", "        first_index = random.choice(possible)", "        ", "        # strip out taken nodes from possible next nodes", "        possible = list(set(graph.edges[first_index])-set(taken_nodes))", "        if len(possible)==0: self.is_alive = False", "        else:", "            # choose a random second node", "            second_index = random.choice(possible)", "            # construct this DirectedWalker's history", "            self.hist = [first_index,second_index]", "    ", "    # the current index of this walker on the graph", "    @property", "    def idx(self):", "        if len(self.hist) > 0 : return self.hist[-1]", "        return False", "        ", "    \"\"\"", "    Position and Direction Retrieval", "    Methods that manage retrieval of the point position, vector trajectory, and normal direction of this walker by mapping an index stored in this DirectedWalker's history with a node on the graph", "    \"\"\"", "    def pos_on_graph(self,idx):", "        return self.graph.normals[idx].spt", "    ", "    @property", "    def pos(self):", "        return self.pos_on_graph(self.idx)", "    ", "    @property", "    def normal(self):", "        return self.graph.normals[self.idx].vec", "    ", "    @property", "    def traj(self):", "        pos_a = self.pos_on_graph(self.hist[-2])", "        pos_b = self.pos_on_graph(self.hist[-1])", "        return Vec(pos_a,pos_b)", "    ", "    \"\"\"", "    Possible Directions", "    Returns the vectors of all possible next steps for this walker, excluding any adjacent nodes that are already taken. Returned vector objects store the index of the node they are associated with as an \"idx\" member.", "    \"\"\"", "    @property", "    def possible_directions(self):", "        # returns a Vec from this position to that of an adjacent face", "        def indexed_vector(idx):", "            vec = Vec(self.pos,self.pos_on_graph(idx))", "            # store the face index of the adjacent face in this vector", "            vec.idx = idx", "            return vec", "        # strips illegals from the set of directions of adjacent faces", "        legal = set(self.graph.edges[self.idx]) - set(self.hist + self.no_go)", "        return [indexed_vector(idx) for idx in legal]", "        ", "    ", "    \"\"\"", "    Step Method", "    Moves this DirectedWalker forward one step by applying the stored choice function to the collection of possible directions available. If a stopping condition is met, this DirectedWalker is killed.", "    \"\"\"", "    def step(self,max_steps=1000):", "        # don't let this DirectedWalker step too far", "        if len(self.hist)>=max_steps: self.is_alive = False", "        ", "        # choose the next face using a best choice function", "        choice = self.choice_func(self)", "        # if a choice was made, move this DirectedWalker", "        if choice: self.hist.append(choice)", "        # if no choice was made, kill this DirectedWalker", "        else: self.is_alive = False", "        ", "        # kill this DirectedWalker if he has stepped onto an edge face", "        if self.idx in self.graph.naked_nodes: self.is_alive = False", "", "            ", "    \"\"\"", "    Polyline Representation", "    A function that returns the path of the Walker as a Polyline on the mesh, for visualization purposes.", "    [noprint]", "    \"\"\"", "    def to_pline(self):", "        # try to return a Polyline from the Walker list points", "        try: return PLine([self.pos_on_graph(idx) for idx in self.hist])", "        # if not, return the current face centroid.", "        except: return self.hist[0] # the Walker has only one face", "", "" ],
          "end" : 117,
          "start" : 21
        },
        "description" : "\nDirected Walker\nDefines an agent with that moves along adjacent nodes on a graph according to one of a set of behavioural rules: random motion, straightest path motion, spiral motion, or relative to an attractor point. The desired rule is passed in as the choice_func function at construction.\n",
        "end" : 21,
        "start" : 18
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Fornes/4.02.F02a.py",
      "name" : "4.02.F02a.py",
      "references" : {
        "classes" : {
          "DirectedWalker" : 1,
          "PLine" : 1,
          "Vec" : 2
        }
      }
    },
    "9da593db-462e-4afa-8fec-2778ae8ec3e9" : {
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/Loose Examples/2.XX.XX - Spirograph/2.E02b.py",
      "name" : "2.E02b.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 3,
          "Segment" : 2
        }
      }
    },
    "9ef4be95-245f-4c5c-9a7f-049c5eb69ef4" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def func(t):", "    return crv_a.eval(t)*(1-m) + crv_b.eval(t)*m", "      ", "crv = Curve(func)", "" ],
          "end" : 25,
          "start" : 20
        },
        "description" : "\nCurve By Tweening\nGiven two curves, crv_a and crv_b, creates a new Curve as an interpolation between them based on an interpolation value m.\n",
        "end" : 20,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "cs = CS()", "crvs = []", "for m in Interval()/cnt:", "    def func(t):", "        return Point.interpolate( crv_a.eval(t), crv_b.eval(t), m )", "    crvs.append(Curve( func, basis = cs + Vec(0,0,floorheight) ) )", "", "    " ],
          "end" : 37,
          "start" : 29
        },
        "description" : "\nStacked Tweened Curves\nCreates a tower-like 'stack' of related curves by successively interpolating between two curves given by crv_a and crv_b\n",
        "end" : 29,
        "start" : 26
      }, {
        "code" : {
          "content" : [ "minmax = math.sqrt(0.5)**skew", "ival = Interval(-minmax,minmax)", "", "def func(x):", "    x -= 0.5", "    if x == 0 : return 0.5", "    if x < 0 : return ival.deval( -math.sqrt(-x) ** skew )", "    if x > 0: return ival.deval( math.sqrt(x) ** skew )", "", "m_vals = [ func(x) for x in Interval().divide(count,True) ]", "" ],
          "end" : 52,
          "start" : 41
        },
        "description" : "\nSkewed Value Series\nGiven a skew amount, produce a series of m-values (to be later used for curve interpolation) progressing from 0 to 1 in a non-linear fashion.\n",
        "end" : 41,
        "start" : 38
      }, {
        "code" : {
          "content" : [ "cs = CS()", "crvs = []", "for m in m_vals:", "    def func(t):", "        return Point.interpolate( crv_a.eval(t), crv_b.eval(t), m )", "    crvs.append( Curve( func, basis = cs + Vec(0,0,floorheight) ) )", "    ", "" ],
          "end" : 63,
          "start" : 56
        },
        "description" : "\nStacked-Skewed Tweened Curves\nCreates a 'stack' of related curves by successively and non-linearly interpolating between two curves given by crv_a and crv_b\n",
        "end" : 56,
        "start" : 53
      } ],
      "documentation" : {
        "description" : [ "4.04.L03a", "Approaches and applications for curve interpolation." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Mathematical Tweening/4.04.L03a.py",
      "name" : "4.04.L03a.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Curve" : 3,
          "Interval" : 3,
          "Point" : 2,
          "Vec" : 2
        }
      },
      "required" : [ "crv_a (Curve) A Curve at interpolation value 0", "crv_b (Curve) A Curve at interpolation value 1", "m (float) Interpolation value.", "cnt (int) The number of Curves to stack", "floorheight (float) The vertical distance between Curves" ],
      "result" : [ "crv (Curve) An interpolated Curve." ]
    },
    "9ff370b0-724b-4ab8-938b-0fdf26ed30c5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def point_by_cyl_coords(radius,radians,z):", "    x = radius * math.cos(radians)", "    y = radius * math.sin(radians)", "    return Point(x,y,z)", "", "def func_helix(t):", "    theta = 2*turns*pi*t/height", "    z = t", "    return point_by_cyl_coords(rad,theta,z) ", "", "ival = Interval(0,height)", "crv_out = Curve(func_helix,ival,0.05)", "", "" ],
          "end" : 29,
          "start" : 15
        },
        "description" : "\nA Simple Helix\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "", "def func_helix(t):", "    rad = Interval(rad_bot,rad_top).eval(t/height)", "    theta = 2*turns*pi*t/height", "    z = t", "    return CylCS().eval(rad, theta, z)", "", "", "   " ],
          "end" : 41,
          "start" : 32
        },
        "description" : "\nA Helix with a linear profile\n",
        "end" : 32,
        "start" : 30
      }, {
        "code" : {
          "content" : [ "rad_min = 2", "offset = 0.2", "", "def func_rad(t):", "    rad = rad_min*(sin(pi*t/height + offset) + 1)", "    return rad", " ", "def func_theta(t):", "    theta = 2*turns*pi*(t/height)**k", "    return theta", "", "def func_helix(t):", "    rad = func_rad(t)", "    theta = func_theta(t)", "    return point_by_cyl_coords(rad, theta, t)", "", "ival = Interval(0,height)", "crv = Curve(func_helix, ival, height/200)", "", "" ],
          "end" : 64,
          "start" : 44
        },
        "description" : "\nA Helix with a 'wavy' profile\n",
        "end" : 44,
        "start" : 42
      }, {
        "code" : {
          "content" : [ "def func_rad(t):", "    pt_a = Point(rad_cap,0)", "    pt_b = Point(rad_mid,mid_height*height)", "    pt_c = Point(rad_cap,height)", "    rad = Curve.bezier([pt_a,pt_b,pt_c]).eval(t/height).x", "    return rad", "", "" ],
          "end" : 74,
          "start" : 67
        },
        "description" : "\nA Helix with a Bezier profile\n",
        "end" : 67,
        "start" : 65
      } ],
      "documentation" : {
        "description" : [ "3.07.E02b", "Generalized Helix." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Parametrization/3.07.E02b.py",
      "name" : "3.07.E02b.py",
      "references" : {
        "classes" : {
          "Curve" : 3,
          "CylCS" : 1,
          "Interval" : 3,
          "Point" : 4
        }
      },
      "required" : [ "TODO" ],
      "result" : [ "TODO" ]
    },
    "a01a7cfc-4f2a-4bf5-9f2d-c03501360aa7" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class GrayScott (object):", "", "    def __init__(self, dimensions=Interval(20,20)):", "        # sets the boundary rectangle", "        self.width, self.height = int(dimensions.a), int(dimensions.b)", "        # sets default coefficients", "        self.coeff = {\"f\":0.023,\"k\":0.077,\"du\":0.095,\"dv\":0.03}", "        # initializes this GrayScott object", "        self.clear()", "        ", "    \"\"\"", "    Get and Set Methods", "    Provides access to the u or v values stored in this GrayScott's value fields.", "    [noprint]", "    \"\"\" ", "    def set_u(self,x,y,val):", "        self._uvals.set(x,y,val) #sets the u at x,y to the given value", "        ", "    def set_v(self,x,y,val):  ", "        self._vvals.set(x,y,val) #sets the v at x,y to the given value", "        ", "    def get_u(self,x,y):     ", "        return self._uvals.get(x,y) #returns the u-value found at x,y", "    ", "    def get_v(self,x,y):", "        return self._vvals.get(x,y) #returns the v-value found at x,y", "    ", "    \"\"\"", "    Set Pixels", "    Provides a way to set the u or v values of this GrayScott within a given area to convenient 'seed' values. These particular values will result in a reaciton that spreads out from the localized area into the surrounding field.", "    \"\"\" ", "    def set_rect(self,x,y,w,h):", "        # for each x- and y-location within the given rectangle:", "        for xi in range(x,x+w):", "            for yi in range(y,y+h):", "                # set the u and v to good 'seed' values.", "                self._uvals.set(xi,yi,0.5)", "                self._vvals.set(xi,yi,0.25)", "", "                ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    def _reframe(self,x,y):", "        # if a location is outside the value field, move it back", "        while x > self.width -1 : x = x - self.width", "        while y > self.height -1: y = y - self.height", "        while x < 0 : x = self.width + x", "        while y < 0 : y = self.height + y", "        return x,y", "        ", "    \"\"\"", "    Clear and Record Methods", "    Manages the stored history, as well as values stored in the current u- and v- ValueFields", "    \"\"\"", "    def clear(self):", "        # create new value fields for the u and v values", "        self._uvals = ValueField(Interval(self.width,self.height),1.0)", "        self._vvals = ValueField(Interval(self.width,self.height),0.0)", "        # set the u and v value histories to empty lists", "        self.hist_u = []", "        self.hist_v = []", "", "    def record(self):", "        # append u and v value fields to the history lists", "        self.hist_u.append(self._uvals)", "        self.hist_v.append(self._vvals)", "        ", "    \"\"\"", "    Step Method", "    Creates a new generation of u- and v- values through the application of the Grey-Scott reaction-diffusion equations", "    \"\"\"", "    def step(self, t=1.0):", "        # create a blank value field for the next generation", "        nxt_uvals = ValueField(Interval(self.width,self.height),0.0)", "        nxt_vvals = ValueField(Interval(self.width,self.height),0.0)", "        ", "        # for each x- and y-location in the value fields:", "        for x,y in u_vals.addresses:", "            # get u- and v- values for this cell ", "            cur_u = self._uvals.get(x,y)", "            cur_v = self._vvals.get(x,y)", "            ", "            # get the neighbors of this cell", "            neighbors_u = self._uvals.neighbors_of(x,y)", "            neighbors_v = self._vvals.neighbors_of(x,y)", "            ", "            # apply the GrayScott reaction-diffusion algorithm", "            d2 = cur_u * cur_v * cur_v", "            cur_du = self.coeff['du'] * (sum(neighbors_u) - 4.0 * cur_u) - d2", "            cur_dv = self.coeff['dv'] * (sum(neighbors_v) - 4.0 * cur_v) + d2", "            nxt_u = cur_u + t * (cur_du + self.coeff['f'] * (1.0 - cur_u))", "            nxt_v = cur_v + t * (cur_dv - self.coeff['k'] * cur_v)", "            ", "            # set the values of the new value field", "            nxt_uvals.set(x,y,max(0.0,nxt_u)) #ensures that u is positive", "            nxt_vvals.set(x,y,max(0.0,nxt_v)) #ensures that v is positive", "", "        # set the current grid to the new value field", "        self._uvals = nxt_uvals", "        self._vvals = nxt_vvals", "        ", "", "", "" ],
          "end" : 128,
          "start" : 24
        },
        "description" : "\nGrayScott Class\nDefines a class that stores u and v values for each location in two value fields, records values as they change, and provides methods for reading, writing and clearing values\n",
        "end" : 24,
        "start" : 21
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Reaction Diffusion/4.02.L01a.py",
      "name" : "4.02.L01a.py",
      "references" : {
        "classes" : {
          "GrayScott" : 1,
          "Interval" : 5,
          "ValueField" : 4
        }
      }
    },
    "a0cc8ea4-cb92-4f7b-944a-ef9c5c129a3c" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_graph.py",
      "definitions" : [ {
        "code" : [ "        super(SpatialGraph,self).__init__()", "        self.distances = {}", "        ", "        #self.qtree = QuadTree(4, bnds)", "        #for pt in pts: qt.append(pt)", "        ", "        if initial_pts:", "            for pt in initial_pts: self.add_node(pt)" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 132,
        "name" : "__init__",
        "start" : 125
      }, {
        "code" : [ "        if check_validity:", "            na, nb = self.node_at(from_node), self.node_at(to_node)", "            if na: from_node = na", "            if nb: to_node = nb", "        ", "            # make sure these nodes are in our list of nodes", "            if from_node not in self.nodes: self.add_node(from_node)", "            if to_node not in self.nodes: self.add_node(to_node)", "        ", "        # add the edge", "        dist = from_node.distance(to_node)   ", "        success = self._add_edge(from_node, to_node, dist)", "        # add the reverse edge", "        if bidirectional: success = success and self._add_edge(to_node, from_node, dist)", "        return success", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 153,
        "name" : "add_edge",
        "start" : 138
      }, {
        "code" : [ "        if check_validity:", "            undup = self.node_at(pt)", "            if undup: pt = undup", "        ", "        self.nodes.add(pt)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 162,
        "name" : "add_node",
        "start" : 157
      }, {
        "code" : [ "        return [[Segment(spt,ept) for ept in epts] for spt, epts in self.edges.items()]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 168,
        "name" : "to_segs",
        "start" : 167
      }, {
        "code" : [ "        \"\"\"| Overloads the containment **(in)** operator\"\"\"", "        return node_at(pt) is not False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the containment **(in)** operator" ]
        },
        "end" : 173,
        "name" : "__contains__",
        "start" : 171
      }, {
        "code" : [ "        for other in self.nodes:", "            if pt == other : return other", "        return False", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 178,
        "name" : "node_at",
        "start" : 175
      } ],
      "documentation" : {
        "description" : [ "A graph of spatial points", "A graph is indexed by object, not by position. This class ensures that duplicate point positions are not permitted.", "Collection of points given at construction are not checked for duplicates" ]
      },
      "end" : 178,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_graph.py",
      "name" : "SpatialGraph",
      "references" : {
        "classes" : {
          "Graph" : 1,
          "Segment" : 1,
          "SpatialGraph" : 2
        },
        "functions" : {
          "__contains__" : 1,
          "__init__" : 1,
          "add_edge" : 1,
          "add_node" : 1,
          "node_at" : 1,
          "to_segs" : 1
        }
      },
      "start" : 119
    },
    "a214b26a-0777-43bb-a709-a52d0fbb0e79" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def split_arc(arc, plane):", "    ", "    # create an Intersector object", "    xsor = Intersector()", "    # if the arc intersects the plane", "    if xsor.of(arc, plane):", "        pts = xsor.results", "        ", "        # find the domain on the arc at which intersection happens", "        domain = [arc.near(pt)[1] for pt in pts]", "        # find the mid point on the domain", "        mid_pt = arc.eval(sum(domain)/len(domain))", "        # create a new arc on the domain through that point", "        out_arc = Arc.thru_pts(pts[0], mid_pt, pts[1])", "        # if the mid point of the new arc is below the cut plane", "        if out_arc.eval(0.5).z < plane.origin.z:", "            # flip it", "            out_arc = out_arc.flipped()", "        ", "        return out_arc" ],
          "end" : 35,
          "start" : 16
        },
        "description" : "\nSplit Arc by Plane\nA method to split a given Arc along its intersection with a given Plane.\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.03.F01a", "Split a given Arc with a given Plane." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Foster Pre-Rational Studies/4.03.F01a.py",
      "name" : "4.03.F01a.py",
      "references" : {
        "classes" : {
          "Arc" : 1,
          "Intersector" : 1
        }
      },
      "required" : [ "arc (Arc) An Arc to intersect.", "plane (Plane) A Plane to intersect." ],
      "result" : [ "out_arc (Arc) An Arc" ]
    },
    "a2c43be3-f25d-4383-aee5-4972ba3a4902" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def nearest_neighbors(crv,t):", "    if (t == 0):", "        pt_t = crv.eval(0.1*crv.tol)", "        pt_plus = crv.eval(0.2*crv.tol)", "        pt_minus = crv.eval(0)    ", "    elif (t > 0) and (t < 0.5*crv.tol):", "        pt_t = crv.eval(t)", "        pt_plus = crv.eval(2*t)", "        pt_minus = crv.eval(0)", "    elif (t > 1-0.5*crv.tol) and (t < 1):", "        pt_t = crv.eval(t)", "        pt_plus = crv.eval(1)", "        pt_minus = crv.eval(0.5*t)", "    elif (t == 1):", "        pt_t = crv.eval(1-0.1*crv.tol)", "        pt_plus = crv.eval(1)", "        pt_minus = crv.eval(1-0.2*crv.tol)", "    else:", "        pt_t = crv.eval(t)", "        pt_plus = crv.eval(t + 0.5*crv.tol)", "        pt_minus = crv.eval(t - 0.5*crv.tol)", "    ", "    return pt_t, pt_plus, pt_minus", "    ", "    " ],
          "end" : 39,
          "start" : 13
        },
        "description" : "\nCalculates nearest neighbors\n",
        "end" : 13,
        "start" : 11
      }, {
        "code" : {
          "content" : [ "def nearest_neighbors(crv,t):", "    pt_t = crv.eval(t)", "    pt_plus = crv.eval(t + 0.5*crv.tol)", "    pt_minus = crv.eval(t - 0.5*crv.tol)", "    ", "    return pt_t, pt_plus, pt_minus", "    " ],
          "end" : 48,
          "start" : 42
        },
        "description" : "\nCalculates nearest neighbors without worrying about odd conditions\n",
        "end" : 42,
        "start" : 40
      } ],
      "documentation" : {
        "description" : [ "3.07.E03a", "A nearest neighbor function" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Geometric Properties/3.07.E03a.py",
      "name" : "3.07.E03a.py"
    },
    "a34e385e-55c2-41ca-868d-86b43e398b3f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Jorn(Guy):", "", "    def steer(self, vec, infl_vec = 1.0, infl_rand = 1.0):", "        # set the magnitude of the vector", "        vec = vec.cross(Vec.uz())", "        vec = vec.normalized(infl_vec)", "        # create a random vector", "        ran_vec = Vec.random(Interval(-1,1),constrain2d=True)", "        ran_vec = ran_vec.normalized(infl_rand)", "        # combine and limit the force of the result", "        sum_vec = (vec + ran_vec).limited(0.5)", "        # update the velocity of the Guy", "        self.vel += sum_vec" ],
          "end" : 31,
          "start" : 19
        },
        "description" : "\nJorn Class\nA subclass of Guy that overrides the steer method such that instances of this type respond differently to vectors of influence, and includes controls for the influence of the given vector and the influence of a random vector.\n",
        "end" : 19,
        "start" : 16
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04e.py",
      "name" : "4.02.L04e.py",
      "references" : {
        "classes" : {
          "Guy" : 1,
          "Interval" : 1,
          "Jorn" : 1,
          "Vec" : 2
        }
      }
    },
    "a3b0c795-a2b2-4d99-802c-ceab6788cdf0" : {
      "code" : [ "    \"\"\"Creates a list of polygons that represents polygons and/or Bins.", "        :param strips: strips with polygons", "        :type strips : list", "        :param border : color of strips borders (or None)", "        :type border : Color", "        :returns: list of edges and polygons", "        :rtype: list", "    \"\"\" ", "    # create list", "    out_list = []", "    for j,s in enumerate(strips):", "        y = j * height", "        if border_color != None:", "            stock = PGon.rectangle(Point(s.boundary.eval(.5), y+height/2.0), s.boundary.length, height)", "            stock.set_color(border_color)", "            stock.set_weight(height/4)", "            out_list.append(stock)", "", "            for e in stock.edges:", "                e.set_color(border_edges)", "                e.set_weight(1)", "                out_list.append(e)", "", "        lines = s.get_filled()", "        for line in lines:", "            rect = PGon.rectangle(Point(line.eval(.5), y+height/2.0), line.length, height)", "            rect.set_color(strip_filled)", "            out_list.append(rect)", "            for e in rect.edges:", "                e.set_color(border_edges)", "                e.set_weight(1)", "                out_list.append(e)", "", "", "    # return list", "    return out_list", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "Creates a list of polygons that represents polygons and/or Bins." ],
        "parameters" : {
          "strips" : "strips with polygons\n"
        },
        "rtype" : "list"
      },
      "end" : 124,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "extract_strips",
      "start" : 88
    },
    "a4e6e4d1-fa40-4012-bc4d-4bcd77158e1c" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Cell(object):", "", "    def __init__(self, cs, radius=1.0, is_star=False):", "        self.basis = cs", "        self.rad = radius", "        self.is_star = is_star", "", "", "    \"\"\"", "    Perimeter Points Property", "    Returns the points on the perimeter of the cell and groups them in pairs for line and arc creation", "    \"\"\"", "    @property", "    def pts(self):", "        ", "        pts = []", "        self._star_centers = []", "        # for every side of the cell:", "        for f in range(4):", "            side = []", "            # create a temporary CS for this side", "            cs = CS.on_xy(rot=f*math.pi/2)", "            start_pt = cs.eval(self.rad, self.rad) # the start point of the arc", "            sweep_pt = cs.eval(self.rad, -self.rad) # the sweep point of the arc", "            # create an arc that represents an edge ", "            arc = Arc.from_pts(cs.origin, start_pt, sweep_pt)", "            ", "            # if this cell is a star:", "            if self.is_star:", "                # move the side arc, and record the center", "                vec = Vec(-2*self.rad, 0, 0)*Xform.rotation(angle=f*math.pi/2)", "                arc *= Xform.translation(vec)", "                self._star_centers.append(arc.basis.origin)", "                ", "            # divide this arc to produce eight Points", "            for i in Interval().divide(8, True,)[1:-1]:", "                side.append(arc.eval(i))", "            ", "            # if the cell is a star:", "            if self.is_star: ", "                # reverse the order of the resulting points", "                side.reverse() ", "            pts.append(side)", "        ", "        ret = []", "        # for every side of the cell:", "        for side in range(len(pts)):", "            # for the first half of the Points:", "            for line in range((len(pts[side])//2), len(pts[side])):", "                # associate these Points with their partners", "                pt_1 = pts[side][line]", "                pt_2 = pts[side-1][-(line+1)]", "                ret.append([pt_1, pt_2]) ", "        return ret", "    ", "    \"\"\"", "    Square Lines Property", "    Creates square lines between side points     ", "    \"\"\"", "    @property", "    def square_lines(self):", "        ret = []", "        # for every pair of points in self.pts:", "        for group in self.pts:", "            # create the appropriate mid-point for the square lines", "            if group[0].x * group[1].y >= 0:", "                group.insert(1, Point(group[1].y, group[0].x))", "            elif group[0].x * group[0].y <= 0:", "                group.insert(1, Point(group[1].x, group[0].y))", "            elif group[1].x * group[1].y <= 0:", "                group.insert(1, Point(group[1].y, group[0].x))", "            # create a PLine that describes the square lines", "            pl = PLine()", "            for pt in group:", "                pl.append(self.basis.eval(pt))", "            ret.append(pl)", "        return ret", "    ", "    \"\"\"", "    Arc Lines Property", "    Creates arcs between side points    ", "    [pseudo]", "    \"\"\"", "    @property", "    def arc_lines(self):", "        arc_pts = self.pts", "        arcs = []", "        ", "        # if this cell is a star:", "        if self.is_star: ", "            # for every pair of points in self.pts:", "            for f in range(len(self.pts)):", "                # create the appropriate Point for a tangent vector", "                index = int(math.floor(f/(len(self.pts)/4)))", "                ctr_pt = self.basis.eval(self._star_centers[index])", "                # locate the start and sweep points from self.pts", "                st_pt = self.basis.eval(self.pts[f][0]) # start point", "                sw_pt = self.basis.eval(self.pts[f][1]) # sweep point", "                # create the arc, and append to a list of arcs", "                arcs.append(Arc.from_tan(st_pt, sw_pt, Vec(st_pt, ctr_pt)))", "                ", "        # else, this cell is not a star:", "        else: ", "            # for every pair of points in self.pts:", "            for group in self.pts:", "                # locate the start and sweep points from self.pts", "                st_pt = self.basis.eval(group[0])# start point", "                sw_pt = self.basis.eval(group[1])# sweep point", "                # and use the CS origin of this cell to create an arc", "                tan = Vec(st_pt, self.basis.origin)", "                # create the arc, and append to a list of arcs", "                arcs.append(Arc.from_tan(st_pt, sw_pt, tan))", "        return arcs" ],
          "end" : 132,
          "start" : 20
        },
        "description" : "\nCell Class\nDefines a Cell that stores position and size information and provides methods for creating various styles of derivative geometries\n",
        "end" : 20,
        "start" : 17
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Neil Katz Tiling/4.01.F02a.py",
      "name" : "4.01.F02a.py",
      "references" : {
        "classes" : {
          "Arc" : 3,
          "CS" : 1,
          "Cell" : 1,
          "Interval" : 1,
          "PLine" : 1,
          "Point" : 3,
          "Vec" : 3,
          "Xform" : 2
        }
      }
    },
    "a5d2bf6a-8743-4278-8055-d59b7c10b5c2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def add_proximity_connections(gph,val=5):", "    for p1 in gph.nodes:", "        # make a list of all points in the graph without pt", "        others = [p for p in gph.nodes if p != p1]", "        # sort them by distance to pt", "        others.sort(key = lambda p: p.distance2(p1))", "        # return the closest ones", "        others = others[:val]", "        for p2 in others:", "            gph.add_edge(p1,p2,bidirectional=False,check_validity=False)", "        ", "        " ],
          "end" : 27,
          "start" : 15
        },
        "description" : "\nProximity Edges\nAdds edges to a given SpatialGraph such that each Point forms connections with a given number of Points nearest to it.\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "def divide_edges(gph, divs=4):", "    ret = []", "    t_vals = (Interval()/divs)[1:]", "    for spt, epts in gph.edges.items():", "        for ept in epts:", "            ret.extend([Point.interpolate(spt,ept,t) for t in t_vals])", "    return ret", "" ],
          "end" : 39,
          "start" : 31
        },
        "description" : "\nDivide Edges Method\nSubdivides a given graph's edges a given number of times, and returns the resulting points.\n",
        "end" : 31,
        "start" : 28
      }, {
        "code" : {
          "content" : [ "graph = SpatialGraph(point_cloud)", "add_proximity_connections(graph)", "", "for n in range(count):", "    inflated_graph = SpatialGraph(graph.nodes)", "    for pt in divide_edges(graph): inflated_graph.add_node(pt)", "    add_proximity_connections(inflated_graph)", "    graph = inflated_graph" ],
          "end" : 50,
          "start" : 43
        },
        "description" : "\nSpatialGraph Inflation Routine\nConstructs and successively divides a SpatialGraph, reconstructing its edges based on proximity at each step.\n",
        "end" : 43,
        "start" : 40
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Sabin/4.02.F01a.py",
      "name" : "4.02.F01a.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 1,
          "SpatialGraph" : 2
        }
      }
    },
    "a67deb05-f041-4d2a-978d-39ee5e26e6ec" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_cs.py",
      "definitions" : [ {
        "code" : [ "        self.origin = pt", "", "        def __repr__(self):", "            return \"cylcs o[{0},{1},{2}]\".format(self.origin.x,self.origin.y,self.origin.z)", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 402,
        "name" : "__init__",
        "start" : 398
      }, {
        "code" : [ "        \"\"\" Returns a Point from this CS to a Cylindrical CS.", "        ", "            :param a: Point or decimal number.", "            :type a: Point or float", "            :param b: None or decimal number.", "            :type b: None or float", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: A Point in a Cylindrical CS.", "            :rtype: Point", "            ", "        \"\"\"", "        try:", "            radius = a.x", "            radians = a.y", "            z = a.z", "            pt = Point( radius * math.cos(radians), radius * math.sin(radians), z) + self.origin", "        except:", "            try:", "                radius = a", "                radians = b", "                z = c", "                pt = Point( radius * math.cos(radians), radius * math.sin(radians), z) + self.origin", "            except:", "                raise AttributeError(\"either pass me a point or three numbers please\")", "                ", "        return pt", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a Point from this CS to a Cylindrical CS." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "Point",
          "rvalue" : "A Point in a Cylindrical CS.\n",
          "types" : {
            "a" : "Point or float\n",
            "b" : "None or float\n",
            "c" : "None or float\n"
          }
        },
        "end" : 432,
        "name" : "eval",
        "start" : 405
      } ],
      "documentation" : {
        "description" : [ "a cylindrical coordinate system" ]
      },
      "end" : 432,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_cs.py",
      "name" : "CylCS",
      "references" : {
        "classes" : {
          "Basis" : 1,
          "CylCS" : 1,
          "Geometry" : 1,
          "Point" : 3
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "eval" : 1
        }
      },
      "start" : 396
    },
    "a69513b0-5772-471a-88f8-eaa5483103aa" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "chains = []", "res = 100", "twopi = Interval.twopi()", "for n in range(chain_count):", "    t = (n/chain_count)", "    pts = []", "    off = (pi * 2 / hump_count) * t", "    for y in Interval().divide(res,True):", "        pt_a = seg_a.eval(y)", "        pt_b = seg_b.eval(y)", "        theta = twopi.eval(y)+off", "        tt = (1.0 + sin(theta*hump_count))/2", "        pts.append(Point.interpolate(pt_a,pt_b,tt))", "    chain = []", "    for n in range(len(pts)-1):", "        chain.append(Segment(pts[n],pts[n+1]))", "    chains.append(chain)", "   ", "" ],
          "end" : 35,
          "start" : 17
        },
        "description" : "\nGuilloche of Chains Between Two Lines\n",
        "end" : 17,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "3.03.E01b", "Generates a \"guilloche\" of wavy chains between two lines." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Line/Guilloche/3.03.E01b.py",
      "name" : "3.03.E01b.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Point" : 1,
          "Segment" : 1
        }
      },
      "required" : [ "seg_a (Segment) line segment representing a boundary for each chain", "seb_b (Segment) line segment representing the other boundary for each chain", "chain_count(int) number of wavy chains", "hump_count (int) number of complete waves in each wavy chain" ],
      "result" : [ "chains ([[Segment]]) a guilloche of wavy chains" ]
    },
    "a7dfdefc-b456-403f-9c43-6a0337b08853" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class TriTile(Tri):", "    ", "    def __init__(self, pt_a, pt_b, pt_c, type=0):", "        super(TriTile, self).__init__(pt_a, pt_b, pt_c)", "        self.type = type", "        self.neighbors = []", "        self.p_tol = 0.6", "    ", "    \"\"\"", "    Shares Points Method", "    Determines if a given TriTile is adjacent to this TriTile by counting the number of shared points", "    \"\"\"", "    def shares_pts(self, other, val=2):", "        return len([pt for pt in other.pts if pt in self.pts]) >= val", "    ", "    ", "    \"\"\"", "    Perpendicular Vector", "    Returns a vector perpendicular to an edge of this TriTile, and also perpendicular to the plane that bisects this TriTile and a neighboring TriTile (if present).", "    \"\"\"", "    def perp_vec(self,edge_idx,neighbor=False):", "        edge_vec = self.edge_bisector(edge_idx).vec.normalized()", "        ", "        # determine if the given edge abuts a neighboring tile", "        for nei_tri in self.neighbors:", "            for nei_edge in nei_tri.edges:", "                if all([pt in nei_edge.pts for pt in self.edge(edge_idx).pts]): ", "                    # looks like we found a neighbor that shares an edge", "                    nei_vec = nei_edge.vec.cross(nei_tri.plane.normal).normalized()", "                    # return an 'averaged' vector", "                    return edge_vec + nei_vec", "        # no neighbor found, return vector in plane with TriTile", "        return edge_vec", "            ", "            ", "    \"\"\"", "    Inscribe Curves", "    Returns the curve pattern representation of the TriTile", "    \"\"\"", "    ", "    def inscribe_curves(self):", "        # get the perpendicular vector to each side", "        v0,v1,v2 = [self.perp_vec(i).normalized(self.p_tol) for i in range(3)]", "        # define needed interpolation points", "        p0, p1, p3, p4, p5, p6 = self.interp_pts()", "        ", "        # create the appropriate curves for each tile type", "        cva = Curve.bezier([p0, p0+v0, self.centroid, p5+v2, p5])", "        if self.type == 1:", "            cvb = Curve.bezier([p3, p3+v1, self.centroid, p4+v1, p4])", "            cvc = Curve.bezier([p6, p6+v2, self.centroid, p1+v0, p1])", "        else:", "            cvb = Curve.bezier([p3, p3+v1, p5, self.centroid, p1+v0, p1])", "            cvc = Curve.bezier([p6, p0+v0, cva.eval(0.5)])", "        return cva, cvb, cvc", "    ", "    def interp_pts(self):", "        pts = []", "        for a,b in ((0,1),(1,2),(2,0)):", "            for t in [1/3,2/3]:", "                pts.append(Point.interpolate(self.pts[a], self.pts[b], t))", "        return pts", "    ", "    ", "    \"\"\"", "    tells Grasshopper not to convert a TriTile into a Grasshopper triangle when moving between components", "    [noprint]", "    \"\"\"", "    @property", "    def do_translate(self):", "        return False", "            ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    def __eq__(self, other):", "        return self.shares_pts(other,3)", "            ", "    \"\"\"", "    Flipped Constructor", "    Functional, but not required: Returns a new TriTile with Points ordered in the opposite direction of this TriTile", "    [noprint]", "    \"\"\"", "    def flipped(self):", "        tri = TriTile(self.pts[0], self.pts[2], self.pts[1], self.type)", "        tri.neighbors = self.neighbors", "        return tri", "    ", "    \"\"\"", "    Match Method", "    Functional, but not required: Matches one of its sides to another Triangle side.", "    [noprint]", "    \"\"\"", "    def match(self, other):", "        #for pt in [pt in self.pts if pt not in other.pts]:", "        #    print pt", "        npts = []", "        for pt in self.pts:", "            if pt not in other.pts:", "                # find the point not in the other triangle", "                pt_a = pt", "            # and put the other two in a list", "            else: npts.append(pt)", "        # make a new tile with a modified point order", "        tri = TriTile(pt_a, npts[0], npts[1], self.type)", "        # assign it the neighbors", "        tri.neighbors = self.neighbors", "        return tri", "" ],
          "end" : 130,
          "start" : 22
        },
        "description" : "\nTriTile Class\nExtends the Tri Class to include functionality for tiling triangles. Each TriTile stores its 'type', which determines the topology of curves that are drawn on it, and a list of the TriTiles adjacent to it.\n",
        "end" : 22,
        "start" : 19
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Sabin/4.02.F01c.py",
      "name" : "4.02.F01c.py",
      "references" : {
        "classes" : {
          "Curve" : 5,
          "Point" : 1,
          "Tri" : 1,
          "TriTile" : 4
        }
      }
    },
    "a8d545a9-0d76-4c25-a0ee-41ef2109ac68" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def rotated_to_min_bounds(pgon, divs=4, lvls=2, min_a=0, max_a=pi/2):", "    # define the rotation per iteration", "    delta_a = (max_a - min_a) / divs", "    t_list = []", "    # make a copy ", "    t = copy.deepcopy(pgon)", "    # rotate into initial position", "    xf = Xform.rotation(angle = (min_a - delta_a))", "    t._verts = [v * xf for v in t._verts]", "", "    # make an Xform for incremental rotations", "    xf = Xform.rotation(angle = delta_a)", "    # for every rotation in divs + 1:", "    for i in range(divs+1):", "        # rotate the vertices of the PGon", "        t._verts = [v * xf for v in t._verts]", "        # get the area of the bounding box", "        b_area = t.bounds.dim_x * t.bounds.dim_y", "        t_list.append([min_a + i*delta_a,b_area])", "    min_vals = min(t_list, key=lambda s: (s[1]))", "    # if we are only looking at one level:", "    if lvls == 0 :", "        # copy the PGon", "        t = copy.deepcopy(pgon)", "        # create the Xfor rotation", "        xf = Xform.rotation(angle = min_vals[0])", "        # rotate into the first position", "        t._verts = [v * xf for v in t._verts]", "        # return the least are bounding box", "        return t", "    else:", "        # iterate again with an incremental value", "        min_a = min_vals[0] - delta_a", "        max_a = min_vals[0] + delta_a", "        lvls -= 1", "        # run the method again with this level", "        return pgon.rotated_to_min_bounds(divs, lvls, min_a, max_a)", "", "", "" ],
          "end" : 59,
          "start" : 19
        },
        "description" : "\nBest Fit Bounding Box\nMethod that creates a copy of a PGon rotated to its best-fit bounding box.\n",
        "end" : 19,
        "start" : 16
      } ],
      "documentation" : {
        "description" : [ "4.07.L06d", "Method that creates a bounding box around a PGon, and rotates the PGon incrementally until the bounding box with the least possible area is created." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Best Fit/4.07.L06d.py",
      "name" : "4.07.L06d.py",
      "references" : {
        "classes" : {
          "Xform" : 3
        }
      },
      "required" : [ "divs (int) Number of divisions of rotation per level.", "levels (int) Number of iterations.", "min_a (float) Minimum angle of rotation.", "max_a (float) Maximum angle of rotation." ],
      "result" : [ "trial (PGon) Polygon rotated to minimum bounds." ]
    },
    "a8f05694-b16a-488f-94b8-e86dd80241ab" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def mesh_tile(pgon, new_pgon, clr):", "    # get the vertices of the original pgon", "    pts = pgon.pts", "    # get the vertices of the offset pgon", "    new_pgon_pts = new_pgon.pts", "    meshes = []", "    cnt = len(pts)", "\t#for each index in the list of vertices:", "    for i in range(cnt):", "        # add two mesh vertices each of the original pgon and the offset pgon", "        if i < cnt-1:", "            mesh = Mesh([pts[i],pts[i+1],new_pgon_pts[i+1],new_pgon_pts[i]])", "        else: ", "            mesh = Mesh([pts[i],pts[0],new_pgon_pts[0],new_pgon_pts[i]])", "\t\t# create a mesh face between these four vertices", "        mesh.add_face(0,1,2,3)", "        mesh.set_color(clr)", "        meshes.append(mesh)", "    return meshes", "" ],
          "end" : 39,
          "start" : 19
        },
        "description" : "\nMesh Tiles Function\nCreate a mesh from a pgon and an offset pgon and assign a given color to the mesh. \n[noprint]\n",
        "end" : 19,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "#create an attractor point", "attractor = Point()", "#compute a factor based on the distance to the attractor", "factor = pgon.centroid.distance(attractor)/force", "if factor < 0 : factor = 0.0", "if factor > 1 : factor = 1.0", "", "#construct a new offset polygon", "new_pgon = PLine(pgon.pts) * Xform.scale(factor, Point.centroid(pgon.pts)) ", "#set a color based on this factor", "clr = Color.interpolate(clr_a,clr_b,factor)", "", "#create a mesh between the original and the offset polygon", "mesh = mesh_tile(pgon, new_pgon, clr)", "" ],
          "end" : 57,
          "start" : 43
        },
        "description" : "\nAttractor Routine\nRescale each polygon in the tiling based on an attractor point\n",
        "end" : 43,
        "start" : 40
      } ],
      "documentation" : {
        "description" : [ "4.01.L02a", "Given a snub square tiling, scale the original RGons according to a distance to a given point. Create a mesh with the new and the original RGon and color the Mesh based on the distance factor." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Dressed Tilings/4.01.L02a.py",
      "name" : "4.01.L02a.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Mesh" : 2,
          "PLine" : 1,
          "Point" : 2,
          "Xform" : 1
        }
      },
      "required" : [ "cell ([PLine]) Base geometries to mesh.", "force (float) Attractor force to offset geometries.", "clr_a (Color) First color to interpolate.", "clr_b (Color) Second color to interpolate." ],
      "result" : [ "ret ([Mesh]) Meshes with color attributes created by offsetting an original geometry." ]
    },
    "a905157b-5587-496a-a885-dd7f3c88cf82" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def func(t):", "    x = len_x*cos(t)", "    y = len_y*sin(t)", "    return Point(x,y)", "", "ival = Interval(0, 2*pi)", "" ],
          "end" : 30,
          "start" : 23
        },
        "description" : " \nEllipse\n",
        "end" : 23,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "def func(t):", "    x = len_x*num_turns*t*cos(num_turns*t)", "    y = len_x*num_turns*t*sin(num_turns*t)", "    return Point(x,y)", "     ", "ival = Interval(0,2*pi)", "" ],
          "end" : 40,
          "start" : 33
        },
        "description" : "\nSpiral\n",
        "end" : 33,
        "start" : 31
      }, {
        "code" : {
          "content" : [ "def func(t):", "    eps = 0.01", "    t_value = (1-t)*(-pi/3 +eps) + t*(pi/3 - eps)", "    c = math.cos(t_value)", "    s = math.sin(t_value)", "    tan = math.tan(t_value)", "    x = len_x*(1-tan*tan)*c", "    y = len_y*(1-tan*tan)*s", "    return Point(x,y)", "     ", "ival = Interval(0,1)", "" ],
          "end" : 55,
          "start" : 43
        },
        "description" : "\nBow\n",
        "end" : 43,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "def func(t):", "    x = len_x*cos(t)", "    y = len_y*(sin(t)*sin(0.5*t)**n)", "    return Point(x,y)", "", "ival = Interval(0, 2*pi)", "" ],
          "end" : 65,
          "start" : 58
        },
        "description" : "\nTeardrop\n",
        "end" : 58,
        "start" : 56
      }, {
        "code" : {
          "content" : [ "def func(t):", "    c = cos(t)", "    s = sin(t)", "    x = len_x*abs(c)*c", "    y = len_y*abs(s)*s", "    return Point(x,y)", "     ", "ival = Interval(0,2*pi)", "" ],
          "end" : 77,
          "start" : 68
        },
        "description" : "\nDiamond\n",
        "end" : 68,
        "start" : 66
      }, {
        "code" : {
          "content" : [ "def blob(t):", "    c = cos(2*math.pi*t)", "    s = sin(2*math.pi*t)", "    c_theta = cos(2*math.pi*alpha)", "    s_theta = sin(2*math.pi*alpha)", "    factor = 1.0/sqrt(2)", "    r = 30*(1 + rad*factor*c_theta*cos(4*pi*t) + rad*factor*s_theta*cos(6*pi*t))", "    x = r*cos(2*pi*t)", "    y = r*sin(2*pi*t)", "    return Point(x,y)", "     ", "ival = Interval(0,1)", "" ],
          "end" : 93,
          "start" : 80
        },
        "description" : "\nBlob-shaped curve family with all curves of fixed radius having same area.  \n",
        "end" : 80,
        "start" : 78
      }, {
        "code" : {
          "content" : [ "def func(t):", "    t_value = 2*pi*t", "    c = cos(t_value)", "    s = sin(t_value)", "    c_n = cos((num_cusps-1)*t_value)", "    s_n = sin((num_cusps-1)*t_value)", "    factor = len_x/num_cusps", "    x = factor*((num_cusps-1)*c - c_n)", "    y = factor*((num_cusps-1)*s + s_n)", "    return Point(x,y)", "    ", "ival = Interval(0,1)", "" ],
          "end" : 109,
          "start" : 96
        },
        "description" : "\nHypocycloid\n",
        "end" : 96,
        "start" : 94
      }, {
        "code" : {
          "content" : [ "def func_knot(t):", "    rho = rad_min + (rad_max - rad_min)*sin(pi*t)", "    phi = pi*sin(pi*n_phi*t)", "    theta = 2*pi*n_theta*t", "    #eventually implement a SphCS().eval(rho, phi, theta)", "    x = rho*sin(phi)*cos(theta)", "    y = rho*sin(phi)*sin(theta)", "    z = rho*cos(phi)", "    return Point(x,y,z)", " ", "ival = Interval(0,1)", "" ],
          "end" : 123,
          "start" : 112
        },
        "description" : "\nA Family of Spherical Knots\n",
        "end" : 112,
        "start" : 110
      } ],
      "documentation" : {
        "description" : [ "3.07.E02a", "A Gallery of Parametrized Curves.  There are many parametrizations that have been \"discovered\" already.", "These can be \"plugged in\" as a Decodes curve" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Parametrization/3.07.E02a.py",
      "name" : "3.07.E02a.py",
      "references" : {
        "classes" : {
          "Interval" : 8,
          "Point" : 8
        }
      },
      "required" : [ "various parameters to define the parametrization function" ],
      "result" : [ "parametrization function", "domain interval", "sample usage:", "tol = ival.delta/pt_count", "crv = Curve(func,ival,tol)" ]
    },
    "aa8b4082-d8ea-495a-bc46-3a8b50eb6c3d" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def func(u,v):", "    pt = crv.eval(v)", "    angle = rot_ival.eval(u)", "    xf = Xform.rotation(axis=axis_vec,angle=angle,center=base_pt )", "    return pt*xf ", "surf = Surface(func)", "" ],
          "end" : 44,
          "start" : 36
        },
        "description" : "\nRotational Surface\nConstructed from a profile curve, a rotational domain, an arbitrary axis of rotation\n",
        "end" : 36,
        "start" : 33
      }, {
        "code" : {
          "content" : [ "from decodes.extensions.classical_surfaces import *", "surf = RotationalSurface(crv,axis=axis_vec,center=base_pt,dom_u=rot_ival)", "" ],
          "end" : 51,
          "start" : 48
        },
        "description" : "\nRotational Surface\nEncapsulated as a subclass\n",
        "end" : 48,
        "start" : 45
      }, {
        "code" : {
          "content" : [ "def func(u,v):", "    generator.basis = CS(directrix.eval(u))", "    return generator.eval(v)", "", "", "surf = Surface(func)", "" ],
          "end" : 62,
          "start" : 55
        },
        "description" : "\nTranslational Surface\nConstructed by sweeping a generator curve along a directrix curve\n",
        "end" : 55,
        "start" : 52
      }, {
        "code" : {
          "content" : [ "", "def func(u,v):", "    height = sqrt(length**2 - ( radius**2 * twist**2 ))", "    pt_btm = Point()+ Vec(cos(u), sin(u),0).normalized(radius)", "    pt_top = pt_btm * Xform.rotation(angle = twist, axis = Vec(0,0,1) ) + Vec(0,0,height)", "    return Segment(pt_btm,pt_top).eval(v)", "", "surf = Surface(func,Interval.twopi(),Interval())", "", "", "" ],
          "end" : 76,
          "start" : 66
        },
        "description" : "\nHyperboloid as Ruled Surface \nConstructed from moving a line segment\n",
        "end" : 66,
        "start" : 63
      } ],
      "documentation" : {
        "description" : [ "3.09.E02a", "Constructs some classical surfaces used in architectural design including", "A. A rotational surface from a profile curve, a rotational domain, and an arbitrary axis of rotation", "B. A translational surface from a directrix curve and generatrix curve", "C. A hyperboloid as a ruled surface" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Classical Surfaces/3.09.E02a.py",
      "name" : "3.09.E02a.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 2,
          "Point" : 1,
          "RotationalSurface" : 1,
          "Segment" : 1,
          "Surface" : 3,
          "Vec" : 3,
          "Xform" : 2
        }
      },
      "required" : [ "A.", "curve to rotate(Curve)", "angular domain (Interval)", "axis (Vec)", "base point of axis (Point)", "B.", "directrix curve (Curve)", "generator curve (Curve)", "C.", "length of lines (float)", "radius of base circle (float)", "angle of twist (float)", "u_divs (int)", "v_divs (int)" ],
      "result" : [ "A. a rotational surface (surface)", "B. a translational surface (surface)", "C. a hyperboloid as a ruled surface (surface)" ]
    },
    "aa9a3e35-4476-4c4a-a60a-c8710e0f4303" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_raster.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Raster constructor.", "        ", "            :param pixel_dim: Pixel dimension of this Raster.", "            :type pixel_dim: Interval or Tuple        ", "            :param include_corners: Boolean value.", "            :type include_corners: bool", "            :param wrap: Boolean value.", "            :type wrap: bool", "            :result: Raster object", "            :rtype: Raster", "            ", "        \"\"\"", "        if pixel_dim is None: pixel_dim = Interval(20,20)", "        try:", "            self._dim = (int(pixel_dim.a),int(pixel_dim.b))", "        except:", "            try:", "                a,b = pixel_dim", "                a,b = int(a), int(b)", "                self._dim = a,b", "            except:", "                raise Exception(\"The first given argument should be either an Interval or a Tuple of two Integers\")            ", "        ", "        self.include_corners = False", "        self.wrap = False", "        if \"include_corners\" in kwargs: self.include_corners = kwargs[\"include_corners\"]", "        if \"wrap\" in kwargs: self.wrap = kwargs[\"wrap\"]", "        ", "        # the _pixels collection is initialized but not populated", "        self._pixels = []", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Raster constructor." ],
          "parameters" : {
            "include_corners" : "Boolean value.\n",
            "pixel_dim" : "Pixel dimension of this Raster.\n",
            "wrap" : "Boolean value.\n"
          },
          "rtype" : "Raster",
          "rvalue" : "Raster object\n",
          "types" : {
            "include_corners" : "bool\n",
            "pixel_dim" : "Interval or Tuple        \n",
            "wrap" : "bool\n"
          }
        },
        "end" : 39,
        "name" : "__init__",
        "start" : 9
      }, {
        "code" : [ "    def px_dim(self):", "        \"\"\" Returns pixel dimension.", "            ", "            :result: Pixel Dimension.", "            :rtype: (int,int)", "            ", "        \"\"\"", "        return self._dim", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns pixel dimension." ],
          "rtype" : "(int,int)",
          "rvalue" : "Pixel Dimension.\n"
        },
        "end" : 50,
        "name" : "px_dim",
        "start" : 42
      }, {
        "code" : [ "    def px_width(self):", "        \"\"\" Returns pixel width.", "            ", "            :result: Pixel width.", "            :rtype: int", "            ", "        \"\"\"", "        return int(self._dim[0])", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns pixel width." ],
          "rtype" : "int",
          "rvalue" : "Pixel width.\n"
        },
        "end" : 60,
        "name" : "px_width",
        "start" : 52
      }, {
        "code" : [ "    def px_height(self):", "        \"\"\" Returns pixel height.", "        ", "            :result: pixel height", "            :rtype: int", "            ", "        \"\"\"", "        return int(self._dim[1])", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns pixel height." ],
          "rtype" : "int",
          "rvalue" : "pixel height\n"
        },
        "end" : 70,
        "name" : "px_height",
        "start" : 62
      }, {
        "code" : [ "    def px_count(self):", "        \"\"\" Returns the total number of pixels.", "        ", "            :result: pixel count", "            :rtype: int", "            ", "        \"\"\"", "        return self.px_width*self.px_height", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the total number of pixels." ],
          "rtype" : "int",
          "rvalue" : "pixel count\n"
        },
        "end" : 80,
        "name" : "px_count",
        "start" : 72
      }, {
        "code" : [ "    def addresses(self):", "        \"\"\" Returns a list of tuples containing x,y addresses in this Raster.", "        ", "            :result: a list of tuples", "            :rtype: [(int,int)]", "            ", "        \"\"\"", "        return [(x,y) for x in range(self.px_width) for y in range(self.px_height)]", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a list of tuples containing x,y addresses in this Raster." ],
          "rtype" : "[(int,int)]",
          "rvalue" : "a list of tuples\n"
        },
        "end" : 90,
        "name" : "addresses",
        "start" : 82
      }, {
        "code" : [ "        \"\"\" Returns value at location (x,y).", "        ", "            :param x: x coordinate.", "            :type x: float", "            :param y: y coordinate.", "            :type y: float", "            :result: Color value.", "            :rtype: Color", "            ", "        \"\"\"", "        return self._pixels[y*self._dim[0]+x]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns value at location (x,y)." ],
          "parameters" : {
            "x" : "x coordinate.\n",
            "y" : "y coordinate.\n"
          },
          "rtype" : "Color",
          "rvalue" : "Color value.\n",
          "types" : {
            "x" : "float\n",
            "y" : "float\n"
          }
        },
        "end" : 103,
        "name" : "get",
        "start" : 92
      }, {
        "code" : [ "        \"\"\" Set color value at location (x,y).", "        ", "            :param x: x coordinate.", "            :type x: float", "            :param y: y coordinate.", "            :type y: float", "            :param value: Color value", "            :type value: Color", "            :result: Raster object.", "            :rtype: None", "            ", "        \"\"\"", "        self._pixels[y*self.px_width+x] = value", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Set color value at location (x,y)." ],
          "parameters" : {
            "value" : "Color value\n",
            "x" : "x coordinate.\n",
            "y" : "y coordinate.\n"
          },
          "rtype" : "None",
          "rvalue" : "Raster object.\n",
          "types" : {
            "value" : "Color\n",
            "x" : "float\n",
            "y" : "float\n"
          }
        },
        "end" : 118,
        "name" : "set",
        "start" : 105
      }, {
        "code" : [ "        \"\"\" Populates every pixel with the given value, or a copy of the value", "        ", "            :param val: The value to populate this Raster.", "            :type val: object", "            :param do_copy: Switch to create copies of the given value", "            :type value: Boolean", "            :result: Raster object.", "            :rtype: None", "            ", "        \"\"\"", "        if not do_copy: self._pixels = [val]*self.px_count", "        else: " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Populates every pixel with the given value, or a copy of the value" ],
          "parameters" : {
            "do_copy" : "Switch to create copies of the given value\n",
            "val" : "The value to populate this Raster.\n"
          },
          "rtype" : "None",
          "rvalue" : "Raster object.\n",
          "types" : {
            "val" : "object\n",
            "value" : "Boolean\n"
          }
        },
        "end" : 131,
        "name" : "populate",
        "start" : 120
      }, {
        "code" : [ "        \"\"\" Finds neighbors of location (x,y) in Raster.", "            ", "            :param x: x coordinate.", "            :type x: float", "            :param y: y coordinate.", "            :type y: float", "            :result: List of neighbors.", "            :rtype: list", "            ", "        \"\"\"", "        m = self.px_width", "        n = self.px_height", "        ret=[]", "        for di in [-1,0,1]:", "            for dj in [-1,0,1]:", "                if (abs(di)+abs(dj)) > 0:", "                    if self.wrap :          # wrap is true", "                        new_index = ((y+dj)%n)*m+((x+di)%m)", "                        if (di == 0) or (dj == 0) : ret.append(self._pixels[new_index])", "                        elif self.include_corners : ret.append(self._pixels[new_index])", "                    else:           # wrap is false", "                        if ((x+di) in range(m)) and ((y+dj) in range(n)):", "                            new_index = ((y+dj)%n)*m+((x+di)%m)", "                            if (di == 0) or (dj == 0) : ret.append(self._pixels[new_index])", "                            elif self.include_corners : ret.append(self._pixels[new_index])", "        return ret", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Finds neighbors of location (x,y) in Raster." ],
          "parameters" : {
            "x" : "x coordinate.\n",
            "y" : "y coordinate.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of neighbors.\n",
          "types" : {
            "x" : "float\n",
            "y" : "float\n"
          }
        },
        "end" : 163,
        "name" : "neighbors_of",
        "start" : 137
      } ],
      "documentation" : {
        "description" : [ "an abstract class for storing information in a raster grid format." ]
      },
      "end" : 163,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_raster.py",
      "name" : "Raster",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Raster" : 1
        },
        "functions" : {
          "__init__" : 1,
          "addresses" : 1,
          "get" : 1,
          "neighbors_of" : 1,
          "populate" : 1,
          "px_count" : 1,
          "px_dim" : 1,
          "px_height" : 1,
          "px_width" : 1,
          "set" : 1
        }
      },
      "start" : 4
    },
    "aad2a907-e99c-4d06-ad78-d9f4231d3399" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_raster.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" BoolField constructor.", "        ", "            :param pixel_dim: Resolution of BoolField.", "            :type pixel_dim: Interval", "            :param initial_value: Start value of BoolField", "            :type initial_value: bool", "            :param include_corners: Boolean value.", "            :type include_corners: bool", "            :param wrap: Boolean value.", "            :type wrap: bool", "            :result: BoolField object.", "            :rtype: BoolField", "            ", "        \"\"\"", "        if \"wrap\" not in kwargs: kwargs[\"wrap\"] = True", "        super(BoolField,self).__init__(pixel_dim,**kwargs)", "        self.populate(initial_value)", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "BoolField constructor." ],
          "parameters" : {
            "include_corners" : "Boolean value.\n",
            "initial_value" : "Start value of BoolField\n",
            "pixel_dim" : "Resolution of BoolField.\n",
            "wrap" : "Boolean value.\n"
          },
          "rtype" : "BoolField",
          "rvalue" : "BoolField object.\n",
          "types" : {
            "include_corners" : "bool\n",
            "initial_value" : "bool\n",
            "pixel_dim" : "Interval\n",
            "wrap" : "bool\n"
          }
        },
        "end" : 354,
        "name" : "__init__",
        "start" : 337
      }, {
        "code" : [ "        \"\"\" Constructs and image from the BoolField.", "            ", "            :param false_color: Color for False values.", "            :type false_color: Color", "            :param true_color: Color for True values.", "            :type true_color: Color", "            :result: Image", "            :rtype: Image", "            ", "        \"\"\"", "        img = Image(self._dim,false_color)", "        for n, bool in enumerate(self._pixels):", "            if bool : img._pixels[n] = true_color", "", "        return img", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Constructs and image from the BoolField." ],
          "parameters" : {
            "false_color" : "Color for False values.\n",
            "true_color" : "Color for True values.\n"
          },
          "rtype" : "Image",
          "rvalue" : "Image\n",
          "types" : {
            "false_color" : "Color\n",
            "true_color" : "Color\n"
          }
        },
        "end" : 372,
        "name" : "to_image",
        "start" : 357
      } ],
      "documentation" : {
        "description" : [ "a raster grid of boolean values", "each pixel contains a True or a False" ]
      },
      "end" : 372,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_raster.py",
      "name" : "BoolField",
      "references" : {
        "classes" : {
          "BoolField" : 2,
          "Color" : 2,
          "Image" : 1,
          "Raster" : 1
        },
        "functions" : {
          "__init__" : 1,
          "to_image" : 1
        }
      },
      "start" : 331
    },
    "abe0bd3a-8f2a-429b-98e9-e138bfdeb5b1" : {
      "code" : [ "        \"\"\"Places sorted polygons into Bins.", "            :param shapes   : polygons to be placed", "            :type shapes    : list of polygons   ", "            :returns        : Bins with the polygons within them", "            :rtype          : list of Bins", "        \"\"\"", "", "        # initialize", "        sheets = [Bin(Point(0,0), sheet_size.a, sheet_size.b)]", "        no_sheets = 1", "", "        for i, r in enumerate(shapes):", "            # see if rectangle fits into one of the sheets", "#            print \"looking at item \",i", "            flag = False", "            for j, s in enumerate(sheets):", "                test_bin = s.can_fit(r)", "                if test_bin <> None:", "                    test_bin.put_item(r)", "#                    print \"packing into bin \",j", "                    flag = True", "                    break", "            # if we get here we have not placed the rectangle", "            # so we need to add a new one", "            if not flag:", "                sheets.append(Bin(Point(no_sheets*sheet_size.a,0), sheet_size.a, sheet_size.b))", "                no_sheets += 1", "                sheets[no_sheets-1].put_item(r)", "#                print \"adding bin \", no_sheets-1", "", "        return sheets", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "Places sorted polygons into Bins." ],
        "rtype" : "list of Bins"
      },
      "end" : 287,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "bin_polygons",
      "start" : 256
    },
    "abe49815-49a3-40a5-bf35-31b964a14096" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_line.py",
      "definitions" : [ {
        "code" : [ "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 345,
        "name" : "__repr__",
        "start" : 345
      }, {
        "code" : [ "        \"\"\" Returns True if the given Ray shares a start Point and normalized direction vector with this Ray. Equivalent to Ray.is_equal()", "        ", "            :param other: Ray to be compared.", "            :type other: Ray", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_ray.is_equal(other_ray)", "        \"\"\"    ", "        return self.is_equal(other,pt_tol, vec_tol)    ", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Ray shares a start Point and normalized direction vector with this Ray. Equivalent to Ray.is_equal()" ],
          "parameters" : {
            "other" : "Ray to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Ray\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float\n"
          }
        },
        "end" : 363,
        "name" : "is_coincident",
        "start" : 347
      }, {
        "code" : [ "        \"\"\" Returns True if the given Ray shares a start Point and normalized direction vector with this Ray", "        ", "            :param other: Ray to be compared.", "            :type other: Ray", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_ray.is_equal(other_ray)", "        \"\"\"", "        return self.spt.is_equal(other.spt,pt_tol) and self.vec.is_coincident(other.vec,vec_tol)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Ray shares a start Point and normalized direction vector with this Ray" ],
          "parameters" : {
            "other" : "Ray to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Ray\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float\n"
          }
        },
        "end" : 381,
        "name" : "is_equal",
        "start" : 365
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given Ray, its t value and the distance from the Point to the near Point.", "       ", "            :param p: Point to look for a near Point on the Ray.", "            :type p: Point", "            :result: Tuple of near point on Ray, t value and distance from point to near point.", "            :rtype: (Point, float, float)", "        \"\"\"", "        near = super(Ray,self).near(p)", "        if near[1] < 0:", "            near = (self.spt,0,p.distance(self.spt))", "        return near", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given Ray, its t value and the distance from the Point to the near Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the Ray.\n"
          },
          "rtype" : "(Point, float, float)",
          "rvalue" : "Tuple of near point on Ray, t value and distance from point to near point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 394,
        "name" : "near",
        "start" : 383
      } ],
      "documentation" : {
        "description" : [ "A ray in space." ]
      },
      "end" : 394,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_line.py",
      "name" : "Ray",
      "references" : {
        "classes" : {
          "LinearEntity" : 1,
          "Ray" : 2
        },
        "functions" : {
          "__repr__" : 1,
          "is_coincident" : 1,
          "is_equal" : 1,
          "near" : 1
        }
      },
      "start" : 343
    },
    "ac97baf8-1c35-4685-9358-84b5838018fd" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/classical_surfaces.py",
      "definitions" : [ {
        "code" : [ "        ", "        if function is not None : self._func = function", "        self._dom = dom_u, dom_v", "        self._tol = self.tol_max", "        if tol_u is not None : self.tol_u = tol_u", "        if tol_v is not None : self.tol_v = tol_v", "", "        for u,v in [(self.u0,self.v0),(self.u0,self.v1),(self.u1,self.v1),(self.u1,self.v0)]:", "            try:", "                pt = self.func(u,v)", "                pt.x", "                pt.y", "                pt.z", "            except:" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 20,
        "name" : "__init__",
        "start" : 7
      }, {
        "code" : [ "        raise NotImplementedError(\"deval_pln not implemented. I am a BAD ClassicalSurface!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 26,
        "name" : "deval_pln",
        "start" : 25
      }, {
        "code" : [ "        raise NotImplementedError(\"deval_crv not implemented. I am a BAD ClassicalSurface!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 29,
        "name" : "deval_crv",
        "start" : 28
      }, {
        "code" : [ "        raise NotImplementedError(\"isocurve not implemented. I am a BAD ClassicalSurface!\")", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 32,
        "name" : "isocurve",
        "start" : 31
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 32,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/classical_surfaces.py",
      "name" : "ClassicalSurface",
      "references" : {
        "classes" : {
          "ClassicalSurface" : 1,
          "Interval" : 2,
          "Surface" : 1
        },
        "functions" : {
          "__init__" : 1,
          "deval_crv" : 1,
          "deval_pln" : 1,
          "isocurve" : 1
        }
      },
      "start" : 6
    },
    "acf10043-136b-4fa2-acd9-4274b04b60c6" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "u0 = cone.u0", "u1 = cone.u1", "u_val = Interval(u0,u1).divide(int((u1-u0)/cone.tol_u),True)", "", "# Creates lists of points for each strip.", "pts = []", "for u in u_val:", "    strip = []", "    strip.append(cone.deval(u,0))", "    strip.append(cone.deval(u,1))", "    pts.append(strip)", "", "", "#Lay down first strip", "cs_orig = CS(pts[0][0],Vec(pts[0][0],pts[0][1]),Vec(pts[0][0],pts[1][0]))", "pos = Point(30,0)", "fpts_a, fpts_b= flat_ptstr(pts[0],pts[1])", "fmsh = mesh_ptstr(fpts_a,fpts_b, quad = True)", "xf = Xform.translation(Vec(fpts_b[0],pos))", "out.put(fmsh*xf)", "cs_flat = CS(fpts_b[0]*xf,Vec(fpts_b[0]*xf,fpts_b[1]*xf),Vec(fpts_b[0]*xf,fpts_a[0]*xf))", "#stores the transformation that flattens each strip", "xf_strip = [Xform.change_basis(cs_orig, cs_flat)]", "", "pos = fpts_a[0]*xf", "vec_prev = Vec(fpts_a[0]*xf, fpts_a[1]*xf)", "", "#Lay down the remaining strips with edges aligned", "num_strips = len(pts)", "for i in range(1,num_strips-1):", "    cs_orig = CS(pts[i][0],Vec(pts[i][0],pts[i][1]),Vec(pts[i][0],pts[i+1][0]))", "    # Unrolls the strip", "    fpts_a, fpts_b= flat_ptstr(pts[i],pts[i+1])", "    # Create a mesh from pts", "    fmsh = mesh_ptstr(fpts_a,fpts_b, quad = True)", "    # Form the transformaton matrix to align the strips edge-to-edge    ", "    xf_trans = Xform.translation(Vec(fpts_b[0],pos))", "    vec_now = Vec(fpts_b[0],fpts_b[1])", "    angle = vec_now.angle(vec_prev)", "    xf_rot_test = Xform.rotation(angle = angle)", "    if ((vec_now*xf_rot_test-vec_prev).length2 > 10e-10):", "        angle = -angle", "    xf_rot = Xform.rotation(angle = angle, center = fpts_b[0])", "    xf = xf_trans*xf_rot    ", "    out.put(fmsh*xf)", "    cs_flat = CS(fpts_b[0]*xf,Vec(fpts_b[0]*xf,fpts_b[1]*xf),Vec(fpts_b[0]*xf,fpts_a[0]*xf))", "    xf_strip.append(Xform.change_basis(cs_orig, cs_flat))", "", "    pos = fpts_a[0]*xf", "    vec_prev = Vec(fpts_a[0]*xf, fpts_a[1]*xf)", "    ", " " ],
          "end" : 78,
          "start" : 25
        },
        "description" : "\nFlatten Cone \nUnwraps a cone into quad strips with edges aligned\n[noprint]\n",
        "end" : 25,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "", "u0 = cone.u0", "u1 = cone.u1", "rot_ival = Interval(u0,u1)", "tol_u = cone.tol_u", "res_u = int((u1-u0)/tol_u)", "", "r_bot = cone.deval(u0, 0).length", "p_top = cone.deval(u0, 1)", "r_top = sqrt(p_top.x**2 + p_top.y**2)", "h = p_top.z", "", "#if cone is not closed", "if (cone.deval(u0, 0).distance(cone.deval(u1,0)) > tol_u):", "    p0 = cone.deval(u0, len_0)", "    p1 = cone.deval(u1, len_1)", "    p_mid = cone.deval(u0 + mid*(u1-u0), len_mid)", "    n_vec = (p1-p_mid).cross(p0-p_mid)", "#else if cone is closed", "else:", "    p0 = cone.deval(u0, len_0)", "    p1 = cone.deval(u0 + 0.5*(u1-u0), len_1)", "    r_vec = p1-p0", "    n_vec = Vec(-r_vec.z, 0, r_vec.x)", "", "m = h/(r_top-r_bot)", "d = n_vec.dot(p0) ", "", "def func_crv_cone(t):", "    theta = t", "    r = (d + n_vec.z * m * r_bot)/(n_vec.z * m + n_vec.x *cos(theta) + n_vec.y * sin(theta))", "    z = m*(r-r_bot)", "    return CylCS().eval(r, theta, z)", "    ", "def func_crv_flat(t):", "    strip = int(floor((t-u0)/tol_u))", "    if strip == res_u: strip = res_u-1", "    return func_crv_cone(t)*xf_flat[strip]", "    ", "crv_cone = Curve(func_crv_cone, rot_ival, tol_u)", "crv_flat = Curve(func_crv_flat, rot_ival, tol_u)", "", "" ],
          "end" : 125,
          "start" : 82
        },
        "description" : "\nUnwrap Curve Type 1\nParametrizes a curve of intersection between a cone and a tilted plane and flattens it\n",
        "end" : 82,
        "start" : 79
      }, {
        "code" : {
          "content" : [ "", "u0 = cone.u0", "u1 = cone.u1", "", "tol_u = cone.tol_u", "res_u = int((u1-u0)/tol_u)", "", "p_top = cone.deval(u0 + len_top*(u1-u0), 1)", "p_bot = cone.deval(u0 + len_bot*(u1-u0), 0)", "p_mid = cone.deval(u0 + len_mid*(u1-u0), mid)", "", "pts_domain = [Point(u0 + len_top*(u1-u0), 1), Point(u0 + len_mid*(u1-u0), mid), Point(u0 + len_bot*(u1-u0), 0)]", "crv_domain = Curve.bezier(pts_domain)", "", "def func_crv_cone(t):", "    domain_pt = crv_domain.eval(t)", "    u = domain_pt.x", "    v = domain_pt.y", "    return cone.deval(u,v)    ", "", "def func_crv_flat(t):", "   domain_pt = crv_domain.eval(t)", "   u = domain_pt.x", "   strip = int(floor((u-u0)/tol_u))", "   if strip == res_u: strip = res_u-1", "   return func_crv_cone(t)*xf_flat[strip]", "    ", "crv_cone = Curve(func_crv_cone, Interval())", "crv_flat = Curve(func_crv_flat, Interval())", " " ],
          "end" : 158,
          "start" : 129
        },
        "description" : "\nUnwrap Curve Type 2\nParametrizes a curve generated by a 3 point Bezier on the domain and flattens it\n",
        "end" : 129,
        "start" : 126
      } ],
      "documentation" : {
        "description" : [ "4.05.L02c", "Unwraps curves on a cone.  Since a cone is developable, it can be flattened into quad", "strips with edges aligned. Using transformations that takes each surface strip to a flattened strip,", "curves on the cone are generated -- one type by intersection with planes and", "the other by a Bezier curve in the domain -- and unwrapped on the flattened cone." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Flatness/4.05.L02c.py",
      "name" : "4.05.L02c.py",
      "references" : {
        "classes" : {
          "CS" : 4,
          "Curve" : 5,
          "CylCS" : 1,
          "Interval" : 4,
          "Point" : 4,
          "Vec" : 14,
          "Xform" : 6
        }
      },
      "required" : [ "cone (Surface) Part of the cone flattened", "mesh_ptstr (func) Meshing function.", "flat_ptstr (func) Unrolling function." ],
      "result" : [ "fmsh_out ([Mesh]) Flattened surface strips.", "xf_strip ([Xform]) Transformations that takes each surface strip to a flattened strip.", "crv_cone (Curve) Curve lying on cone", "crv_flat (Curve) Unwrapped curve lying on flattened cone" ]
    },
    "ad9bc2de-6f12-4681-bdfd-b9256024ee70" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "import math", "# Define constants for math functions", "SQRT2 = 2**0.5", "SQRT3 = 3**0.5", "SQRT24 = 24**0.5", "SQRT3_8 = (3/8)**0.5", "SQRT1_1_8 = (9/8)**0.5 ", "" ],
          "end" : 25,
          "start" : 17
        },
        "description" : "\n[noprint]\n",
        "end" : 17,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "class Tetrahedron(HasBasis):", "    def __init__(self,cs,radius=1.0):", "        self.basis = cs", "        self.rad = radius", "        self.rad2 = self.rad/SQRT1_1_8", "    ", "    \"\"\"", "    Corner Points Method", "    Returns corner points by evaluating the base vectors for this Tetrahedron", "    \"\"\"", "    @property", "    def pts(self):", "        base_vecs = Tetrahedron._base_vecs(self.rad)", "        return [self.basis.eval(v) for v in base_vecs]", "    ", "    \"\"\"", "    Adjacent Edges Method", "    Returns the three edges of this Tetrahedron that include a corner point at a given index", "    [pseudo]", "    \"\"\"", "    def adjacent_edges(self, pt_index):", "        pt = self.pts[pt_index]", "        # Create Segments from given point to each adjacent point", "        e1 = Segment(pt, self.pts[pt_index-3])", "        e2 = Segment(pt, self.pts[pt_index-2])", "        e3 = Segment(pt, self.pts[pt_index-1])", "        return (e1,e2,e3)", "    \"\"\"", "    Triangular Face Method", "    Returns a polygon representation of the triangular face of this Tetrahedron that corresponds to a given face address (a tuple of three point indices)", "    [pseudo]", "    \"\"\"", "    def tri_face(self, address):", "        # Construct a CS at the center of the desired face", "        pts = [self.pts[address[0]],self.pts[address[1]],self.pts[address[2]]]", "        ctr = Point.centroid(pts)", "        cs = CS(ctr, Vec(ctr, pts[0]), Vec(ctr, pts[2]))", "        # Describe face points relative to this CS", "        verts = [cs.deval(pt) for pt in pts]", "        # Construct and return a PGon", "        return PGon(verts,cs)", "     ", "    \"\"\"", "    Tetrahedron to Mesh", "    Creates a mesh representation of this Tetrahedron.", "    [pseudo]", "    \"\"\"", "    def to_mesh(self):", "        # construct a Mesh", "        msh = Mesh()", "        # create mesh faces through points [0,2,1] [0,3,2] [0,1,3] [3,1,2]", "        msh.append(self.pts)", "        msh.add_face(0,2,1)", "        msh.add_face(0,3,2)", "        msh.add_face(0,1,3)", "        msh.add_face(3,1,2)", "        # return the Mesh", "        return msh", "        ", "    \"\"\"", "    Face-Center Constructor", "    Creates a Tetrahedron given geometry that describes the position (CS) and size (radius) of one of the faces of the desired Tetrahedron", "    \"\"\"", "    @staticmethod", "    def from_face_center(face_cs=CS(), face_rad=1.0):", "        # determine the edge length, radius", "        edge_len = face_rad * 3 / SQRT3", "        rad = edge_len * SQRT3_8", "        # determine the center of the Tetrahedron", "        cpt = face_cs.eval(0,0,edge_len/SQRT24)", "        # create a CS at the center at the proper orientation", "        angle_edge_to_face = math.atan(2**0.5)", "        xf = Xform.rotation(axis=face_cs.y_axis,angle=angle_edge_to_face)", "        x_axis = face_cs.x_axis * xf", "        cs = CS(cpt,x_axis,face_cs.y_axis)", "        # construct and return the Tetrahedron", "        return Tetrahedron(cs,rad)", "    ", "    \"\"\"", "    Tetrahedron Base Vectors", "    Vectors describing the points of a unit Tetrahedron at the world origin", "    \"\"\"", "    @staticmethod", "    def _base_vecs(radius=1.0):", "        base_vec_radius =  ((3/8)**0.5)*2", "        mult = radius/base_vec_radius", "        # Create vectors for the Tetrahedron's vertices ", "        v0 = Vec(1,0,1/SQRT2)*mult", "        v1 = Vec(-1,0,1/SQRT2)*mult", "        v2 = Vec(0,1,-1/SQRT2)*mult", "        v3 = Vec(0,-1,-1/SQRT2)*mult", "        return v0,v1,v2,v3", "          ", "", "", "" ],
          "end" : 124,
          "start" : 29
        },
        "description" : "\nTetrahedron class\nA class that represents a regular Tetrahedron, constructed by a coordinate system that lies at the center of the desired tetrahedron\n",
        "end" : 29,
        "start" : 26
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Aranda Lasch Fractal/4.01.F01a.py",
      "name" : "4.01.F01a.py",
      "references" : {
        "classes" : {
          "CS" : 3,
          "HasBasis" : 1,
          "Mesh" : 1,
          "PGon" : 1,
          "Point" : 1,
          "SQRT1_1_8" : 2,
          "SQRT2" : 5,
          "SQRT24" : 2,
          "SQRT3" : 2,
          "SQRT3_8" : 2,
          "Segment" : 3,
          "Tetrahedron" : 3,
          "Vec" : 6,
          "Xform" : 1
        }
      }
    },
    "afcbc118-8bd4-41a4-b98b-620b238c328d" : {
      "code" : [ "        \"\"\"Creates a list of polygons that represents polygons and/or Bins.", "            :param sheets: bins with polygons", "            :type sheets : list", "            :param border : color of sheets borders (or None)", "            :type border : Color", "            :returns: list of edges and polygons", "            :rtype: list", "        \"\"\" ", "        # create list", "        out_list = []", "        for j,s in enumerate(sheets):", "            out_list.extend(s.get_polygons(bin_filled, bin_edges))", "            if border_color != None:", "                border = PGon(s.boundary.corners).edges", "                for b in border:", "                    b.set_color(border_color)", "                    b.set_weight(3)", "                out_list.append(b)", "", "        # return list", "        return out_list", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "Creates a list of polygons that represents polygons and/or Bins." ],
        "parameters" : {
          "sheets" : "bins with polygons\n"
        },
        "rtype" : "list"
      },
      "end" : 311,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "extract_polygons",
      "start" : 290
    },
    "b0a50aa4-188c-4047-ae70-67211032b6c2" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/voxel.py",
      "definitions" : [ {
        "code" : [ "        self.bnds = boundary", "        self._res_x = res_x ", "        self._res_y = res_y ", "        self._res_z = res_z", "        self._stack = tuple(ValueField(Interval(res_x,res_y),initial_value) for z in range(self._res_z))", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 15,
        "name" : "__init__",
        "start" : 10
      }, {
        "code" : [ "    def res_x(self):", "        return self._res_x", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 19,
        "name" : "res_x",
        "start" : 17
      }, {
        "code" : [ "    def res_y(self):", "        return self._res_y", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 23,
        "name" : "res_y",
        "start" : 21
      }, {
        "code" : [ "    def res_z(self):", "        return self._res_z", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 27,
        "name" : "res_z",
        "start" : 25
      }, {
        "code" : [ "    def bnds(self):", "        return self._bnds", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 31,
        "name" : "bnds",
        "start" : 29
      }, {
        "code" : [ "    def bnds(self,value): ", "        self._dim_pixel = None", "        self._dim_pixel2 = None", "        self._bnds = value", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 37,
        "name" : "bnds",
        "start" : 33
      }, {
        "code" : [ "    def dim_pixel(self):", "        \"\"\"", "        returns the spatial dimensions of a single pixel of this voxel grid as a vector", "        \"\"\"", "        if self._dim_pixel is None : self._dim_pixel = Vec(self.bnds.dim_x / self._res_x , self.bnds.dim_y / self._res_y, self.bnds.dim_z / self._res_z)", "        return self._dim_pixel", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "returns the spatial dimensions of a single pixel of this voxel grid as a vector" ]
        },
        "end" : 45,
        "name" : "dim_pixel",
        "start" : 39
      }, {
        "code" : [ "    def dim_pixel2(self):", "        \"\"\"", "        returns the spatial dimensions of HALF OF a single pixel of this voxel grid as a tuple", "        \"\"\"", "        if self._dim_pixel2 is None : self._dim_pixel2 = self._dim_pixel = Vec(self.bnds.dim_x / self._res_x , self.bnds.dim_y / self._res_y, self.bnds.dim_z / self._res_z) / 2.0", "        return self._dim_pixel2", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "returns the spatial dimensions of HALF OF a single pixel of this voxel grid as a tuple" ]
        },
        "end" : 53,
        "name" : "dim_pixel2",
        "start" : 47
      }, {
        "code" : [ "    def max_value(self):", "        return max([tray.max_value for tray in stack])", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 57,
        "name" : "max_value",
        "start" : 55
      }, {
        "code" : [ "    def min_value(self):", "        return min([tray.max_value for tray in stack])", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 61,
        "name" : "min_value",
        "start" : 59
      }, {
        "code" : [ "        if x<0 or x>self._res_x-1 : raise IndexError(\"x out of bounds. this voxel field has %s pixels in the x direction and you asked to set %s\"%(self._res_x,x))", "        if y<0 or y>self._res_y-1 : raise IndexError(\"y out of bounds. this voxel field has %s pixels in the y direction and you asked to set %s\"%(self._res_y,y))", "        if z<0 or z>self._res_z-1 : raise IndexError(\"z out of bounds. this voxel field has %s pixels in the z direction and you asked to set %s\"%(self._res_z,z))", "        self._stack[z]._pixels[int(self.res_y*y+x)] = value", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 67,
        "name" : "set",
        "start" : 63
      }, {
        "code" : [ "        if x<0 or x>self._res_x-1 : raise IndexError(\"x out of bounds. this voxel field has %s pixels in the x direction and you asked for %s\"%(self._res_x,x))", "        if y<0 or y>self._res_y-1 : raise IndexError(\"y out of bounds. this voxel field has %s pixels in the y direction and you asked for %s\"%(self._res_y,y))", "        if z<0 or z>self._res_z-1 : raise IndexError(\"z out of bounds. this voxel field has %s pixels in the z direction and you asked for %s\"%(self._res_z,z))", "        return self._stack[z]._pixels[int(self.res_y*y+x)]", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 73,
        "name" : "get",
        "start" : 69
      }, {
        "code" : [ "        \"\"\"", "        returns the centerpoint of the pixel referenced by the given address", "        \"\"\"", "        if x<0 or x>self._res_x-1 : raise IndexError(\"x out of bounds. this voxel field has %s pixels in the x direction and you asked for %s\"%(self._res_x,x))", "        if y<0 or y>self._res_y-1 : raise IndexError(\"y out of bounds. this voxel field has %s pixels in the y direction and you asked for %s\"%(self._res_y,y))", "        if z<0 or z>self._res_z-1 : raise IndexError(\"z out of bounds. this voxel field has %s pixels in the z direction and you asked for %s\"%(self._res_z,z))", "        pt = self.bnds.eval(float(x)/float(self._res_x),float(y)/float(self._res_y),float(z)/float(self._res_z))", "        pt = pt + self.dim_pixel2", "        pt.val = self._stack[z]._pixels[int(self.res_y*y+x)]", "        return pt", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "returns the centerpoint of the pixel referenced by the given address" ]
        },
        "end" : 85,
        "name" : "cpt_at",
        "start" : 75
      }, {
        "code" : [ "        pts = []", "        for z in range(self.res_z): ", "            for y in range(self.res_y): ", "                for x in range(self.res_x):", "                    pts.append(self.cpt_at(x,y,z))", "        return pts" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 93,
        "name" : "to_pts",
        "start" : 87
      } ],
      "documentation" : {
        "description" : [ "Currently rounds down to nearest whole Voxel" ]
      },
      "end" : 93,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/voxel.py",
      "name" : "VoxelField",
      "references" : {
        "classes" : {
          "Geometry" : 1,
          "Interval" : 1,
          "ValueField" : 1,
          "Vec" : 2,
          "VoxelField" : 1
        },
        "functions" : {
          "__init__" : 1,
          "bnds" : 2,
          "cpt_at" : 1,
          "dim_pixel" : 1,
          "dim_pixel2" : 1,
          "get" : 1,
          "max_value" : 1,
          "min_value" : 1,
          "res_x" : 1,
          "res_y" : 1,
          "res_z" : 1,
          "set" : 1,
          "to_pts" : 1
        }
      },
      "start" : 5
    },
    "b4047e9e-4be0-4235-be87-3b664c972820" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_cs.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" CS Constructor.", "           ", "            :param a: Point or decimal number.", "            :type a: Point or float", "            :param b: None or decimal number.", "            :type b: None or float", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: Coordinate system.", "            :rtype: Coordinate system", "        \"\"\"", "        #TODO: write docstring detailing the different ways of constructing a CS", "        #TODO: make axes private and provide getters and setters that maintain orthogonality and right-handedness", "        pt,vec_x,vec_y = Point(), Vec(1,0), Vec(0,1)", "        if all( hasattr(a,i) for i in ['x','y','z'] ) :", "            # a is something that acts like a point", "            pt=a", "            if b is not None : vec_x = b", "            if c is not None : vec_y = c", "            #TODO: handle situation when we've been passed three points", "        else :", "            # a cannot act like a point, let's try to make a point out of a,b,c", "            pt = Point(a,b,c)", "", "        #try: self.origin = pt.basis_applied()", "        #except : self.origin = pt", "        self.origin = pt", "        ", "        if vec_x.length == 0 : raise GeometricError(\"vec_x is a Vec of length 0\")", "        if vec_y.length == 0 : raise GeometricError(\"vec_y is a Vec of length 0\")", "", "        self.x_axis = vec_x.normalized()", "        self.z_axis = self.x_axis.cross(vec_y).normalized()", "        self.y_axis = self.z_axis.cross(self.x_axis).normalized()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "CS Constructor." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "Coordinate system",
          "rvalue" : "Coordinate system.\n",
          "types" : {
            "a" : "Point or float\n",
            "b" : "None or float\n",
            "c" : "None or float\n"
          }
        },
        "end" : 49,
        "name" : "__init__",
        "start" : 15
      }, {
        "code" : [ "        \"\"\" Overloads the equal **(==)**  operator for position and orientation of this CS as compared to the given CS.", "        ", "            :param other: CS to be compared.", "            :type other: CS", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"", "        try:", "            return self.origin == other.origin and self.x_axis == other.x_axis and  self.y_axis == other.y_axis and  self.z_axis == other.z_axis", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the equal **(==)**  operator for position and orientation of this CS as compared to the given CS." ],
          "parameters" : {
            "other" : "CS to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "CS\n"
          }
        },
        "end" : 61,
        "name" : "__eq__",
        "start" : 51
      }, {
        "code" : [ "        \"\"\" Overloads the not equal **(!=)** operator for position and orientation of this CS as compared to the given CS.", "        ", "            :param other: CS to be compared.", "            :type other: CS", "            :result: Boolean result of comparison.", "            :rtype: bool", "", "        \"\"\"", "        return not self == other", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the not equal **(!=)** operator for position and orientation of this CS as compared to the given CS." ],
          "parameters" : {
            "other" : "CS to be compared.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "CS\n"
          }
        },
        "end" : 74,
        "name" : "__ne__",
        "start" : 65
      }, {
        "code" : [ "        \"\"\"| Overloads the addition **(+)** operator. ", "           | Translates this CS by adding the given Vec to the origin of this CS and returns this CS", "        ", "           :param other: Vec to be added", "           :type other: Vec", "           :result: this CS.", "           :rtype: CS", "           ", "           ::", "                ", "                cs + vec", "        \"\"\"", "        self.origin += other", "        return self", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the addition **(+)** operator.", "| Translates this CS by adding the given Vec to the origin of this CS and returns this CS" ],
          "parameters" : {
            "other" : "Vec to be added\n"
          },
          "rtype" : "CS\n\n",
          "rvalue" : "this CS.\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 91,
        "name" : "__add__",
        "start" : 77
      }, {
        "code" : [ "        return \"cs o[{0},{1},{2}] n[{3},{4},{5}]\".format(self.origin.x,self.origin.y,self.origin.z,self.z_axis.x,self.z_axis.y,self.z_axis.z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 95,
        "name" : "__repr__",
        "start" : 94
      }, {
        "code" : [ "        \"\"\" Evaluates the given coordinates (or coordinates contained within a given Point) relative to this CS and returns a Point.", "            ", "            :param a: Point or decimal number.", "            :type a: Point or float", "            :param b: None or decimal number.", "            :type b: None or float", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: Point in world coordinates.", "            :rtype: Point", "            ", "        \"\"\"", "        try:", "            x,y,z = a.x,a.y,a.z", "        except:", "            x,y,z = a,b,c", "        return Point(self.origin + ((self.x_axis*x)+(self.y_axis*y)+(self.z_axis*z)))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates the given coordinates (or coordinates contained within a given Point) relative to this CS and returns a Point." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Point in world coordinates.\n",
          "types" : {
            "a" : "Point or float\n",
            "b" : "None or float\n",
            "c" : "None or float\n"
          }
        },
        "end" : 114,
        "name" : "eval",
        "start" : 97
      }, {
        "code" : [ "        \"\"\" Evaluates the given coordinates (or coordinates contained within a given Point) and returns a Vector between the origin of this CS and the point.", "            ", "            :param a: Point or decimal number.", "            :type a: Point or float", "            :param b: None or decimal number.", "            :type b: None or float", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: Vector in this CS.", "            :rtype: Vec", "            ", "        \"\"\"", "        try:", "            x,y,z = a.x,a.y,a.z", "        except:", "            x,y,z = a,b,c", "        ", "        v = Vec(self.origin,Point(x,y,z)) ", "        xx = v.dot(self.x_axis)", "        yy = v.dot(self.y_axis)", "        zz = v.dot(self.z_axis)", "", "        return Vec(xx,yy,zz)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates the given coordinates (or coordinates contained within a given Point) and returns a Vector between the origin of this CS and the point." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "Vec",
          "rvalue" : "Vector in this CS.\n",
          "types" : {
            "a" : "Point or float\n",
            "b" : "None or float\n",
            "c" : "None or float\n"
          }
        },
        "end" : 139,
        "name" : "deval",
        "start" : 116
      }, {
        "code" : [ "        \"\"\" Returns a Point relative to this CS given three cylindrical coordinates.", "        ", "            :param radius: number representing the distance of the resulting Point from the origin of this CS.", "            :type radius: float", "            :param radians: number representing the rotation angle (in radians) of the resulting Point measured from the x-axis of this CS.", "            :type radians: float", "            :param z: number representing the distance of the resulting Point from the xy_plane of this CS.", "            :type z: float", "            :result: A Point in a cylindrical space.", "            :rtype: Point", "            ", "        \"\"\"", "        pt = Point( radius * math.cos(radians), radius * math.sin(radians), z)", "        return self.eval(pt)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a Point relative to this CS given three cylindrical coordinates." ],
          "parameters" : {
            "radians" : "number representing the rotation angle (in radians) of the resulting Point measured from the x-axis of this CS.\n",
            "radius" : "number representing the distance of the resulting Point from the origin of this CS.\n",
            "z" : "number representing the distance of the resulting Point from the xy_plane of this CS.\n"
          },
          "rtype" : "Point",
          "rvalue" : "A Point in a cylindrical space.\n",
          "types" : {
            "radians" : "float\n",
            "radius" : "float\n",
            "z" : "float\n"
          }
        },
        "end" : 155,
        "name" : "eval_cyl",
        "start" : 141
      }, {
        "code" : [ "        \"\"\" Evaluates the given coordinates (or coordinates contained within a given Point) and returns a tuple containing the cylindrical coordinate representation of this Point relative to this CS.", "            ", "            :param a: Point or decimal number.", "            :type a: Point or float", "            :param b: None or decimal number.", "            :type b: None or float", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: Tuple of cylindrical coordinates - radius, radians, z.", "            :rtype: (float, float, float)", "            ", "        \"\"\"", "        vec = self.deval(a,b,c)", "        z = vec.z", "        vec.z = 0", "        radius = vec.length", "        ang = vec.angle(self.x_axis)", "", "        vec_lcl = self.deval(a,b,c)", "        z = vec_lcl.z", "        vec_lcl.z = 0", "        radius = vec_lcl.length", "    ", "        vec_gbl = Vec(self.origin,self.eval(vec_lcl.x,vec_lcl.y))", "        ang = vec_gbl.angle(self.x_axis)", "", "        if not self.x_axis.is_parallel(vec_gbl):", "            crs = self.x_axis.cross(vec_gbl)", "            if crs.angle(self.z_axis) > math.pi/2 : ang = math.pi*2-ang", "", "        return(radius,ang,z)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates the given coordinates (or coordinates contained within a given Point) and returns a tuple containing the cylindrical coordinate representation of this Point relative to this CS." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "(float, float, float)",
          "rvalue" : "Tuple of cylindrical coordinates - radius, radians, z.\n",
          "types" : {
            "a" : "Point or float\n",
            "b" : "None or float\n",
            "c" : "None or float\n"
          }
        },
        "end" : 188,
        "name" : "deval_cyl",
        "start" : 157
      }, {
        "code" : [ "        \"\"\" Returns a Point relative to this CS given three spherical coordinates.", "        ", "            :param rho: number representing the distance of the resulting Point from the origin of this CS.", "            :type rho: float", "            :param phi: number representing the polar coordinate running from 0 to pi (colatitude).", "            :type phi: float", "            :param theta: number representing the azimuthal coordinate running from 0 to 2pi (longitude).", "            :type theta: float", "            :result: a Point in a spherical space.", "            :rtype: point", "            ", "        \"\"\"", "        x = rho*math.sin(phi)*math.cos(theta)", "        y = rho*math.sin(phi)*math.sin(theta)", "        z = rho*math.cos(phi)", "        ", "        return self.eval(Point(x,y,z))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a Point relative to this CS given three spherical coordinates." ],
          "parameters" : {
            "phi" : "number representing the polar coordinate running from 0 to pi (colatitude).\n",
            "rho" : "number representing the distance of the resulting Point from the origin of this CS.\n",
            "theta" : "number representing the azimuthal coordinate running from 0 to 2pi (longitude).\n"
          },
          "rtype" : "point",
          "rvalue" : "a Point in a spherical space.\n",
          "types" : {
            "phi" : "float\n",
            "rho" : "float\n",
            "theta" : "float\n"
          }
        },
        "end" : 207,
        "name" : "eval_sph",
        "start" : 190
      }, {
        "code" : [ "        \"\"\" Evaluates the given coordinates (or coordinates contained within a given Point) and returns a tuple containing the spherical coordinate representation of this Point relative to this CS.", "            ", "            :param a: Point or decimal number.", "            :type a: Point or float.", "            :param b: None or decimal number.", "            :type b: None or float.", "            :param c: None or decimal number.", "            :type c: None or float", "            :result: Tuple of spherical coordinates - radius, longitude, colatitude", "            :rtype: (float, float, float)", "        ", "        \"\"\"", "        ", "        vec = self.deval(a,b,c)", "        rho = vec.length", "        theta = math.radians((180/math.pi)*math.atan2(-vec.y, -vec.x)+180)", "        phi = Vec.uz().angle(vec)", "        ", "        return (rho, phi, theta)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates the given coordinates (or coordinates contained within a given Point) and returns a tuple containing the spherical coordinate representation of this Point relative to this CS." ],
          "parameters" : {
            "a" : "Point or decimal number.\n",
            "b" : "None or decimal number.\n",
            "c" : "None or decimal number.\n"
          },
          "rtype" : "(float, float, float)",
          "rvalue" : "Tuple of spherical coordinates - radius, longitude, colatitude\n",
          "types" : {
            "a" : "Point or float.\n",
            "b" : "None or float.\n",
            "c" : "None or float\n"
          }
        },
        "end" : 228,
        "name" : "deval_sph",
        "start" : 209
      }, {
        "code" : [ "    def xform(self):", "        \"\"\" Returns the Xform that corresponds to the transformation from world space to CS space.", "        ", "        \"\"\"", "        from .dc_xform import Xform", "        return Xform.change_basis(CS(), self)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Xform that corresponds to the transformation from world space to CS space." ]
        },
        "end" : 236,
        "name" : "xform",
        "start" : 230
      }, {
        "code" : [ "    def ixform(self): ", "        \"\"\" Returns the Xform that corresponds to the transformation from CS space to world space.", "        ", "        \"\"\"", "        from .dc_xform import Xform", "        return Xform.change_basis(self, CS())", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Xform that corresponds to the transformation from CS space to world space." ]
        },
        "end" : 244,
        "name" : "ixform",
        "start" : 238
      }, {
        "code" : [ "    def xy_plane(self):", "        \"\"\" Returns the xy plane.", "        ", "        \"\"\"", "        return Plane(self.origin,self.z_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the xy plane." ]
        },
        "end" : 251,
        "name" : "xy_plane",
        "start" : 246
      }, {
        "code" : [ "    def xz_plane(self):", "        \"\"\" Returns the xz plane.", "        ", "        \"\"\"", "        return Plane(self.origin,self.y_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the xz plane." ]
        },
        "end" : 258,
        "name" : "xz_plane",
        "start" : 253
      }, {
        "code" : [ "    def yz_plane(self):", "        \"\"\" Returns the yz plane.", "        ", "        \"\"\"", "        return Plane(self.origin,self.x_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the yz plane." ]
        },
        "end" : 265,
        "name" : "yz_plane",
        "start" : 260
      }, {
        "code" : [ "    def x_ray(self):", "        \"\"\" Returns a ray along the x-axis.", "        \"\"\"", "        from .dc_line import Ray", "        return Ray(self.origin,self.x_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a ray along the x-axis." ]
        },
        "end" : 272,
        "name" : "x_ray",
        "start" : 267
      }, {
        "code" : [ "    def y_ray(self):", "        \"\"\" Returns a ray along the y-axis.", "        \"\"\"", "        from .dc_line import Ray", "        return Ray(self.origin,self.y_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a ray along the y-axis." ]
        },
        "end" : 279,
        "name" : "y_ray",
        "start" : 274
      }, {
        "code" : [ "    def z_ray(self):", "        \"\"\" Returns a ray along the z-axis.", "        \"\"\"", "        from .dc_line import Ray", "        return Ray(self.origin,self.z_axis)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a ray along the z-axis." ]
        },
        "end" : 286,
        "name" : "z_ray",
        "start" : 281
      }, {
        "code" : [ "    def xAxis(self): ", "        \"\"\" depreciated", "        \"\"\"", "        warnings.warn(\"cs.xAxis depreciated. please use CS.x_axis instead\")", "        return self.x_axis", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "depreciated" ]
        },
        "end" : 293,
        "name" : "xAxis",
        "start" : 288
      }, {
        "code" : [ "    def yAxis(self): ", "        \"\"\" depreciated", "        \"\"\"", "        warnings.warn(\"cs.yAxis depreciated. please use CS.y_axis instead\")", "        return self.y_axis", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "depreciated" ]
        },
        "end" : 300,
        "name" : "yAxis",
        "start" : 295
      }, {
        "code" : [ "    def zAxis(self): ", "        \"\"\" depreciated", "        \"\"\"", "        warnings.warn(\"cs.zAxis depreciated. please use CS.z_axis instead\")", "        return self.z_axis", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "depreciated" ]
        },
        "end" : 307,
        "name" : "zAxis",
        "start" : 302
      }, {
        "code" : [ "    def on_xy(x=0,y=0,x_vec=None,rot=None):", "        \"\"\" Returns a coordinate system on the world xy plane. Optionally, one may define the origin_x and origin_y of the resulting CS. One may also define ONE (but not both) of the following: ", "            ", "            * a vector that controls the rotation of the resulting CS on the xy_plane. The z coordinate of this vector will be ignored.", "            * a rotation value (0->2PI) that does the same thing", "        ", "            :param x: x coordinate of CS origin.", "            :type x: float", "            :param y: y coordinate of CS origin.", "            :type y: float", "            :param x_vec: A vector that controls the rotation of the CS.", "            :type x_vec: Vec", "            :param rot: A rotation value between 0 and 2PI.", "            :type rot: float", "            :result: Coordinate system on the world xy plane.", "            :rtype: Coordinate system.", "            ", "        \"\"\"", "", "        if x_vec is not None and rot is not None : raise GeometricError(\"You may specify *only* one of the following: x_vec, rotation\")", "        if rot is not None:", "            x_vec = Vec(math.cos(rot),math.sin(rot))", "        if x_vec is None:", "            x_vec = Vec(1,0)", "        x_vec.z = 0", "        return CS(Point(x,y,0),x_vec,x_vec.cross(Vec(0,0,-1)))", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a coordinate system on the world xy plane. Optionally, one may define the origin_x and origin_y of the resulting CS. One may also define ONE (but not both) of the following:", "* a vector that controls the rotation of the resulting CS on the xy_plane. The z coordinate of this vector will be ignored.", "* a rotation value (0->2PI) that does the same thing" ],
          "parameters" : {
            "rot" : "A rotation value between 0 and 2PI.\n",
            "x" : "x coordinate of CS origin.\n",
            "x_vec" : "A vector that controls the rotation of the CS.\n",
            "y" : "y coordinate of CS origin.\n"
          },
          "rtype" : "Coordinate system.",
          "rvalue" : "Coordinate system on the world xy plane.\n",
          "types" : {
            "rot" : "float\n",
            "x" : "float\n",
            "x_vec" : "Vec\n",
            "y" : "float\n"
          }
        },
        "end" : 336,
        "name" : "on_xy",
        "start" : 310
      }, {
        "code" : [ "    def on_xz(x=0,z=0,x_vec=None,rot=None):", "        \"\"\" Returns a coordinate system on the world xz plane. Optionally, one may define the origin_x and origin_z of the resulting CS. One may also define ONE (but not both) of the following: ", "        ", "            * a vector that controls the rotation of the resulting CS on the xz_plane. The y coordinate of this vector will be ignored.", "            * a rotation value (0->2PI) that does the same thing", "            ", "            :param x: x coordinate of CS origin.", "            :type x: float", "            :param z: z coordinate of CS origin.", "            :type z: float", "            :param x_vec: A vector that controls the rotation of the CS.", "            :type x_vec: Vec", "            :param rot: A rotation value between 0 and 2PI.", "            :type rot: float", "            :result: Coordinate system on the world xz plane.", "            :rtype: Coordinate system.         ", "        \"\"\"", "", "        if x_vec is not None and rot is not None : raise GeometricError(\"You may specify *only* one of the following: x_vec, rotation\")", "        if rot is not None:", "            x_vec = Vec(math.cos(rot),0,math.sin(rot))", "        if x_vec is None:", "            x_vec = Vec(0,0,1)", "        x_vec.y = 0", "        return CS(Point(x,0,z),x_vec,x_vec.cross(Vec(0,1,0)))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a coordinate system on the world xz plane. Optionally, one may define the origin_x and origin_z of the resulting CS. One may also define ONE (but not both) of the following:", "* a vector that controls the rotation of the resulting CS on the xz_plane. The y coordinate of this vector will be ignored.", "* a rotation value (0->2PI) that does the same thing" ],
          "parameters" : {
            "rot" : "A rotation value between 0 and 2PI.\n",
            "x" : "x coordinate of CS origin.\n",
            "x_vec" : "A vector that controls the rotation of the CS.\n",
            "z" : "z coordinate of CS origin.\n"
          },
          "rtype" : "Coordinate system.         ",
          "rvalue" : "Coordinate system on the world xz plane.\n",
          "types" : {
            "rot" : "float\n",
            "x" : "float\n",
            "x_vec" : "Vec\n",
            "z" : "float\n"
          }
        },
        "end" : 363,
        "name" : "on_xz",
        "start" : 338
      }, {
        "code" : [ "    def on_yz(y=0,z=0,x_vec=None,rot=None):", "        \"\"\" Returns a coordinate system on the world yz plane. Optionally, one may define the origin_y and origin_z of the resulting CS. One may also define ONE (but not both) of the following: ", "        ", "            * a vector that controls the rotation of the resulting CS on the yz_plane. The x coordinate of this vector will be ignored.", "            * a rotation value (0->2PI) that does the same thing", "            ", "            :param y: y coordinate of CS origin.", "            :type y: float", "            :param z: z coordinate of CS origin.", "            :type z: float", "            :param x_vec: A vector that controls the rotation of the CS.", "            :type x_vec: Vec", "            :param rot: a rotation value between 0 and 2PI", "            :type rot: float", "            :result: Coordinate system on the world yz plane.", "            :rtype: Coordinate system        ", "        \"\"\"", "", "        if x_vec is not None and rot is not None : raise GeometricError(\"You may specify *only* one of the following: x_vec, rotation\")", "        if rot is not None:", "            x_vec = Vec(0,math.cos(rot),math.sin(rot))", "        if x_vec is None:", "            x_vec = Vec(0,0,1)", "        x_vec.x = 0", "        return CS(Point(0,y,z),x_vec,x_vec.cross(Vec(-1,0,0)))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a coordinate system on the world yz plane. Optionally, one may define the origin_y and origin_z of the resulting CS. One may also define ONE (but not both) of the following:", "* a vector that controls the rotation of the resulting CS on the yz_plane. The x coordinate of this vector will be ignored.", "* a rotation value (0->2PI) that does the same thing" ],
          "parameters" : {
            "rot" : "a rotation value between 0 and 2PI\n",
            "x_vec" : "A vector that controls the rotation of the CS.\n",
            "y" : "y coordinate of CS origin.\n",
            "z" : "z coordinate of CS origin.\n"
          },
          "rtype" : "Coordinate system        ",
          "rvalue" : "Coordinate system on the world yz plane.\n",
          "types" : {
            "rot" : "float\n",
            "x_vec" : "Vec\n",
            "y" : "float\n",
            "z" : "float\n"
          }
        },
        "end" : 390,
        "name" : "on_yz",
        "start" : 365
      } ],
      "documentation" : {
        "description" : [ "a ortho coordinate system class", "a simple orthonormal cs floating around in R3", "can describe any translation and rigid-body manipulation of the R3" ],
        "images" : {
          "developed-1&jpg" : "parameter spaces\n",
          "parametric1&jpg" : "parameter spaces\n",
          "scales-final-1&jpg" : "parameter spaces"
        }
      },
      "end" : 390,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_cs.py",
      "name" : "CS",
      "references" : {
        "classes" : {
          "Basis" : 1,
          "CS" : 6,
          "Geometry" : 1,
          "Plane" : 3,
          "Point" : 9,
          "Ray" : 3,
          "Vec" : 15,
          "Xform" : 2
        },
        "functions" : {
          "__add__" : 1,
          "__eq__" : 1,
          "__init__" : 1,
          "__ne__" : 1,
          "__repr__" : 1,
          "deval" : 1,
          "deval_cyl" : 1,
          "deval_sph" : 1,
          "eval" : 1,
          "eval_cyl" : 1,
          "eval_sph" : 1,
          "ixform" : 1,
          "on_xy" : 1,
          "on_xz" : 1,
          "on_yz" : 1,
          "xAxis" : 1,
          "x_ray" : 1,
          "xform" : 1,
          "xy_plane" : 1,
          "xz_plane" : 1,
          "yAxis" : 1,
          "y_ray" : 1,
          "yz_plane" : 1,
          "zAxis" : 1,
          "z_ray" : 1
        }
      },
      "start" : 6
    },
    "b63f9b18-8e18-4cf6-a030-5a1882c4d19f" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/classical_surfaces.py",
      "definitions" : [ {
        "code" : [ "        '''", "        the given generator curve will be translated along the given directrix curve", "        '''", "        self.genx = generator", "        self.dirx = directrix", "        self.origin = origin #intersection of the generator and directrix curves", "", "        def func(u,v):                 ", "            vec = self.dirx.eval(u) - origin", "            return self.genx.eval(v) + vec", "            ", "        try:", "            tol_u = self.dirx.tol", "            tol_v = self.genx.tol", "        except:", "            tol_u = 1.0/10.0", "            tol_v = 1.0/10.0", "", "        super(TranslationalSurface,self).__init__(func,Interval(), Interval(),tol_u,tol_v)", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "the given generator curve will be translated along the given directrix curve" ]
        },
        "end" : 126,
        "name" : "__init__",
        "start" : 107
      }, {
        "code" : [ "        pln_crv = self.genx.deval_pln(u)", "", "        pt = self._func(u,v)", "        return Plane(pt, pln_crv.normal.cross(self.vec)) ### this will break, no longer uses self.vec", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 132,
        "name" : "deval_pln",
        "start" : 128
      }, {
        "code" : [ "        # we could re-implement deval_crv here in the context of this classical surface type, or we could pass the buck to our general Surface class", "        return super(ClassicalSurface,self).deval_crv(u,v)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 137,
        "name" : "deval_crv",
        "start" : 135
      }, {
        "code" : [ "        # TODO: implement", "        # we could re-implement deval_crv here in the context of this classical surface type, or we could pass the buck to our general Surface class", "        if v_val is None:", "            # we're plotting a u-iso, return the tranlated directrix", "            pass", "        else :", "             # we're plotting a v-iso, return the translated generator", "             pass", "", "        return super(ClassicalSurface,self).isocurve(u_val,v_val)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 149,
        "name" : "isocurve",
        "start" : 139
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 149,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/classical_surfaces.py",
      "name" : "TranslationalSurface",
      "references" : {
        "classes" : {
          "ClassicalSurface" : 3,
          "Interval" : 2,
          "Plane" : 1,
          "TranslationalSurface" : 2
        },
        "functions" : {
          "__init__" : 1,
          "deval_crv" : 1,
          "deval_pln" : 1,
          "func" : 1,
          "isocurve" : 1
        }
      },
      "start" : 105
    },
    "b68e93c5-0bb8-4168-ac36-2cf404f8c7c0" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "#determine \"alpha\", tilt angle for Villarceau circles", "alpha = asin(r/R) ", "cos_alpha = cos(alpha)", "sin_alpha = sin(alpha)", "cos_gamma = -r*sin(v)/(R*sin_alpha)", "#determine \"psi\"", "if (v > 0.5*pi) and (v < 1.5*pi):", "    psi_v1 = atan2(-R*sqrt(1-cos_gamma*cos_gamma) + r, R*cos_alpha*cos_gamma)", "    psi_v2 = atan2(R*sqrt(1-cos_gamma*cos_gamma) - r, R*cos_alpha*cos_gamma)", "else:", "    psi_v1 = atan2(R*sqrt(1-cos_gamma*cos_gamma) + r, R*cos_alpha*cos_gamma)", "    psi_v2 = atan2(-R*sqrt(1-cos_gamma*cos_gamma) - r, R*cos_alpha*cos_gamma)", "#define a Xform transformation to rotate by \"psi\"", "rot_psi_v1 = Xform.rotation(axis = Vec(0,0,1), angle = -psi_v1)", "rot_psi_v2 = Xform.rotation(axis = Vec(0,0,1), angle = -psi_v2)", "" ],
          "end" : 40,
          "start" : 24
        },
        "description" : "\nCalculation of Relevant Angles\n",
        "end" : 24,
        "start" : 22
      }, {
        "code" : {
          "content" : [ "def func1(t):", "    rho = R + r*cos(v)", "    x = rho*cos(t)", "    y = rho*sin(t)", "    z = r*sin(v)", "    pt_out = Point(x,y,z)", "    return pt_out", "   " ],
          "end" : 53,
          "start" : 45
        },
        "description" : "\nParallel Circle\nThe parameter t acts as angle \"theta\"\n[noprint]\n",
        "end" : 45,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "def func2(t):", "    x = R + r*cos(t)", "    y = 0", "    z = r*sin(t)", "    pt_out = Point(x,y,z)", "    return pt_out", "" ],
          "end" : 65,
          "start" : 58
        },
        "description" : "\nMeridian Circle\nThe parameter t acts as angle \"phi\"\n[noprint]\n",
        "end" : 58,
        "start" : 54
      }, {
        "code" : {
          "content" : [ "def func_v1(t):", "    # define X, Y, and Z values of tilted circle", "    x = R*cos_alpha*cos(t)", "    y = R*sin(t) + r", "    z = -R*sin_alpha*cos(t)", "    # rotate to go through corresponding point along specific merdian", "    pt_out = Point(x,y,z)*rot_psi_v1", "    return pt_out", "" ],
          "end" : 78,
          "start" : 69
        },
        "description" : "\nVillarceau Circle #1\nParameterization for circle associated with positive tilt sign (+alpha)\n",
        "end" : 69,
        "start" : 66
      }, {
        "code" : {
          "content" : [ "def func_v2(t):", "    x = R*cos_alpha*cos(t)", "    y = R*sin(t) - r", "    z = -R*sin_alpha*cos(t)", "    pt_out = Point(x,y,z)*rot_psi_v2", "    return pt_out", "" ],
          "end" : 89,
          "start" : 82
        },
        "description" : "\nVillarceau Circle #2\nParameterization for circle associated with negative tilt sign (-alpha)\n",
        "end" : 82,
        "start" : 79
      }, {
        "code" : {
          "content" : [ "rot = Xform.rotation(axis = Vec(0,0,1), angle = u)", "pt_out = func1(0)*rot", "circ1 = Circle.thru_pts(func1(0), func1(0.5*pi), func1(pi))*rot", "circ2 = Circle.thru_pts(func2(0), func2(0.5*pi), func2(pi))*rot", "circ3 = Circle.thru_pts(func_v1(0), func_v1(0.5*pi), func_v1(pi))*rot", "circ4 = Circle.thru_pts(func_v2(0), func_v2(0.5*pi), func_v2(pi))*rot", "" ],
          "end" : 101,
          "start" : 94
        },
        "description" : "\nDerivation of 4 Circles Through Point\nCalculates the circles for the fixed CS then rotates\n[noprint]\n",
        "end" : 94,
        "start" : 90
      }, {
        "code" : {
          "content" : [ "def villarceau(t, psi):", "    x = R*cos_alpha*cos(t)", "    y = R*sin(t) + r", "    z = -R*sin_alpha*cos(t)", "    rot_psi = Xform.rotation(axis = Vec(0,0,1), angle = -psi)", "    pt_out = Point(x1,y1,z1)*rot_psi", "    return pt_out", "" ],
          "end" : 114,
          "start" : 106
        },
        "description" : "\nVillarceau #1 with \"psi\" dependency\nUsed to create alternate parametrization of torus\n[noprint]\n",
        "end" : 106,
        "start" : 102
      }, {
        "code" : {
          "content" : [ "def torus(u,v):", "    cos_gam = -r*sin(v)/(R*sin_alpha)", "    if (v > 0.5*pi) and (v < 1.5*pi):", "        psi_v = atan2(-R*sqrt(1-cos_gam*cos_gam) + r, R*cos_alpha*cos_gam)", "    else:", "        psi_v = atan2(R*sqrt(1-cos_gam*cos_gam) + r, R*cos_alpha*cos_gam)", "    return villarceau(u, psi_v)" ],
          "end" : 124,
          "start" : 118
        },
        "description" : "\nAlternate Parametrization of Torus\nIsocurves are Villarceau Circles\n",
        "end" : 118,
        "start" : 115
      } ],
      "documentation" : {
        "description" : [ "4.03.L04a", "Exploration of a Torus and its properties: finding the four families of curves on the torus.", "Draws the 4 circles -- parallel, meridian, 2 Villarceau circles", "given a point on the torus." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Pre-Rational Torus Studies/4.03.L04a.py",
      "name" : "4.03.L04a.py",
      "references" : {
        "classes" : {
          "Circle" : 4,
          "Point" : 5,
          "R" : 26,
          "Vec" : 4,
          "Xform" : 4
        }
      },
      "required" : [ "R (float) - major radius", "r (float) - minor radius", "u,v(float, float) - domain coordinates corresponding to a point on the torus parametrized by", "x = (R + r*cos(v))*cos(u)", "y = (R + r*cos(v))*sin(u)", "z = r*sin(v)", "domain = [0, 2*pi]x[0, 2*pi]" ],
      "result" : [ "circles ([Circles]) the four circles on the torus going through the point" ]
    },
    "b6bec15f-12a8-4def-80f6-dff1bf6bc0e8" : {
      "documentation" : {
        "description" : [ "4.07.L05b", "Given a mesh on the Plane and step count, produce a mesh whose vertices have been moved to more relaxed positions." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Mesh Relaxation/4.07.L05b.py",
      "name" : "4.07.L05b.py",
      "references" : {
        "classes" : {
          "Mesh" : 1,
          "Point" : 1
        }
      },
      "required" : [ "msh (Mesh) The mesh to relax", "steps (int) The number of relaxation recursions" ],
      "result" : [ "new_msh (Mesh) A relaxed mesh" ]
    },
    "b774b160-11c2-46ff-af10-84f6980e5ed9" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# super lists to ouput", "ln=[[]]", "points = [cp]", "", "# for every step on an Interval:", "for t in Interval().divide(steps):", "    # create a point on a spiral", "    u = cp.x + t*math.cos(2*math.pi*turn_cnt*t)", "    v = cp.y + t*math.sin(2*math.pi*turn_cnt*t)", "    # if it lies outside the domain of the surface", "    if u < 0 or u > 1 or v < 0 or v > 1 :", "        # create a new polyline and add any previous points to the super list", "        points.extend(ln[-1])", "        ln.append([])", "    # else find that point on the surface", "    else: ", "        spi_pt = surf.eval(u,v)", "        # if the max points of a polyline has not been met:", "        if len(ln[-1]) < (pts_per_turn + offset):", "            # if it is not too close to any previous point:", "            if spi_pt.distance(Point.near(spi_pt, points))> tool_diameter:", "                # add it to the polyline", "                ln[-1].append(spi_pt)", "            # else: create a new polyline and add any previous points to the super list", "            else:", "                points.extend(ln[-1])", "                ln.append([])", "        # else: create a new polyline and add any previous points to the super list", "        else:", "            points.extend(ln[-1])", "            ln.append([])", "" ],
          "end" : 46,
          "start" : 14
        },
        "description" : " \nGiven a surface, creates toolpaths on that surface in Cartesian space that maintain a physical distance from one another.\n",
        "end" : 14,
        "start" : 12
      } ],
      "documentation" : {
        "description" : [ "4.05.L03c", "Create a series of toolpaths which maintain a physical distance from one another in Cartesian space as opposed to domain space." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Toolpathing/4.05.L03c.py",
      "name" : "4.05.L03c.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 1
        }
      },
      "required" : [ "surf (Surface) Surface to create toolpaths with." ],
      "result" : [ "ln ([PLines]) Toolpaths." ]
    },
    "b776bd57-b073-4d56-963d-aa9ee6106f0e" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def func(u,v):", "    # create a regular 5 sided RGon of radius 1", "    rg = RGon(5, 1)", "    # create the Interval to be evaluated at each height", "    ival_u = Interval(u, u+v )", "    ", "    pts = []", "    # for each section in the section count", "    for h in Interval().divide(section_count,True):", "        # move the RGon to the appropriate height", "        rg.basis = CS(0,0,height*h)", "        # apply transformations", "        xfs = Xform.scale(math.sin(v*math.pi+1)*0.05+1)", "        xfr = Xform.rotation(angle = v*math.pi/12)", "        rg_h = rg * xfs", "        # evaluate the RGon at the given u,v Interval", "        pts.append(rg_h.eval(ival_u.eval(h)))", "    # create a PLine with all of the evaluated points", "    u_line = PLine(pts)", "    ", "    # evaluate that line at v", "    pt_out = u_line.eval( v )", "    return pt_out", "", "# maintains the form of the mesh throughout its height", "section_count = 10 ", "# create a Surface", "srf = Surface(func, tol_u = 0.05, tol_v = 0.05)", "# create a Mesh representation of the Surface", "srf.surrogate" ],
          "end" : 45,
          "start" : 15
        },
        "description" : "\nDiagrid Tower\nMethod for creating a Surface function by evaluating a PLine modified with mathematical functions. \n",
        "end" : 15,
        "start" : 12
      } ],
      "documentation" : {
        "description" : [ "4.03.L01b", "Evaluate a PGon over a given height, and create a tower with a controlled mesh." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Bespoke Parameterizations/4.03.L01b.py",
      "name" : "4.03.L01b.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 2,
          "PLine" : 1,
          "RGon" : 1,
          "Surface" : 1,
          "Xform" : 2
        }
      },
      "required" : [ "height (float) The height of the tower." ],
      "result" : [ "ret (Mesh) A tower." ]
    },
    "b8e8ddf0-a610-4df6-bcea-896d32091687" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def offset_path(pgon, inner_pgon = None):", "    if not inner_pgon: return [pgon.offset(t_width, True)]", "    else: return [pgon.offset(t_width, True), inner_pgon.offset(t_width)]", "" ],
          "end" : 23,
          "start" : 19
        },
        "description" : "\nOffset Boundary\nOffsets by tool width the outer and inner polygons bounding a planar region\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def run_path(pgons):", "    #sort outer polygon vertices by x value", "    pgon_pts = sorted(list(pgons[0].pts),key=lambda point: point.x)", "    #set starting point to have smallest x value", "    ppt = pgon_pts[0]", "    xsor = Intersector()", "    seg_groups, cur_path = [], []", "    #while x value of current line is within polygon width ", "    while ppt.x < pgon_pts[-1].x:", "        #start line in y-direction with given x value", "        ln = Line(ppt, Vec(0,1))", "        pts = []", "        for pgon in pgons:", "            #add intersection points to the list of line points", "            if xsor.of(ln, pgon): pts.extend([r for r in xsor.results])", "        #sort line points by y value", "        pts.sort(key = lambda pt: pt.y)", "        #create segments from line points that are inside region", "        rng = range(1,len(pts))", "        seg_groups.append([Segment(pts[r], pts[r-1]) for r in rng if r%2==1])", "        #shift x value of next line by tool width", "        ppt += Vec(t_width)", "    ", "    #for each pair of lines:", "    for ln,(gr_a,gr_b) in enumerate(zip(seg_groups[:-1],seg_groups[1:])):", "        #add segments along the first line to our toolpath", "        cur_path.append(gr_a)", "        ln_a, ln_b, rng = len(gr_a), len(gr_b), range(len(gr_a))", "        # exit if the pair does not have same number of segments", "        if not ln_a == ln_b: continue", "        #if odd line, connect startpoints of pair", "        if ln%2!=0: cur_path += [Segment(gr_a[n].spt,gr_b[n].spt) for n in rng]", "        #if even line, connect endpoints of pair ", "        else: cur_path += [Segment(gr_a[n].ept,gr_b[n].ept) for n in rng]", "            ", "    cur_path.extend([seg_groups[0], seg_groups[-1]])", "    return cur_path", "", "#create zigzag toolpath in region between offset pgons", "paths = [run_path(offset_path(pgo,pgi)) for pgi,pgo in zip(pgs_in,pgs_out)]" ],
          "end" : 66,
          "start" : 27
        },
        "description" : "\nZigzag Toolpaths\nCreates zigzag lines in region between polygons running in the y-direction based on tool width\n",
        "end" : 27,
        "start" : 24
      } ],
      "documentation" : {
        "description" : [ "4.05.L06b", "Creates zigzagging toolpaths inside given regions (each bounded by an outer and inner polygon) based on tool width" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/3d Printed Toolpathing/4.05.L06b.py",
      "name" : "4.05.L06b.py",
      "references" : {
        "classes" : {
          "Intersector" : 1,
          "Line" : 1,
          "Segment" : 3,
          "Vec" : 2
        }
      },
      "required" : [ "pgons ([PGons]) List of PGons denoting the outer boundary of each region", "inner_pgons ([PGons]) List of PGons denoting the inner boundary of each region", "t_width (float) tool width" ],
      "result" : [ "paths ([[Segment]]) Toolpaths" ]
    },
    "b9383ccd-07a3-42c8-8150-9c06537f6006" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/solar_geometry.py",
      "definitions" : [ {
        "code" : [ "        self.lat = latitude", "        self.lng = longitude", "        self.tmz = timezone   ", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 11,
        "name" : "__init__",
        "start" : 8
      }, {
        "code" : [ "        altitude, azimuth = self.altazi_at(day_of_year,hour_of_day)", "        x = math.cos(altitude)*math.sin(azimuth)", "        y = math.cos(altitude)*math.cos(azimuth)", "        z = math.sin(altitude)", "        return Vec(x, y, z)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 19,
        "name" : "vec_at",
        "start" : 14
      }, {
        "code" : [ "        altitude, azimuth, d, o = self.angles_at(day_of_year,hour_of_day)", "        return altitude, azimuth", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 23,
        "name" : "altazi_at",
        "start" : 21
      }, {
        "code" : [ "        \"\"\"", "        calculates the following solar position angles for given coordinates, integer day of the year (0->365), local time. ", "        Altitude", "        Azimuth", "        Declination", "        Hour Angle", "        all output in radians", "        \"\"\"", "        alpha = self._calc_alpha(day_of_year, hour_of_day)", "        #calculate Declination Angle", "        declination = 0.396372-22.91327*math.cos(alpha)+4.02543*math.sin(alpha)-0.387205*math.cos(2*alpha)+0.051967*math.sin(2*alpha)-0.154527*math.cos(3*alpha)+0.084798*math.sin(3*alpha)", "        declination_rad = math.radians(declination)", "        ", "        # time correction for solar angle ", "        TC = 0.004297+0.107029*math.cos(alpha)-1.837877*math.sin(alpha)-0.837378*math.cos(2*alpha)-2.340475*math.sin(2*alpha)", "        # calculate Solar Hour Angle, angle between local longitude and solar noon", "        hour_angle = (hour_of_day-12-self.tmz)*(360/24) + self.lng + TC", "        if hour_angle >= 180:", "            hour_angle = hour_angle - 360", "        if hour_angle <= -180:", "            hour_angle = hour_angle + 360", "        hour_angle_rad = math.radians(hour_angle)      ", "        ", "        #calc Altitude Angle", "        lat_rad = math.radians(self.lat)", "        cos_zenith= math.sin(lat_rad)*math.sin(declination_rad)+math.cos(lat_rad)*math.cos(declination_rad)*math.cos(hour_angle_rad)", "        if cos_zenith>1:", "            cos_zenith = 1", "        if cos_zenith<-1:", "            cos_zenith = -1", "", "        zenith_rad = math.acos(cos_zenith)", "        altitude_rad =  math.asin(cos_zenith)", "        ", "        #calc Azimuth angle", "        cos_azimuth = (math.sin(declination_rad)-math.sin(lat_rad)*math.cos(zenith_rad))/(math.cos(lat_rad)*math.sin(zenith_rad))", "        azimuth = math.degrees(math.acos(cos_azimuth))", "        if hour_angle_rad > 0:", "            azimuth = 360-azimuth", "        azimuth_rad = math.radians(azimuth)", "        ", "        return altitude_rad, azimuth_rad, declination_rad, hour_angle_rad", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "calculates the following solar position angles for given coordinates, integer day of the year (0->365), local time.", "Altitude", "Azimuth", "Declination", "Hour Angle", "all output in radians" ]
        },
        "end" : 67,
        "name" : "angles_at",
        "start" : 25
      }, {
        "code" : [ "    def _calc_alpha(day_in, hour_in):", "        \"\"\"", "        calculates alpha = ecliptic longitude, varying from alpha = 0 completing 360 in 1 year.", "        \"\"\"", "        alphaOut = (360/365.25)*(day_in + hour_in/24) ", "        return math.radians(alphaOut)", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "calculates alpha = ecliptic longitude, varying from alpha = 0 completing 360 in 1 year." ]
        },
        "end" : 77,
        "name" : "_calc_alpha",
        "start" : 71
      }, {
        "code" : [ "    def str_to_day_of_year(date_in):", "        \"\"\"", "        converts a date given as \"mo/day\" into a day of year", "        \"\"\"", "        daysInMonth= [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  ", "        (month, day) = date_in.split('/')", "        dayOut = 0;", "        for m in range(1,int(month)):", "            dayOut = dayOut + daysInMonth[m-1]", "        dayOut = dayOut + int(day)", "        return dayOut", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "converts a date given as \"mo/day\" into a day of year" ]
        },
        "end" : 90,
        "name" : "str_to_day_of_year",
        "start" : 79
      }, {
        "code" : [ "    def str_to_decimal_hour(time_in):", "        \"\"\"", "        converts 24h time into a decimal hour", "        \"\"\"", "        (hour, minutes) = time_in.split(':')", "        return  int(hour) + int(minutes)/60.0", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "converts 24h time into a decimal hour" ]
        },
        "end" : 98,
        "name" : "str_to_decimal_hour",
        "start" : 92
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 98,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/solar_geometry.py",
      "name" : "SolarGeom",
      "references" : {
        "classes" : {
          "SolarGeom" : 1,
          "TC" : 2,
          "Vec" : 1
        },
        "functions" : {
          "__init__" : 1,
          "_calc_alpha" : 1,
          "altazi_at" : 1,
          "angles_at" : 1,
          "str_to_day_of_year" : 1,
          "str_to_decimal_hour" : 1,
          "vec_at" : 1
        }
      },
      "start" : 7
    },
    "ba629dbb-6924-4116-9692-333759b685e8" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pt_a = Point(2,3)", "vec_a = Vec(0,1)", "ln_a = Segment(pt_a, vec_a)", "print ln_a", "print \"start point is\" , ln_a.spt", "print \"end point is\" , ln_a.ept", "" ],
          "end" : 22,
          "start" : 15
        },
        "description" : "\nConstruction of a Line Segment\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "vec_b = Vec(0,0,1)", "ln_a.ept = ln_a.ept + vec_b", "print ln_a" ],
          "end" : 27,
          "start" : 25
        },
        "description" : "\nManipulation of a Line Segment\n",
        "end" : 25,
        "start" : 23
      } ],
      "documentation" : {
        "description" : [ "2.01.E01d", "Lines may be constructed in a number of ways:  between two points, given a point and a vector, or by passing numbers indicating the x and y locations of the start and end points." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01d.py",
      "name" : "2.01.E01d.py",
      "references" : {
        "classes" : {
          "Point" : 1,
          "Segment" : 1,
          "Vec" : 2
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "ba87b67a-22ac-421e-bec9-f7efc23a4ef5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#calculate mutual tangency", "cir_ab, pt_ab, pt_ba = Circle.mutually_tangent(cir_a,cir_b,tan_off,True)", "", "#calculate intersection points", "pt_a = cir_a.plane.origin + Vec(0,-1).normalized(cir_a.rad)", "pt_b = cir_b.plane.origin + Vec(0,1).normalized(cir_b.rad)", "", "# create a chain of Arcs", "arc_a = Arc.from_pts(cir_a.plane.origin,pt_a,pt_ab)", "arc_ab = Arc.from_pts(cir_ab.plane.origin,pt_ab,pt_ba)", "arc_b = Arc.from_pts(cir_b.plane.origin,pt_ba,pt_b)", "", "# for every Arc we've created:", "for arc in arcs:", "    for rail in rails:", "        # define a surface evaluation function", "        def func(u,v):", "            vec =  - rail.deval(u)", "            return arc.deval(v) - vec", "        #Create a surface", "        surf = Surface(func)" ],
          "end" : 38,
          "start" : 17
        },
        "description" : "\nSurface of Mutually Tangent Arcs\nGiven two circles and a tangent offset value, create an arc which is tangent to both of them. Chain the results together into a guide rail for a surface\n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.03.F01e", "Given two circles and a tangent offset value, create an arc which is tangent to both of them. Chain the results together into a guide rail for a surface" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Foster Pre-Rational Studies/4.03.F01e.py",
      "name" : "4.03.F01e.py",
      "references" : {
        "classes" : {
          "Arc" : 3,
          "Circle" : 1,
          "Surface" : 1,
          "Vec" : 2
        }
      },
      "required" : [ "arcs ([Arc]) List of Arcs to use as profile Curves.", "rails ([Arc]) List of Arcs to use as rails." ],
      "result" : [ "ret ([Surface]) List of Surfaces." ]
    },
    "bca32d18-04f4-4213-a129-e7eb7353a39e" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/classical_surfaces.py",
      "definitions" : [ {
        "code" : [ "        self.cs = cs", "        self.major_radius = major_radius", "        self.minor_radius = minor_radius", "        self.param_type = param_type", "        def func(u,v):", "            if self.param_type == 1 or self.param_type == 2:", "                #Set v to phi which determines 2 V-circles.  Choose one and let", "                #u traverse pts on that circle", "                phi = v", "                cos_gamma = -self.minor_radius*math.sin(phi)/(self.major_radius*self.sin_alpha)", "                if (phi > 0.5*math.pi) and (phi < 1.5*math.pi):", "                    psi_v1 = math.atan2(-self.major_radius*math.sqrt(1-cos_gamma*cos_gamma) + self.minor_radius, self.major_radius*self.cos_alpha*cos_gamma)", "                else:", "                    psi_v1 = math.atan2(self.major_radius*math.sqrt(1-cos_gamma*cos_gamma) + self.minor_radius, self.major_radius*self.cos_alpha*cos_gamma)", "                #Villarceau #1  (t = \"gamma\")", "                if self.param_type == 1: return self.func_v1(u, psi_v1)", "                #Villarceau #2  (t = \"gamma\")", "                else:return self.func_v2(u, psi_v1)", "                ", "            else:", "                rho = self.major_radius + self.minor_radius*math.cos(v)", "                pt_out = self.cs.eval(Point(rho*math.cos(u), rho*math.sin(u), self.minor_radius*math.sin(v)))", "                return pt_out", "        super(Torus,self).__init__(func,dom_u,dom_v,tol_u,tol_v)", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 180,
        "name" : "__init__",
        "start" : 156
      }, {
        "code" : [ "    def alpha(self): return math.asin(self.minor_radius/self.major_radius)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 183,
        "name" : "alpha",
        "start" : 182
      }, {
        "code" : [ "    def cos_alpha(self): return math.cos(self.alpha)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 186,
        "name" : "cos_alpha",
        "start" : 185
      }, {
        "code" : [ "    def sin_alpha(self): return math.sin(self.alpha)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 189,
        "name" : "sin_alpha",
        "start" : 188
      }, {
        "code" : [ "        x1 = self.major_radius*self.cos_alpha*math.cos(t)", "        y1 = self.major_radius*math.sin(t) + self.minor_radius", "        z1 = -self.major_radius*self.sin_alpha*math.cos(t)", "        rot_psi = Xform.rotation(axis = Vec(0,0,1), angle = -psi)", "        pt_out = self.cs.eval(Point(x1,y1,z1)*rot_psi)", "        return pt_out", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 198,
        "name" : "func_v1",
        "start" : 192
      }, {
        "code" : [ "        x = self.major_radius*self.cos_alpha*math.cos(t)", "        y = self.major_radius*math.sin(t) - self.minor_radius", "        z = -self.major_radius*self.sin_alpha*math.cos(t)", "        rot_psi = Xform.rotation(axis = Vec(0,0,1), angle = -psi)", "        pt_out = self.cs.eval(Point(x,y,z)*rot_psi)", "        return pt_out", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 207,
        "name" : "func_v2",
        "start" : 201
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 207,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/classical_surfaces.py",
      "name" : "Torus",
      "references" : {
        "classes" : {
          "ClassicalSurface" : 1,
          "Point" : 3,
          "Torus" : 2,
          "Vec" : 2,
          "Xform" : 2
        },
        "functions" : {
          "__init__" : 1,
          "alpha" : 1,
          "cos_alpha" : 1,
          "func" : 1,
          "func_v1" : 1,
          "func_v2" : 1,
          "sin_alpha" : 1
        }
      },
      "start" : 153
    },
    "bd1ae758-6429-449d-b4d3-517a3c8ebc2b" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_mesh.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Mesh Constructor.", "", "            :param vertices: The vertices of the mesh.", "            :type vertices: [Point]", "            :param faces: List of ordered faces.", "            :type faces: [int]", "            :param basis: The (optional) basis of the mesh.", "            :type basis: Basis", "            :result: Mesh object.", "            :rtype: Mesh", "            ", "            ::", "            ", "                pts=[", "                    Point(0,0,0),", "                    Point(0,1,0),", "                    Point(1,1,0),", "                    Point(1,0,0),", "                    Point(0,0,1),", "                    Point(0,1,1),", "                    Point(1,1,1),", "                    Point(1,0,1),", "                    ]", "    ", "                quad_faces=[[0,1,2,3],[4,5,6,7],[0,4,5,1],[3,7,6,2]]", "                quadmesh=Mesh(pts,quad_faces)                ", "        \"\"\"", "        super(Mesh,self).__init__(vertices,basis) #HasPts constructor handles initalization of verts and basis", "        self._faces = [] if (faces is None) else faces", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Mesh Constructor." ],
          "parameters" : {
            "basis" : "The (optional) basis of the mesh.\n",
            "faces" : "List of ordered faces.\n",
            "vertices" : "The vertices of the mesh.\n"
          },
          "rtype" : "Mesh\n\n",
          "rvalue" : "Mesh object.\n",
          "types" : {
            "basis" : "Basis\n",
            "faces" : "[int]\n",
            "vertices" : "[Point]\n"
          }
        },
        "end" : 42,
        "name" : "__init__",
        "start" : 13
      }, {
        "code" : [ "    def faces(self): ", "        \"\"\" Returns a list of mesh faces.", "        ", "            :result: List of mesh faces.", "            :rtype: list", "        \"\"\"", "        return self._faces", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a list of mesh faces." ],
          "rtype" : "list",
          "rvalue" : "List of mesh faces.\n"
        },
        "end" : 52,
        "name" : "faces",
        "start" : 45
      }, {
        "code" : [ "        \"\"\" Adds a face to the mesh.", "        ", "            :param a,b,c,d: Face to be added to the list of faces.", "            :type a,b,c,d: int.", "            :result: Modifies list of faces.", "            :rtype: None", "            ", "            ::", "            ", "                quadmesh.add_face(4,5,6,7)", "        \"\"\"", "        #TODO: add lists of faces just the same", "        ", "        if max(a,b,c,d) < len(self.pts):", "            if (d>=0) : self._faces.append([a,b,c,d])" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Adds a face to the mesh." ],
          "parameters" : {
            "a,b,c,d" : "Face to be added to the list of faces.\n"
          },
          "rtype" : "None\n\n",
          "rvalue" : "Modifies list of faces.\n",
          "types" : {
            "a,b,c,d" : "int.\n"
          }
        },
        "end" : 68,
        "name" : "add_face",
        "start" : 54
      }, {
        "code" : [ "        \"\"\" Returns the points of a given face.", "        ", "            :param index: Face's index", "            :type index: int", "            :returns: Vertices.", "            :rtype: Point", "            ", "            ::", "            ", "                quadmesh.face_pts(0)", "        \"\"\"", "        return [self.pts[i] for i in self.faces[index]]", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the points of a given face." ],
          "parameters" : {
            "index" : "Face's index\n"
          },
          "rtype" : "Point\n\n",
          "types" : {
            "index" : "int\n"
          }
        },
        "end" : 84,
        "name" : "face_pts",
        "start" : 72
      }, {
        "code" : [ "        \"\"\" Returns the centroids of individual mesh faces.", "        ", "            :param index: Index of a face.", "            :type index: int", "            :returns: The centroid of a face.", "            :rtype: Point", "            ", "            ::", "            ", "                quadmesh.face_centroid(0)", "        \"\"\"", "        return Point.centroid(self.face_pts(index))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the centroids of individual mesh faces." ],
          "parameters" : {
            "index" : "Index of a face.\n"
          },
          "rtype" : "Point\n\n",
          "types" : {
            "index" : "int\n"
          }
        },
        "end" : 98,
        "name" : "face_centroid",
        "start" : 86
      }, {
        "code" : [ "        \"\"\" Returns the normal vector of a face.", "        ", "            :param index: Index of a face.", "            :type index: int", "            :returns: Normal vector.", "            :rtype: Vec", "            ", "            ::", "            ", "                quadmesh.face_normal(0)", "        \"\"\"", "        verts = self.face_pts(index)", "        if len(verts) == 3 : return Vec(verts[0],verts[1]).cross(Vec(verts[0],verts[2])).normalized()", "        else :" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the normal vector of a face." ],
          "parameters" : {
            "index" : "Index of a face.\n"
          },
          "rtype" : "Vec\n\n",
          "types" : {
            "index" : "int\n"
          }
        },
        "end" : 113,
        "name" : "face_normal",
        "start" : 100
      }, {
        "code" : [ "        return \"msh[{0}v,{1}f]\".format(len(self._verts),len(self._faces))", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 120,
        "name" : "__repr__",
        "start" : 119
      }, {
        "code" : [ "    def explode(msh):", "        \"\"\" Explodes a mesh into individual faces.", "        ", "            :param msh: Mesh to explode.", "            :type msh: Mesh", "            :returns: List of meshes.", "            :type: [Mesh]", "            ", "            ::", "            ", "                Mesh.explode(quadmesh)", "        \"\"\"", "        exploded_meshes = []", "        for face in msh.faces:", "            pts = [msh.pts[v] for v in face]", "            nface = [0,1,2] if len(face)==3 else [0,1,2,3]", "            exploded_meshes.append(Mesh(pts,[nface]))", "        return exploded_meshes", "    " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Explodes a mesh into individual faces." ],
          "parameters" : {
            "msh" : "Mesh to explode.\n"
          },
          "types" : "[Mesh]\n\n"
        },
        "end" : 140,
        "name" : "explode",
        "start" : 122
      }, {
        "code" : [ "        \"\"\" Returns a Graph representation of the mesh points by index.", "", "            :returns: A Graph of point indexes.", "            :rtype: Graph", "            ", "            ::", "            ", "                quadmesh.to_pt_graph()", "        \"\"\"", "        graph = Graph()", "        for index in range(len(self.pts)):", "            for face in self.faces:", "                for px in face:", "                    if index in face and index!=px: graph.add_edge(index, px)", "        return graph", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a Graph representation of the mesh points by index.", ":returns: A Graph of point indexes." ],
          "rtype" : "Graph\n\n"
        },
        "end" : 159,
        "name" : "to_pt_graph",
        "start" : 144
      }, {
        "code" : [ "        \"\"\" Returns a Graph representation of the mesh faces by index.", "            ", "            :param val: number of coincident points for neighborness.", "            :type val: int", "            :returns: A Graph of face indexes.", "            :rtype: Graph", "            ", "            ::", "            ", "                quadmesh.to_face_graph(2)", "        \"\"\" ", "        from decodes.extensions.graph import Graph", "        graph = Graph()", "        graph.naked_nodes = []", "        for f1 in range(len(self.faces)):", "            for f2 in range(len(self.faces)):", "                if f1 != f2:", "                    count = 0", "                    for index in self.faces[f2]:", "                        if index in self.faces[f1]:", "                            count+=1", "                    if count >= val:", "                        graph.add_edge(f1,f2)", "            if len(graph.edges[f1]) < len(self.faces[f1]):", "                if f1 not in graph.naked_nodes:", "                    graph.naked_nodes.append(f1)", "                                          ", "        return graph", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a Graph representation of the mesh faces by index." ],
          "parameters" : {
            "val" : "number of coincident points for neighborness.\n"
          },
          "rtype" : "Graph\n\n",
          "types" : {
            "val" : "int\n"
          }
        },
        "end" : 190,
        "name" : "to_face_graph",
        "start" : 162
      } ],
      "documentation" : {
        "description" : [ "a very simple mesh class" ]
      },
      "end" : 190,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_mesh.py",
      "name" : "Mesh",
      "references" : {
        "classes" : {
          "Graph" : 2,
          "HasPts" : 1,
          "Mesh" : 3,
          "Point" : 1,
          "Vec" : 7
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "add_face" : 1,
          "explode" : 1,
          "face_centroid" : 1,
          "face_normal" : 1,
          "face_pts" : 1,
          "faces" : 1,
          "to_face_graph" : 1,
          "to_pt_graph" : 1
        }
      },
      "start" : 7
    },
    "beae2b23-a9dc-414a-b33f-4683dda82640" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def mesh_pgons(pts_top, pts_mid, pts_btm):", "    # construct a Mesh object", "    msh = Mesh()", "    # add the list of Points to the Mesh", "    msh.append(pts_top)", "    msh.append(pts_mid)", "    msh.append(pts_btm)", "    ", "    # get the number of vertices of the base PGon", "    cnt = len(pgon_top.pts)", "    # for every index of the vertices in cnt-1:", "    for n in range(cnt-1):", "        # add triangular faces to the Mesh", "        msh.add_face(n,n+1,n+cnt)", "        msh.add_face(n+1,cnt+n+1,cnt+n)", "        msh.add_face(cnt+n,2*cnt+n+1,cnt*2+n)", "        msh.add_face(cnt+n,cnt+n+1,2*cnt+n+1)", "    # add a Mesh face for the last face", "    msh.add_face(cnt-1,0,cnt*2-1)", "    msh.add_face(0,cnt,cnt*2-1)", "    msh.add_face(cnt*3-1,cnt*2-1,cnt*2)", "    msh.add_face(cnt*2,cnt*2-1,cnt)", "    return msh", "" ],
          "end" : 45,
          "start" : 20
        },
        "description" : " \nMethod to create a Mesh given 3 lists of Points.\n",
        "end" : 20,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "    ", "# get the centroid and vertices of the top PGon ", "cen = Point.centroid(pgon_top.pts)", "pts_top = pgon_top.pts", "", "# displace the top PGon, and get its vertices ", "pts_mid = [edge.eval(0.5) - Vec(0,0,cen.z*.5) for edge in pgon_top.edges]", "# create a rotation transformation matrix", "xf = Xform.rotation(center= Point.centroid(pts_mid), angle=rot_mid)", "pts_mid = [pt * xf for pt in pts_mid]", "# create a scaling transformation matrix", "xs = Xform.scale(f_mid, Point.centroid(pts_mid))", "pts_mid = [pt * xs for pt in pts_mid]", "", "# displace the top PGon and get its vertices ", "pts_btm = [pt - Vec(0,0,cen.z) for pt in pts_top]", "# create a scaling transformation matrix", "xf2 = Xform.scale(1.25, Point.centroid(pts_btm))", "pts_btm = [pt * xf2 for pt in pts_btm]", "", "# create a Mesh with the 3 lists of Points", "column = mesh_pgons(pts_top, pts_mid, pts_btm)" ],
          "end" : 69,
          "start" : 48
        },
        "description" : "\nTranslate the base PGon, and given a rotation and scale values, transform the mid PGon. Create a Mesh with the transformed PGons. \n",
        "end" : 48,
        "start" : 46
      } ],
      "documentation" : {
        "description" : [ "4.04.L04a", "Given a base PGon, create a mesh by displacing it twice on the Z axis. Given a rotation and scaling values, transform the mesh. The transformations will be polar." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Columns/4.04.L04a.py",
      "name" : "4.04.L04a.py",
      "references" : {
        "classes" : {
          "Mesh" : 1,
          "Point" : 4,
          "Vec" : 2,
          "Xform" : 3
        }
      },
      "required" : [ "pgon_top (PGon) Base PGon to build the Mesh.", "rot_mid(int) Rotation in radians.", "f_mid (float) Scaling factor." ],
      "result" : [ "pts_top ([Point]) Vertices of the geometries.", "pts_mid ([Point]) Vertices of the geometries.", "pts_btm ([Point]) Vertices of the geometries.", "column (Mesh) Resulting Mesh" ]
    },
    "c049ebbd-e4c1-47af-9ac4-ad4631e8c10c" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Plane(Geometry):", "        o = Vec(point)", "        self.x = o.x", "        self.y = o.y", "        self.z = o.z", "        self._vec = normal.normalized()", "", "", "        " ],
          "end" : 26,
          "start" : 17
        },
        "description" : "\nA Simple Plane Class\n",
        "end" : 17,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "def from_pts(pt_a,pt_b,pt_c):", "        pt = Point.centroid([pt_a,pt_b,pt_c])", "        try:", "            nml = Vec(pt_a,pt_b).cross(Vec(pt_a,pt_c))", "        except:", "            raise GeometricError(\"Cannot create a Plane from collinear Points.\")", "        return Plane(pt,nml)       ", "", "" ],
          "end" : 38,
          "start" : 29
        },
        "description" : "\nConstruction by Three Points\n",
        "end" : 29,
        "start" : 27
      }, {
        "code" : {
          "content" : [ "def near(self, p):", "    t = Vec(self.spt,p).dot(self.vec)/self.vec.dot(self.vec)", "    point = self.eval(t)", "    return (point, t,point.distance(p))", "    ", "def near_pt(self, p):", "    return self.near(p)[0]", "    ", "    ", " ", "" ],
          "end" : 51,
          "start" : 41
        },
        "description" : "\nNear Projection Methods\n",
        "end" : 41,
        "start" : 39
      } ],
      "documentation" : {
        "description" : [ "3.05.E00a", "This file is not downloadable, and is only to be used to generate marked-up code" ],
        "images" : {
          "3&05&P02&png" : "required"
        }
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Plane/NOGHX/3.05.E00a.py",
      "name" : "3.05.E00a.py",
      "references" : {
        "classes" : {
          "Geometry" : 1,
          "Plane" : 2,
          "Point" : 1,
          "Vec" : 4
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "c0f6a294-85e1-4f9a-b39d-67a9611621c9" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_pline.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Polyline constructor.", "        ", "            :param vertices: Vertices to build the pline.", "            :type vertices: list", "            :param basis: Basis of polyline.", "            :type basis: basis", "            :returns: Polyline.", "            :rtype: PLine", "            ", "            ::", "            ", "                pts=[Point(i,i,i) for i in range(10)]", "                my_pline=PLine(pts)", "        ", "        \"\"\"", "        #todo: check if passed an empty array of points", "        if vertices is None or len(vertices)<2: raise GeometricError(\"Plines must be constructed with at least two points\")", "        super(PLine,self).__init__(vertices,basis) #HasPts constructor handles initialization of verts and basis", "        #self.basis = CS() if (basis is None) else basis # set the basis after appending the points" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Polyline constructor." ],
          "parameters" : {
            "basis" : "Basis of polyline.\n",
            "vertices" : "Vertices to build the pline.\n"
          },
          "rtype" : "PLine\n\n",
          "types" : {
            "basis" : "basis\n",
            "vertices" : "list\n"
          }
        },
        "end" : 32,
        "name" : "__init__",
        "start" : 14
      }, {
        "code" : [ "    def edges(self):", "        \"\"\" Returns the edges of a PLine.", "       ", "            :result: List of edges of a PLine", "            :rtype: [Segment]", "            ", "            ", "            ::", "            ", "                my_pline.edges", "        \"\"\"", "        try:", "            return copy.copy(self._edges)", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the edges of a PLine." ],
          "rtype" : "[Segment]\n\n\n",
          "rvalue" : "List of edges of a PLine\n"
        },
        "end" : 48,
        "name" : "edges",
        "start" : 35
      }, {
        "code" : [ "    def length(self):", "        \"\"\" Returns the length of this PLine.", "        ", "            :result: Length of this PLine", "            :rtype: float", "            ", "            TODO: better to not store this, but calculate as needed?", "            ", "            ::", "            ", "                my_pline.length", "        \"\"\"", "        try:", "            return self._length", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the length of this PLine." ],
          "rtype" : "float\n\nTODO",
          "rvalue" : "Length of this PLine\n"
        },
        "end" : 67,
        "name" : "length",
        "start" : 53
      }, {
        "code" : [ "        \"\"\" Returns a copy of this PLine with the vertices reversed", "        ", "            :result: Polyline.", "            :rtype: PLine", "        \"\"\"", "        return PLine(reversed(self._verts),self.basis)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a copy of this PLine with the vertices reversed" ],
          "rtype" : "PLine",
          "rvalue" : "Polyline.\n"
        },
        "end" : 78,
        "name" : "reversed",
        "start" : 72
      }, {
        "code" : [ "        \"\"\" Joins this polyline with a given polyline.", "            ", "            :param other: Polyline to join with this polyline.", "            :type other: PLine", "            :param tol: Tolerance of difference.", "            :type tol: bool.", "            :result: New joined Polyline.", "            :rtype: PLine", "            ", "            ::", "            ", "                pts_2=[Point(i+1, i, i-1) for in range(5)]", "                my_pline2=PLine(pts_2)", "                ", "                my_pline.join(my_pline2)", "            ", "        \"\"\"", "        if self._basis != other.basis: raise BasisError(\"The basis for this PLine and the PLine you're joining it to do not match.\")", "        self._unset_attr() # call this when any of storable properties (subclass_attr or class_attr) changes", "        if self[-1].is_equal(other[0],tol) :", "            pts = []" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Joins this polyline with a given polyline." ],
          "parameters" : {
            "other" : "Polyline to join with this polyline.\n",
            "tol" : "Tolerance of difference.\n"
          },
          "rtype" : "PLine\n\n",
          "rvalue" : "New joined Polyline.\n",
          "types" : {
            "other" : "PLine\n",
            "tol" : "bool.\n"
          }
        },
        "end" : 101,
        "name" : "join",
        "start" : 81
      }, {
        "code" : [ "        \"\"\" Returns a segment of this polyline.", "       ", "            :param index: Index of the polyline's segment", "            :type index: Int", "            :result: Line segment", "            :rtype: Segment", "            ", "            ::", "                ", "                my_pline.seg(2)", "        \"\"\"", "        idx = idx%(len(self)-1)", "        return Segment(self.pts[idx],self.pts[idx+1])", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a segment of this polyline." ],
          "parameters" : {
            "index" : "Index of the polyline's segment\n"
          },
          "rtype" : "Segment\n\n",
          "rvalue" : "Line segment\n",
          "types" : {
            "index" : "Int\n"
          }
        },
        "end" : 157,
        "name" : "seg",
        "start" : 144
      }, {
        "code" : [ "        \"\"\"| Evaluates this PLine at the specified parameter t.", "           | A t-value of 0 will result in a point coincident with PLine.pts[0].", "           | A t-value of 1 will result in a point coincident with PLine.pts[-1].", "           ", "           :param t: A decimal number between [0:1]", "           :type t: float", "           :result: A point on the polyline.", "           :rtype: Point", "           ", "           ::", "                ", "                my_pline.eval(0.5)", "           ", "        \"\"\"", "        if t > 1 or t < 0 : raise IndexError(\"PLines must be evaluated with 0.0 <= t <= 1.0\")", "        if t == 0.0 : return self.pts[0]", "        if t == 1.0 : return self.pts[-1]", "", "        for seg,ival in zip(self.edges, Interval()//(len(self)-1)):", "            if t in ival: return seg.eval(ival.deval(t))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this PLine at the specified parameter t.", "| A t-value of 0 will result in a point coincident with PLine.pts[0].", "| A t-value of 1 will result in a point coincident with PLine.pts[-1]." ],
          "parameters" : {
            "t" : "A decimal number between [0"
          },
          "rtype" : "Point\n\n",
          "rvalue" : "A point on the polyline.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 179,
        "name" : "eval",
        "start" : 159
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given PLine, the index of the closest segment, and the distance from the Point to the near Point.", "       ", "            :param p: Point to look for a near Point on the PLine.", "            :type p: Point", "            :result: Tuple of near point on PLine, index of near segment and distance from point to near point.", "            :rtype: (Point, integer, float)", "            ", "            ::", "            ", "                my_pline.near(Point(1,2,3))", "        \"\"\"", "        #KS: this does not function as advertised, after narrowing down to the nearest segment we need to project the given point", "        return False", "        npts = [seg.near(p) for seg in self.edges]", "        ni = Point.near_index(p,[npt[0] for npt in npts])", "        return (npts[ni][0],ni,npts[ni][2])", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given PLine, the index of the closest segment, and the distance from the Point to the near Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the PLine.\n"
          },
          "rtype" : "(Point, integer, float)\n\n",
          "rvalue" : "Tuple of near point on PLine, index of near segment and distance from point to near point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 197,
        "name" : "near",
        "start" : 181
      }, {
        "code" : [ "        \"\"\" Returns the closest point to a given PLine.", "       ", "            :param p: Point to look for a near Point on the PLine.", "            :type p: Point", "            :result: Near point on Pline.", "            :rtype: Point", "        \"\"\"", "        return self.near(p)[0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point to a given PLine." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the PLine.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Near point on Pline.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 207,
        "name" : "near_pt",
        "start" : 199
      }, {
        "code" : [ "        return \"pline[{0}v]\".format(len(self._verts))" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 210,
        "name" : "__repr__",
        "start" : 209
      } ],
      "documentation" : {
        "description" : [ "a simple polyline class" ]
      },
      "end" : 210,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_pline.py",
      "name" : "PLine",
      "references" : {
        "classes" : {
          "HasPts" : 1,
          "Interval" : 1,
          "PLine" : 8,
          "Point" : 1,
          "Segment" : 1
        },
        "functions" : {
          "__init__" : 1,
          "__repr__" : 1,
          "edges" : 1,
          "eval" : 1,
          "join" : 1,
          "length" : 1,
          "near" : 1,
          "near_pt" : 1,
          "reversed" : 1,
          "seg" : 1
        }
      },
      "start" : 7
    },
    "c2560781-2f12-4af8-9656-b03a9261e157" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_surface.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" Constructs a Curve object. If tolerance is None, Curve.tol = tol_max().", "        ", "            :param function: A function returning points.", "            :type function: function", "            :param dom_u: Domain for u-value of curve points.", "            :type dom_u: Interval", "            :param dom_v: Domain for v-value of curve points.", "            :type dom_v: Interval", "            :param tol_u: The tolerance of u-direction of this Surface expressed in domain space.", "            :type tol_u: float", "            :param tol_v: The tolerance of v-direction of this Surface expressed in domain space.", "            :type tol_v: float", "            :result: Surface object.", "            :rtype: Surface", "            ", "            ::", "            ", "                def func(u,v):", "                    return Point(u,v)", "                Int=Interval(1,20)", "                my_surf=Surface(func,Int,Int)", "        \"\"\"", "        if function is not None : self._func = function", "        self._dom = dom_u, dom_v", "        self._tol = self.tol_max", "        if tol_u is not None : self.tol_u = tol_u", "        if tol_v is not None : self.tol_v = tol_v", "", "        for u,v in [(self.u0,self.v0),(self.u0,self.v1),(self.u1,self.v1),(self.u1,self.v0)]:", "            try:", "                pt = self.func(u,v)", "                pt.x", "                pt.y", "                pt.z", "            except:" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "Constructs a Curve object. If tolerance is None, Curve.tol = tol_max()." ],
          "parameters" : {
            "dom_u" : "Domain for u-value of curve points.\n",
            "dom_v" : "Domain for v-value of curve points.\n",
            "function" : "A function returning points.\n",
            "tol_u" : "The tolerance of u-direction of this Surface expressed in domain space.\n",
            "tol_v" : "The tolerance of v-direction of this Surface expressed in domain space.\n"
          },
          "rtype" : "Surface\n\n",
          "rvalue" : "Surface object.\n",
          "types" : {
            "dom_u" : "Interval\n",
            "dom_v" : "Interval\n",
            "function" : "function\n",
            "tol_u" : "float\n",
            "tol_v" : "float\n"
          }
        },
        "end" : 51,
        "name" : "__init__",
        "start" : 17
      }, {
        "code" : [ "    def surrogate(self):", "        \"\"\"Returns a mesh copy of this surface.", "        ", "            :result: Mesh copy of this surface.", "            :rtype: Mesh", "            ", "            ::", "                ", "                my_surf.surrogate", "            ", "        \"\"\"", "        ", "        try:", "            return self._surrogate", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns a mesh copy of this surface." ],
          "rtype" : "Mesh\n\n",
          "rvalue" : "Mesh copy of this surface.\n"
        },
        "end" : 71,
        "name" : "surrogate",
        "start" : 57
      }, {
        "code" : [ "        \"\"\"Deletes attributes of this surrogate Surface.", "        ", "            :result: None", "            :rtype: None", "            ", "        \"\"\"", "    ", "        try: delattr(self, \"_surrogate\")", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Deletes attributes of this surrogate Surface." ],
          "rtype" : "None",
          "rvalue" : "None\n"
        },
        "end" : 84,
        "name" : "_rebuild_surrogate",
        "start" : 76
      }, {
        "code" : [ "    def domain_u(self): ", "        \"\"\"Returns the Interval domain for the U-direction of this Surface.", "            ", "            :result: Domain of this Surface in the U-direction.", "            :rtype: Interval", "        \"\"\"", "        return self._dom[0]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Interval domain for the U-direction of this Surface." ],
          "rtype" : "Interval",
          "rvalue" : "Domain of this Surface in the U-direction.\n"
        },
        "end" : 96,
        "name" : "domain_u",
        "start" : 89
      }, {
        "code" : [ "    def u0(self):", "        \"\"\"Returns the minimum value for the U domain of this Surface.", "            ", "            :result: Minimum value for U domain.", "            :rtype: float", "            ", "        \"\"\"", "        return self._dom[0].a", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the minimum value for the U domain of this Surface." ],
          "rtype" : "float",
          "rvalue" : "Minimum value for U domain.\n"
        },
        "end" : 106,
        "name" : "u0",
        "start" : 98
      }, {
        "code" : [ "    def u1(self):", "        \"\"\"Returns the maximum value for the U domain of this Surface.", "        ", "            :result: Maximum value for U domain.", "            :rtype: float", "            ", "        \"\"\"", "        return self._dom[0].b", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the maximum value for the U domain of this Surface." ],
          "rtype" : "float",
          "rvalue" : "Maximum value for U domain.\n"
        },
        "end" : 116,
        "name" : "u1",
        "start" : 108
      }, {
        "code" : [ "    def v0(self):", "        \"\"\"Returns the minimum value for the V domain of this Surface.", "        ", "            :result: Minimum value for V domain.", "            :rtype: float", "            ", "        \"\"\"", "        return self._dom[1].a", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the minimum value for the V domain of this Surface." ],
          "rtype" : "float",
          "rvalue" : "Minimum value for V domain.\n"
        },
        "end" : 126,
        "name" : "v0",
        "start" : 118
      }, {
        "code" : [ "    def v1(self):", "        \"\"\"Returns the maximum value for the V domain of this Surface.", "        ", "            :result: Maximum value for V domain.", "            :rtype: float", "        ", "        \"\"\"", "        return self._dom[1].b", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the maximum value for the V domain of this Surface." ],
          "rtype" : "float",
          "rvalue" : "Maximum value for V domain.\n"
        },
        "end" : 136,
        "name" : "v1",
        "start" : 128
      }, {
        "code" : [ "    def domain_v(self): ", "        \"\"\"Returns the Interval domain for the V-direction of this Surface.", "           ", "            :result: Domain of this Surface in the V-direction.", "            :rtype: Interval", "            ", "        \"\"\"", "        return self._dom[1]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Interval domain for the V-direction of this Surface." ],
          "rtype" : "Interval",
          "rvalue" : "Domain of this Surface in the V-direction.\n"
        },
        "end" : 146,
        "name" : "domain_v",
        "start" : 138
      }, {
        "code" : [ "    def tol_max(self):", "        \"\"\"Determines the maximum tolerance as Surface.domain_u.delta / 10 , Surface.domain_v.delta / 10.", "        ", "            :result: [Maximum U-tolerance, Maximum V-tolerance]", "            :rtype: [float, float]", "        \"\"\"", "        return [self._dom[0].delta / 10.0, self._dom[1].delta / 10.0]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Determines the maximum tolerance as Surface.domain_u.delta / 10 , Surface.domain_v.delta / 10." ],
          "rtype" : "[float, float]",
          "rvalue" : "[Maximum U-tolerance, Maximum V-tolerance]\n"
        },
        "end" : 155,
        "name" : "tol_max",
        "start" : 148
      }, {
        "code" : [ "    def tol_u(self):", "        \"\"\"Returns tolerance in the U-direction of this Surface.", "        ", "            :result: Tolerance in U-direction.", "            :rtype: float", "            ", "        \"\"\"", "        return self._tol[0]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns tolerance in the U-direction of this Surface." ],
          "rtype" : "float",
          "rvalue" : "Tolerance in U-direction.\n"
        },
        "end" : 165,
        "name" : "tol_u",
        "start" : 157
      }, {
        "code" : [ "    def tol_u(self, tolerance):", "        \"\"\"Sets the tolerance of this Surface in the U-direction.", "            ", "            :param tolerance: Tolerance of this Surface.", "            :type tolerance: float", "            :result: None", "            :rtype: None", "            ", "        \"\"\"", "        self._tol[0] = tolerance", "        if self._tol[0] > self.tol_max[0] :  ", "            warnings.warn(\"Surface u tolerance too high relative to u domain - Resetting to max tol.  tol_u (%s) > Surface.max_tol(%s)\"%(tolerance,self.tol_max))", "            self._tol[0] = self.tol_max[0]", "        self._rebuild_surrogate()", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the tolerance of this Surface in the U-direction." ],
          "parameters" : {
            "tolerance" : "Tolerance of this Surface.\n"
          },
          "rtype" : "None",
          "rvalue" : "None\n",
          "types" : {
            "tolerance" : "float\n"
          }
        },
        "end" : 181,
        "name" : "tol_u",
        "start" : 167
      }, {
        "code" : [ "    def tol_u_nudge(self):", "        return self.tol_u/100.0", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 185,
        "name" : "tol_u_nudge",
        "start" : 183
      }, {
        "code" : [ "    def tol_v(self):", "        \"\"\"Returns the tolerance of this Surface in the V-direction.", "        ", "            :result: Tolerance in V-direction.", "            :rtype: float", "            ", "        \"\"\"", "        return self._tol[1]", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the tolerance of this Surface in the V-direction." ],
          "rtype" : "float",
          "rvalue" : "Tolerance in V-direction.\n"
        },
        "end" : 195,
        "name" : "tol_v",
        "start" : 187
      }, {
        "code" : [ "    def tol_v(self, tolerance):", "        \"\"\"Sets the tolerance of this surface in the V-direction.", "        ", "            :param tolerance: Tolerance of this Surface.", "            :type tolerance: float", "            :result: None", "            :rtype: None", "        \"\"\"", "        self._tol[1] = tolerance", "        if self._tol[1] > self.tol_max[1] :  ", "            warnings.warn(\"Surface v tolerance too high relative to v domain - Resetting to max tol.  tol_v (%s) > Surface.max_tol(%s)\"%(tolerance,self.tol_max))", "            self._tol[1] = self.tol_max[1]", "        self._rebuild_surrogate()", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the tolerance of this surface in the V-direction." ],
          "parameters" : {
            "tolerance" : "Tolerance of this Surface.\n"
          },
          "rtype" : "None",
          "rvalue" : "None\n",
          "types" : {
            "tolerance" : "float\n"
          }
        },
        "end" : 210,
        "name" : "tol_v",
        "start" : 197
      }, {
        "code" : [ "    def tol_v_nudge(self):", "        return self.tol_v/100.0", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 214,
        "name" : "tol_v_nudge",
        "start" : 212
      }, {
        "code" : [ "        \"\"\"| Evaluates this Surface and returns a Point.", "           | u and v are float values that fall within the defined domain of this Surface.", "", "           :param u: U-value to evaluate the Surface at.", "           :type u: float", "           :param v: V-value to evaluate the Surface at.", "           :type v: float", "           :result: a Point on this Surface.", "           :rtype: Point", "            ", "           ::", "            ", "               my_surf.deval(5,5)", "        \"\"\"", "        '''", "        # some rounding errors require something like this:", "        if u < self.u0 and u > self.u0-self.tol_u : u = u0", "        if u > self.u1 and u < self.u1+self.tol_u : u = u1", "        if v < self.v0 and v > self.v0-self.tol_v : v = v0", "        if v > self.v1 and v < self.v1+self.tol_v : v = v1", "        '''", "        if u not in self.domain_u : raise DomainError(\"Surface evaluated outside the bounds of its u-domain: deval(%s) %s\"%(u,self.domain_u))", "        if v not in self.domain_v : raise DomainError(\"Surface evaluated outside the bounds of its v-domain: deval(%s) %s\"%(v,self.domain_v))", "        ", "        return Point(self.func(u,v))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Surface and returns a Point.", "| u and v are float values that fall within the defined domain of this Surface." ],
          "parameters" : {
            "u" : "U-value to evaluate the Surface at.\n",
            "v" : "V-value to evaluate the Surface at.\n"
          },
          "rtype" : "Point\n \n",
          "rvalue" : "a Point on this Surface.\n",
          "types" : {
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 242,
        "name" : "deval",
        "start" : 217
      }, {
        "code" : [ "        \"\"\"| Evaluates this Surface and returns a Plane.", "           | u and v are float values that fall within the defined domain of this Surface.", "           | Tangent vector determined by a nearest neighbor at distance Surface.tol/100", "", "           :param u: U-value to evaluate the Surface at.", "           :type u: float", "           :param v: V-value to evaluate the Surface at.", "           :type v: float", "           :result: a Plane on this Surface.", "           :rtype: Plane", "           ", "           ::", "                ", "               my_surf.deval_pln(5,5)", "        \"\"\"", "        '''", "        # some rounding errors require something like this:", "        if u < self.u0 and u > self.u0-self.tol_u : u = u0", "        if u > self.u1 and u < self.u1+self.tol_u : u = u1", "        if v < self.v0 and v > self.v0-self.tol_v : v = v0", "        if v > self.v1 and v < self.v1+self.tol_v : v = v1", "        '''", "        if u not in self.domain_u : raise DomainError(\"Surface evaluated outside the bounds of its u-domain: deval(%s) %s\"%(u,self.domain_u))", "        if v not in self.domain_v : raise DomainError(\"Surface evaluated outside the bounds of its v-domain: deval(%s) %s\"%(v,self.domain_v))", "", "        pt,vec_u,vec_v = self._nudged(u,v)", "        vec = vec_u.cross(vec_v)", "", "        return Plane(pt, vec)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Surface and returns a Plane.", "| u and v are float values that fall within the defined domain of this Surface.", "| Tangent vector determined by a nearest neighbor at distance Surface.tol/100" ],
          "parameters" : {
            "u" : "U-value to evaluate the Surface at.\n",
            "v" : "V-value to evaluate the Surface at.\n"
          },
          "rtype" : "Plane\n\n",
          "rvalue" : "a Plane on this Surface.\n",
          "types" : {
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 274,
        "name" : "deval_pln",
        "start" : 245
      }, {
        "code" : [ "        \"\"\"Calculates the curvature of this Surface at a given location.", "        ", "            :param u: U-value to evaluate the Surface at.", "            :type u: float", "            :param v: V-value to evaluate the Surface at.", "            :type v: float", "            :param calc_extras: Boolean value.", "            :type calc_extras: bool", "            :result: (Curvature at point in U-direction, osculating Circle), (Curvature at point in V-direction, osculating Circle)", "            :rtype: (float, Circle), (float, Circle)", "            ", "            ::", "            ", "                my_surf.deval_curviso(3,5)", "            ", "        \"\"\"", "        # calculates the curvature of the isoparms of this surfaces", "        # returns curvature values and osc circles", "        pt, u_pos, u_neg, v_pos, v_neg = self._nudged(u,v,True)", "", "        # if given a surface edge, nudge vectors a bit so we don't get zero curvature, but leave origin the same", "        if (u-self.tol_u_nudge <= self.domain_u.a):", "            nudged = self._nudged(self.tol_u_nudge,v,True)", "            u_pos = nudged[1]", "            u_neg = nudged[2]", "        if (u+self.tol_u_nudge >= self.domain_u.b):", "            nudged = self._nudged(self.domain_u.b-self.tol_u_nudge,v,True)", "            u_pos = nudged[1]", "            u_neg = nudged[2]", "", "        if (v-self.tol_v_nudge <= self.domain_v.a):", "            nudged = self._nudged(u,self.tol_v_nudge,True)", "            v_pos = nudged[3]", "            v_neg = nudged[4]", "        if (v+self.tol_v_nudge >= self.domain_v.b):", "            nudged = self._nudged(u,self.domain_v.b-self.tol_v_nudge,True)", "            v_pos = nudged[3]", "            v_neg = nudged[4]", "", "        crv_u = Curve._curvature_from_vecs(pt,u_pos,u_neg,calc_extras)", "        crv_v = Curve._curvature_from_vecs(pt,v_pos,v_neg,calc_extras)", "        ", "        if calc_extras : return crv_u[0]*crv_v[0], (crv_u[0],crv_v[0]),(crv_u[1],crv_v[1])", "        return crv_u,crv_v", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Calculates the curvature of this Surface at a given location." ],
          "parameters" : {
            "calc_extras" : "Boolean value.\n",
            "u" : "U-value to evaluate the Surface at.\n",
            "v" : "V-value to evaluate the Surface at.\n"
          },
          "rtype" : "(float, Circle), (float, Circle)\n\n",
          "rvalue" : "(Curvature at point in U-direction, osculating Circle), (Curvature at point in V-direction, osculating Circle)\n",
          "types" : {
            "calc_extras" : "bool\n",
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 322,
        "name" : "deval_curviso",
        "start" : 278
      }, {
        "code" : [ "        \"\"\" IN:  ", "        ", "            - a point u,v (given on this surface domain) referring to a point on the surface.", "", "            OUT:", "        ", "            The following geometric entities describing the shape of the surface at a given point:", "        ", "            - principal directions (expressed as a coordinate system)", "        ", "            - curvatures: principal curvatures (min/max), Gaussian curvature (K), Mean Curvature (H)", "", "            Note: All quantities at a given point are computed using nearest neighbors on a mesh.  ", "        ", "            For the case of a parametrized surface, we take a mesh of nearest neighbors with vertices given by the isocurves at a resolution tol_nudge. These calculations are good for any mesh on a surface;  all that would need to change for another type of mesh is: ", "        ", "                (1) the construction of the mesh of nearest neighbors around the surface point in question ", "        ", "                (2) the calculation of the areas of the faces and the weighted face areas", "        ", "            ref: ", "        ", "            Taubin, Gabriel, Estimating the Tensor of Curvature of a Surface from a Polyhedral", "        ", "            Approximation, http://pdf.aminer.org/000/234/737/curvature_approximation_for_triangulated_surfaces.pdf", "", "            Note: We can define projection onto a surface by computing the normal on the surrogate.", "        ", "            :param u: U-value to evaluate Surface at.", "            :type u: float", "            :param v: V-value to evaluate Surface at.", "            :type v: float", "            :param calc_extras: Boolean value.", "            :type calc_extras: bool", "            :result: The principal directions (CS), minimum curvature, maximum curvature, Gaussian curvature, Mean curvature", "            :rtype: CS, float, float, float, float", "            ", "            ::", "            ", "                my_surf.deval_curv(5,4)", "            ", "        \"\"\"", "        # * eliminate when we have a matrix class or can import numpy", "        def matrix_mult(matrix1,matrix2):", "            if len(matrix1[0]) != len(matrix2):", "                print \"Matrices can't be multiplied!\"", "            else:", "                m = len(matrix1)", "                n = len(matrix1[0])", "                p = len(matrix2[0])", "                new_matrix = [[0 for row in range(p)] for col in range(m)]", "                for i in range(m):", "                    for j in range(p):", "                        for k in range(n):", "                            new_matrix[i][j] += matrix1[i][k]*matrix2[k][j]", "                return new_matrix", "", "        ret = []", "        pt_uv = self.func(u,v)", "        ret.append(pt_uv)", "", "        #construct mesh of nearest neighbors, with 0 indexing p_uv and neighbors indexed counter clockwise. ", "        ngbr = Mesh()", "        pt, u_pos, u_neg, v_pos, v_neg = self._nudged(u,v,True)", "        ngbr.append(pt_uv)", "        ngbr.append(pt_uv +  u_pos )", "        ngbr.append(pt_uv +  u_pos  +  v_pos)", "        ngbr.append(pt_uv +  v_pos )", "        ngbr.append(pt_uv +  u_neg  +  v_pos)", "        ngbr.append(pt_uv +  u_neg )", "        ngbr.append(pt_uv +  u_neg  +  v_neg)", "        ngbr.append(pt_uv +  v_neg )", "        ngbr.append(pt_uv +  u_pos  +  v_neg)", "    ", "        #Triangular mesh", "        ngbr.add_face(0,1,2)", "        ngbr.add_face(0,2,3)", "        ngbr.add_face(0,3,5)", "        ngbr.add_face(0,5,6)", "        ngbr.add_face(0,6,7)", "        ngbr.add_face(0,7,1)", "", "        #weights stores the sum of the face areas for faces touching at given vertex and p_uv", "        #used for creating the matrix needed for the calculation of the principals", "        weights = [0]*len(ngbr) ", "", "        #Compute the normal vector and tangent plane at the point pt_uv", "        N_vec = Vec(0,0,0)", "        for k in range(len(ngbr.faces)):", "            verts = ngbr.face_pts(k)", "            face_area = 0.5*Vec(verts[0],verts[1]).cross(Vec(verts[0],verts[2])).length #Triangular face area", "            N_vec = N_vec + ngbr.face_normal(k)*face_area", "            for i in ngbr.faces[k]:", "                weights[i] += face_area", "        N_vec = N_vec.normalized()", "        tangent_plane = Plane(pt_uv, N_vec)", "", "        #Compute the principal curvatures and directions at the point pt_uv (*)", "", "        #Form the matrix needed for the calculation of the principal curvatures/directions", "        M_mat = [[0 for row in range(3)] for col in range(3)]", "        weights_sum = sum(weights)", "        for k in range(1,len(ngbr)):", "            vec_k = Vec(ngbr[k] - pt_uv) ", "            #T_k is normalized projecton of vec_k onto the tangent plane", "            T_k = (vec_k - N_vec*(vec_k.dot(N_vec))).normalized().to_tuple()", "            #kappa_k is the approximate directional curvature at ngbr[k]", "            kappa_k = 2*N_vec.dot(vec_k)/vec_k.length2", "            w_k =  weights[k]/weights_sum", "            factor = kappa_k*w_k  ", "            for row in range(3):", "               for col in range(3):", "                   M_mat[row][col] += factor * T_k[row] * T_k[col]", " ", "        \"\"\"", "        #Check that N_vec is an eigenvector of M_mat (with eigenvalue 0)", "        N = [[N_vec.x], [N_vec.y], [N_vec.z]]", "        print matrix_mult(M_mat, N)", "        \"\"\"", "", "        #Form matrix for Householder transformation(reflection matrix Q = I - 2*W*transpose(W))", "        E_vec = Vec(1,0,0)", "        if (E_vec - N_vec).length2 > (E_vec + N_vec).length2:", "            W_vec = (Vec(1,0,0) - N_vec).normalized().to_tuple()", "        else:", "            W_vec = (Vec(1,0,0) + N_vec).normalized().to_tuple()", "    ", "        I_mat = [[1,0,0], [0,1,0], [0,0,1]] ", "        Q_mat = [[0 for row in range(3)] for col in range(3)]", "", "        for row in range(3):", "            for col in range(3):", "                Q_mat[row][col] = I_mat[row][col] - 2 * W_vec[row] * W_vec[col]", "", "        \"\"\"", "        #Check that +- N_vec is the first column of Q", "        print N_vec, Q_mat", "        \"\"\"", "", "        T1_tilde = Vec(Q_mat[0][1], Q_mat[1][1], Q_mat[2][1])", "        T2_tilde = Vec(Q_mat[0][2], Q_mat[1][2], Q_mat[2][2])", "        \"\"\"", "        #Check that these vectors are orthonormal", "        print T1_tilde.length, T2_tilde.length, T1_tilde.dot(T2_tilde)", "        \"\"\"", "", "        #Apply Householder transformation by forming matrix : transpose(Q)*M*Q = Q*M*Q", "        #Note: Q_mat_transpose = transpose(Q_mat)", "        M_s =  matrix_mult(matrix_mult(Q_mat, M_mat), Q_mat)", "        m11 = M_s[1][1]", "        m12 = M_s[1][2]", "        m21 = M_s[2][1]", "        m22 = M_s[2][2]", "        M_s_restricted = [[m11, m12],[m21 , m22]]", "", "        \"\"\"", "        #Check that M_s_rectricted (restriction of M_s on tangent space) is symmetric", "        print \"Matrix to be diagonalized\", M_s_restricted", "        \"\"\"", "", "        #Calculate the Givens rotation angle", "        theta = 0.5*math.atan2(2*m12, m22-m11)", "        cos = math.cos(theta)", "        sin = math.sin(theta)", "", "        \"\"\"", "        #Check that transpose(Rot)*M_s_restricted*Rot is diagonal", "        Rot_mat = [[cos, sin],[-sin, cos]]", "        print matrix_mult(matrix_mult(transpose(Rot_mat), M_s_restricted), Rot_mat)", "        \"\"\"", "", "        #Calculate the eigenvectors and eigenvalues of M_mat", "        T1_vec = T1_tilde*cos - T2_tilde*sin", "        T2_vec = T1_tilde*sin + T2_tilde*cos", "        d1 = cos*cos*m11 - 2*cos*sin*m12 + sin*sin*m22 ", "        d2 = sin*sin*m11 + 2*cos*sin*m12 + cos*cos*m22", "", "        if d1 > d2:", "            d1,d2 = d2,d1", "            T1_vec, T2_vec = T2_vec, T1_vec", "", "        \"\"\"", "        #Check that T1, T2 are eigenvectors of M_mat", "        T1 = [[T1_vec.x], [T1_vec.y], [T1_vec.z]]", "        T2 = [[T2_vec.x], [T2_vec.y], [T2_vec.z]]", "        T1_test = matrix_mult(M_mat, T1)", "        #These should all equal d1", "        print T1_test[0][0]/T1[0][0], T1_test[1][0]/T1[1][0], T1_test[2][0]/T1[2][0]", "        T2_test = matrix_mult(M_mat, T2)", "        #These should all equal d2", "        print T2_test[0][0]/T2[0][0], T2_test[1][0]/T2[1][0], T2_test[2][0]/T2[2][0]", "        \"\"\" ", "", "        #T1 and T2 are the principal directions.  Form a coordinate system aligned with these directions.", "        cs_principal = CS(pt_uv, T1_vec, T2_vec)", "", "        #Compute all the curvature quantities: principal curvatures, Gaussian, Mean", "        k1 = 3*d1 - d2", "        k2 = 3*d2 - d1", "        K = k1*k2", "        H = (k1 + k2)*0.5", "        if k1 == k2 : ", "            if not calc_extras : return False", "            return False, k1, k2, K, H", "", "        if not calc_extras : return cs_principal", "        return cs_principal, k1, k2, K, H", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "IN:", "- a point u,v (given on this surface domain) referring to a point on the surface.", "OUT:", "The following geometric entities describing the shape of the surface at a given point:", "- principal directions (expressed as a coordinate system)", "- curvatures: principal curvatures (min/max), Gaussian curvature (K), Mean Curvature (H)", "Note: All quantities at a given point are computed using nearest neighbors on a mesh.", "For the case of a parametrized surface, we take a mesh of nearest neighbors with vertices given by the isocurves at a resolution tol_nudge. These calculations are good for any mesh on a surface;  all that would need to change for another type of mesh is:", "(1) the construction of the mesh of nearest neighbors around the surface point in question", "(2) the calculation of the areas of the faces and the weighted face areas", "ref:", "Taubin, Gabriel, Estimating the Tensor of Curvature of a Surface from a Polyhedral", "Approximation, http://pdf.aminer.org/000/234/737/curvature_approximation_for_triangulated_surfaces.pdf", "Note: We can define projection onto a surface by computing the normal on the surrogate." ],
          "parameters" : {
            "calc_extras" : "Boolean value.\n",
            "u" : "U-value to evaluate Surface at.\n",
            "v" : "V-value to evaluate Surface at.\n"
          },
          "rtype" : "CS, float, float, float, float\n\n",
          "rvalue" : "The principal directions (CS), minimum curvature, maximum curvature, Gaussian curvature, Mean curvature\n",
          "types" : {
            "calc_extras" : "bool\n",
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 531,
        "name" : "deval_curv",
        "start" : 324
      }, {
        "code" : [ "        \"\"\"| Evaluates this Surface and returns a Point.", "           | u and v are normalized float values (0->1) which will be remapped to the domain defined by this Surface.", "           | Equivalent to Surface.deval(Interval.remap(t,Interval(),Surface.domain))", "            ", "           :param u: U value to evaluate Surface at.", "           :type u: float", "           :param v: V value to evaluate Surface at.", "           :type v: float", "           :result: a Point on this Surface.", "           :rtype: Point", "        \"\"\"", "        if u<0 or u>1 : raise DomainError(\"u out of bounds.  eval() must be called numbers between 0->1: eval(%s)\"%u)", "        if v<0 or v>1 : raise DomainError(\"v out of bounds.  eval() must be called numbers between 0->1: eval(%s)\"%v)", "        return self.deval(Interval.remap(u,Interval(),self.domain_u),Interval.remap(v,Interval(),self.domain_v))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Surface and returns a Point.", "| u and v are normalized float values (0->1) which will be remapped to the domain defined by this Surface.", "| Equivalent to Surface.deval(Interval.remap(t,Interval(),Surface.domain))" ],
          "parameters" : {
            "u" : "U value to evaluate Surface at.\n",
            "v" : "V value to evaluate Surface at.\n"
          },
          "rtype" : "Point",
          "rvalue" : "a Point on this Surface.\n",
          "types" : {
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 547,
        "name" : "eval",
        "start" : 533
      }, {
        "code" : [ "        \"\"\"| Evaluates this Curve and returns a Plane.", "           | u and v are normalized float values (0->1) which will be remapped to the domain defined by this Surface.", "           | Equivalent to Surface.deval(Interval.remap(t,Interval(),Surface.domain)).", "            ", "           :param u: U value to evaluate the Surface at.", "           :type u: float", "           :param v: V value to evaluate the Surface at.", "           :type v: float", "           :result: a Plane on this Surface.", "           :rtype: Plane", "        \"\"\"", "        if u<0 or u>1 : raise DomainError(\"u out of bounds.  eval() must be called numbers between 0->1: eval(%s)\"%u)", "        if v<0 or v>1 : raise DomainError(\"v out of bounds.  eval() must be called numbers between 0->1: eval(%s)\"%v)", "        return self.deval_pln(Interval.remap(u,Interval(),self.domain_u),Interval.remap(v,Interval(),self.domain_v))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Evaluates this Curve and returns a Plane.", "| u and v are normalized float values (0->1) which will be remapped to the domain defined by this Surface.", "| Equivalent to Surface.deval(Interval.remap(t,Interval(),Surface.domain))." ],
          "parameters" : {
            "u" : "U value to evaluate the Surface at.\n",
            "v" : "V value to evaluate the Surface at.\n"
          },
          "rtype" : "Plane",
          "rvalue" : "a Plane on this Surface.\n",
          "types" : {
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 563,
        "name" : "eval_pln",
        "start" : 549
      }, {
        "code" : [ "        \"\"\"Calculates the curvature of this Surface at a given location.", "        ", "            :param u: U-value to evaluate the Surface at.", "            :type u: float", "            :param v: V-value to evaluate the Surface at.", "            :type v: float", "            :param calc_extras: Boolean value.", "            :type calc_extras: bool", "            :result: (Curvature at point in U-direction, osculating Circle), (Curvature at point in V-direction, osculating Circle)", "            :rtype: (float, Circle), (float, Circle)", "            ", "        \"\"\"", "        if u<0 or u>1 : raise DomainError(\"u out of bounds.  eval_curvature() must be called numbers between 0->1: eval(%s)\"%u)", "        if v<0 or v>1 : raise DomainError(\"v out of bounds.  eval_curvature() must be called numbers between 0->1: eval(%s)\"%v)", "        return self.deval_curviso(Interval.remap(u,Interval(),self.domain_u),Interval.remap(v,Interval(),self.domain_v),calc_extras)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Calculates the curvature of this Surface at a given location." ],
          "parameters" : {
            "calc_extras" : "Boolean value.\n",
            "u" : "U-value to evaluate the Surface at.\n",
            "v" : "V-value to evaluate the Surface at.\n"
          },
          "rtype" : "(float, Circle), (float, Circle)",
          "rvalue" : "(Curvature at point in U-direction, osculating Circle), (Curvature at point in V-direction, osculating Circle)\n",
          "types" : {
            "calc_extras" : "bool\n",
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 580,
        "name" : "eval_curviso",
        "start" : 565
      }, {
        "code" : [ "        \"\"\" Returns the curvature of a surface at a given location u,v. Equivalent to deval_curv.", "        ", "            :param u: U-value to evaluate Surface at.", "            :type u: float", "            :param v: V-value to evaluate Surface at.", "            :type v: float", "            :param calc_extras: Boolean value.", "            :type calc_extras: bool", "            :result: The principal directions (CS), minimum curvature, maximum curvature, Gaussian curvature, Mean curvature", "            :rtype: CS, float, float, float, float", "                        ", "        \"\"\"", "        if u<0 or u>1 : raise DomainError(\"u out of bounds.  eval_curvature() must be called numbers between 0->1: eval(%s)\"%u)", "        if v<0 or v>1 : raise DomainError(\"v out of bounds.  eval_curvature() must be called numbers between 0->1: eval(%s)\"%v)", "        return self.deval_curv(Interval.remap(u,Interval(),self.domain_u),Interval.remap(v,Interval(),self.domain_v),calc_extras)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the curvature of a surface at a given location u,v. Equivalent to deval_curv." ],
          "parameters" : {
            "calc_extras" : "Boolean value.\n",
            "u" : "U-value to evaluate Surface at.\n",
            "v" : "V-value to evaluate Surface at.\n"
          },
          "rtype" : "CS, float, float, float, float\n            ",
          "rvalue" : "The principal directions (CS), minimum curvature, maximum curvature, Gaussian curvature, Mean curvature\n",
          "types" : {
            "calc_extras" : "bool\n",
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 597,
        "name" : "eval_curv",
        "start" : 582
      }, {
        "code" : [ "        \"\"\"Returns the nearest neighbors along u and v axis of a point(u,v). Used for discrete approximations calculations.", "        ", "            :param u: U value to evaluate the Surface at.", "            :type u: float", "            :param v: V value to evaluate the Surface at.", "            :type v: float", "            :param include_negs: Boolean value.", "            :type include_negs: bool", "            :result: Point, first U-direction Vec, second U-direction Vec, first V-direction Vec, second V-direction Vec", "            :rtype: Point, Vec, Vec, Vec, Vec", "            ", "        \"\"\"", "        #nearest neighbors along u and v axis of point(u,v); used for discrete approximations calculations ", "        if u not in self.domain_u : raise DomainError(\"Surface evaluated outside the bounds of its u-domain: deval(%s) %s\"%(u,self.domain_u))", "        if v not in self.domain_v : raise DomainError(\"Surface evaluated outside the bounds of its v-domain: deval(%s) %s\"%(v,self.domain_v))", "        pt = Point(self.func(u,v))", "        ", "        vec_u = False", "        vec_ui = False", "        if (u+self.tol_u_nudge <= self.domain_u.b): ", "            vec_u = Vec(pt,self.func(u + self.tol_u_nudge,v))", "        else:", "            vec_ui = Vec(pt,self.func(u - self.tol_u_nudge,v))", "            vec_u = vec_ui.inverted()", "", "        vec_v = False", "        vec_vi = False", "        if (v+self.tol_v_nudge <= self.domain_v.b): ", "            vec_v = Vec(pt,self.func(u,v + self.tol_v_nudge))", "        else:", "            vec_vi = Vec(pt,self.func(u,v - self.tol_v_nudge))", "            vec_v = vec_vi.inverted()", "", "        if not include_negs : return pt,vec_u,vec_v", "", "        if not vec_ui: ", "            if (u-self.tol_u_nudge >= self.domain_u.a): vec_ui = Vec(pt,self.func(u - self.tol_u_nudge,v))", "            else : vec_ui = vec_u.inverted()", "        if not vec_vi: ", "            if (v-self.tol_v_nudge >= self.domain_v.a): vec_vi = Vec(pt,self.func(u,v - self.tol_v_nudge))", "            else : vec_vi = vec_v.inverted()", "", "        return pt,vec_u,vec_ui,vec_v,vec_vi", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the nearest neighbors along u and v axis of a point(u,v). Used for discrete approximations calculations." ],
          "parameters" : {
            "include_negs" : "Boolean value.\n",
            "u" : "U value to evaluate the Surface at.\n",
            "v" : "V value to evaluate the Surface at.\n"
          },
          "rtype" : "Point, Vec, Vec, Vec, Vec",
          "rvalue" : "Point, first U-direction Vec, second U-direction Vec, first V-direction Vec, second V-direction Vec\n",
          "types" : {
            "include_negs" : "bool\n",
            "u" : "float\n",
            "v" : "float\n"
          }
        },
        "end" : 642,
        "name" : "_nudged",
        "start" : 599
      }, {
        "code" : [ "        \"\"\" Returns a mesh from this Surface.", "        ", "            :param do_close: Boolean value.", "            :type do_close: bool", "            :param tris: Boolean value.", "            :type tris: bool", "            :param divs_u: Boolean value.", "            :type divs_u: bool", "            :param divs_V: Boolean value.", "            :type divs_v: bool", "            ", "            ::", "            ", "                my_surf.to_mesh()", "            ", "        \"\"\"", "        ", "        if not divs_u : divs_u = int(math.ceil(self.domain_u.delta/self.tol_u))", "        if not divs_v : divs_v = int(math.ceil(self.domain_v.delta/self.tol_v))", "        u_vals = self.domain_u.divide((divs_u),True)", "        v_vals = self.domain_v.divide((divs_v),True)", "", "        pts = [self._func(u,v) for v in v_vals for u in u_vals]", "        '''", "        equiv to", "        for v in v_vals:", "            for u in u_vals:", "                pts.append(self._func(u,v))", "        '''", "        msh = Mesh(pts)", "", "        res_u = len(u_vals)", "        if tris is False:", "            # simple quadrangulation style", "            for v in range(len(v_vals)):", "                row = v*res_u", "                for u in range(len(u_vals)-1):", "                    pi_0 = row+u", "                    pi_1 = row+u+1", "                    pi_2 = row+u+res_u+1", "                    pi_3 = row+u+res_u", "                    msh.add_face(pi_0,pi_1,pi_2,pi_3)", "                if do_close:", "                    #last two faces in the row", "                    pi_0 = row+res_u-1", "                    pi_1 = row+0", "                    pi_2 = row+res_u", "                    pi_3 = row+res_u-1+res_u", "                    msh.add_face(pi_0,pi_1,pi_2,pi_3)", "        ", "        else:", "            # simple triangulation style", "            for v in range(len(v_vals)):", "                row = v*res_u", "                for u in range(len(u_vals)-1):", "                    pi_0 = row+u", "                    pi_1 = row+u+1", "                    pi_2 = row+u+res_u+1", "                    pi_3 = row+u+res_u", "                    msh.add_face(pi_0,pi_1,pi_2)", "                    msh.add_face(pi_0,pi_2,pi_3)", "                if do_close:", "                    #last two faces in the row", "                    pi_0 = row+res_u-1", "                    pi_1 = row+0", "                    pi_2 = row+res_u", "                    pi_3 = row+res_u-1+res_u", "                    msh.add_face(pi_0,pi_1,pi_2)", "                    msh.add_face(pi_0,pi_2,pi_3)", "        ", "        return msh", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a mesh from this Surface." ],
          "parameters" : {
            "divs_V" : "Boolean value.\n",
            "divs_u" : "Boolean value.\n",
            "do_close" : "Boolean value.\n",
            "tris" : "Boolean value.\n"
          },
          "types" : {
            "divs_u" : "bool\n",
            "divs_v" : "bool\n\n",
            "do_close" : "bool\n",
            "tris" : "bool\n"
          }
        },
        "end" : 716,
        "name" : "to_mesh",
        "start" : 645
      }, {
        "code" : [ "        \"\"\" Returns an isocurve of this Surface at the given u OR v value.", "        ", "            :param u_val: U-value to extract isocurve at.", "            :type u_val: float or None", "            :param v_val: V-value to extract the isocurve at.", "            :type v_val: float or None", "            :result: Isocurve of Surface.", "            :rtype: Curve", "            ", "            ::", "            ", "                my_surf.isopolyline(u_val=3.5)", "                ", "                OR", "                ", "                my_surf.isopolyline(u_val=None, v_val=2.5)", "            ", "        \"\"\"", "    ", "        if u_val is None and v_val is None: raise AttributeError(\"Surface.isocurve requires either u_val OR v_val to be set\")", "        if u_val is not None and v_val is not None: raise AttributeError(\"u_val AND v_val cannot both be set when generating a Surface.isocurve\")", "", "        if v_val is None:", "            # we're plotting a u-iso" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns an isocurve of this Surface at the given u OR v value." ],
          "parameters" : {
            "u_val" : "U-value to extract isocurve at.\n",
            "v_val" : "V-value to extract the isocurve at.\n"
          },
          "rtype" : "Curve\n\n",
          "rvalue" : "Isocurve of Surface.\n",
          "types" : {
            "u_val" : "float or None\n",
            "v_val" : "float or None\n"
          }
        },
        "end" : 741,
        "name" : "isocurve",
        "start" : 718
      }, {
        "code" : [ "        \"\"\"Returns Polyline isocurve of this Surface at the given u OR v value.", "        ", "            :param u_val: U-value to evaluate isocurve at.", "            :type u_val: float or None", "            :param v_val: V-value to evaluate isocurve at.", "            :type v_val: float or None", "            :param dom: u or v domain of this Surface. ", "            :type dom: Interval or None", "            :param res: Resolution of surface.", "            :type res: float or None.", "            :result: Isocurve of this surface.", "            :rtype: Polyline", "            ", "            ", "        \"\"\"", "        ", "        if u_val is None and v_val is None: raise AttributeError(\"Surface.isocurve requires either u_val OR v_val to be set\")", "        if u_val is not None and v_val is not None: raise AttributeError(\"u_val AND v_val cannot both be set when generating a Surface.isocurve\")", "", "        if v_val is None:", "            # we're plotting a u-iso" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns Polyline isocurve of this Surface at the given u OR v value." ],
          "parameters" : {
            "dom" : "u or v domain of this Surface. \n",
            "res" : "Resolution of surface.\n",
            "u_val" : "U-value to evaluate isocurve at.\n",
            "v_val" : "V-value to evaluate isocurve at.\n"
          },
          "rtype" : "Polyline",
          "rvalue" : "Isocurve of this surface.\n",
          "types" : {
            "dom" : "Interval or None\n",
            "res" : "float or None.\n",
            "u_val" : "float or None\n",
            "v_val" : "float or None\n"
          }
        },
        "end" : 772,
        "name" : "isopolyline",
        "start" : 752
      } ],
      "documentation" : {
        "description" : [ "A simple surface class", "To construct a surface, pass in a function and [optionally] two intervals that determine the a valid range of u&v values.", "The function should expect two parameters u and v (float), and return a Point." ]
      },
      "end" : 772,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_surface.py",
      "name" : "Surface",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Curve" : 4,
          "E_vec" : 3,
          "H" : 3,
          "I_mat" : 2,
          "Interval" : 18,
          "IsParametrized" : 1,
          "K" : 3,
          "M_mat" : 3,
          "M_s" : 5,
          "M_s_restricted" : 1,
          "Mesh" : 2,
          "N_vec" : 13,
          "PLine" : 2,
          "Plane" : 2,
          "Point" : 4,
          "Q_mat" : 10,
          "Surface" : 1,
          "T1_tilde" : 3,
          "T1_vec" : 4,
          "T2_tilde" : 3,
          "T2_vec" : 4,
          "T_k" : 3,
          "Vec" : 15,
          "W_vec" : 4
        },
        "functions" : {
          "__init__" : 1,
          "_nudged" : 1,
          "_rebuild_surrogate" : 1,
          "deval" : 1,
          "deval_curv" : 1,
          "deval_curviso" : 1,
          "deval_pln" : 1,
          "domain_u" : 1,
          "domain_v" : 1,
          "eval" : 1,
          "eval_curv" : 1,
          "eval_curviso" : 1,
          "eval_pln" : 1,
          "iso_func" : 2,
          "isocurve" : 1,
          "isopolyline" : 1,
          "matrix_mult" : 1,
          "surrogate" : 1,
          "to_mesh" : 1,
          "tol_max" : 1,
          "tol_u" : 2,
          "tol_u_nudge" : 1,
          "tol_v" : 2,
          "tol_v_nudge" : 1,
          "u0" : 1,
          "u1" : 1,
          "v0" : 1,
          "v1" : 1
        }
      },
      "start" : 7
    },
    "c636a2a7-7659-4eaf-ae94-22c52eceb026" : {
      "code" : [ "    xform = Xform.translation(Point(2,1)) ", "    xform *= Xform.rotation(center=Point(),angle=math.pi/3, axis=Vec(0,1,1))", "    tb = DzTileB(xf=xform,rlvl=0)", "    out_0.put(tb.draw())", "", "    inflt1 = tb.inflate()", "    for tile in inflt1 : ", "        out_1.put(tile.draw())", "        inflt2 = tile.inflate()", "        for tile in inflt2 : out_2.put(tile.draw())", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 354,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "inflationB",
      "start" : 344
    },
    "c88339d1-1387-4ef7-8171-3b651255b3f0" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_base.py",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 7,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_base.py",
      "name" : "GeometricError",
      "references" : {
        "classes" : {
          "GeometricError" : 1,
          "StandardError" : 1
        }
      },
      "start" : 7
    },
    "c88b5bed-778b-40ae-b6c6-72e3a69f9b46" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def leastSquaresLineTotal(pts_in):", "    # create and set variables to 0", "    x_m, y_m, xsq_m, ysq_m, xy_m = 0,0,0,0,0", "    ", "    # for every point in pts_in:", "    for pt in pts_in :", "        # create the average of all the variables", "        x_m += pt.x/len(pts_in)", "        y_m += pt.y/len(pts_in)", "        xsq_m += pt.x**2/len(pts_in)", "        ysq_m += pt.y**2/len(pts_in)", "        xy_m += pt.x*pt.y/len(pts_in)", "    if (xy_m != x_m*y_m):", "        B = 0.5*((ysq_m - y_m**2)-(xsq_m - x_m**2))/(x_m*y_m -xy_m)", "        m = [-B + math.sqrt(B**2 + 1), -B - math.sqrt(B**2 + 1)]", "        y_coeff = [y_m - m[0]*x_m, y_m - m[1]*x_m]", "        p = [Point(0, y_coeff[0]), Point(0, y_coeff[1])]", "        n0 = Vec(-m[0], 1).normalized()", "        n1 = Vec(-m[1], 1).normalized()", "        # test for the Segment that gives the least distance", "        d0,d1 = 0,0", "        # for every point in the pts_in:", "        for pt in pts_in:", "            d0 += abs(Vec(pt - p[0]).dot(n0))", "            d1 += abs(Vec(pt - p[1]).dot(n1))", "        if d0 < d1: indx_min = 0", "        else: indx_min = 1", "        p_ls = p[indx_min]", "        u_ls = Vec(1, m[indx_min]).normalized()", "    else:", "        p_ls = Point(x_m, 0)", "        u_ls = Vec(0,1)", "    ", "    d_min = Vec(pts_in[0]-p_ls).dot(u_ls)", "    d_max = d_min", "    # for every point in pts_in:", "    for pt in pts_in:", "        d = Vec(pt - p_ls).dot(u_ls)", "        if (d > d_max): d_max = d", "        elif (d < d_min): d_min = d", "    # start and end Points for the Segment", "    start_pt = p_ls + u_ls*d_min", "    end_pt = p_ls + u_ls*d_max", "    return Segment(start_pt, end_pt)" ],
          "end" : 59,
          "start" : 16
        },
        "description" : "\nBest Fit by Total Least Squares\nReturns a best fit Segment defined by total least squares.\n",
        "end" : 16,
        "start" : 13
      } ],
      "documentation" : {
        "description" : [ "4.07.L06b", "Method that returns a best fit Segment defined by total least squares." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Best Fit/4.07.L06b.py",
      "name" : "4.07.L06b.py",
      "references" : {
        "classes" : {
          "B" : 5,
          "Point" : 3,
          "Segment" : 1,
          "Vec" : 8
        }
      },
      "required" : [ "pts_in ([Point]) A list of Points." ],
      "result" : [ "(Segment) A best fit Segment." ]
    },
    "c8ac1485-4427-432a-b984-2dbf80a249f8" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pt_on_surf = surf.eval(u,v)", "", "      " ],
          "end" : 21,
          "start" : 18
        },
        "description" : "\nPoint on Surface\n",
        "end" : 18,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "u_fix = surf.domain_u.eval(0.5) ", "v_fix = surf.domain_v.eval(0.25) ", "iso_u = surf.isocurve(v_val = v_fix, res = 20 ) # this is a curve for which u varies", "iso_v = surf.isopolyline( u_val = u_fix, res = 20 ) # this is a polyline for which v varies", "" ],
          "end" : 28,
          "start" : 24
        },
        "description" : "\nIsocurves and isopolylines\n",
        "end" : 24,
        "start" : 22
      } ],
      "documentation" : {
        "description" : [ "3.09.E01a", "Basic Evaluation of Surfaces" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Surface/Surface Basics/3.09.E01a.py",
      "name" : "3.09.E01a.py",
      "required" : [ "u (float between 0 and 1)", "v (float between 0 and 1)" ],
      "result" : [ "pt_on_surf (Point)", "iso_u (Curve or PLine)", "iso_v (Curve or PLine)" ]
    },
    "caf3bd8a-cd3c-450a-8124-535e95bccc12" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def flatten_ptstrip(pts_a,pts_b,init_ray=Ray(Point(),Vec(0,1))):", "    # initialize lists of points for unrolled strip from a given Ray ", "    fpts_a = [init_ray.spt]", "    init_ray._vec.length = pts_a[0].distance(pts_b[0])", "    fpts_b = [init_ray.spt + init_ray.vec]", "    # Create a CS to lay down the unrolled surfaces", "    cs_tar = CS(Point(),Vec(0,1),Vec(1,0))", "    # for every strip", "    for n in range(len(pts_a)-1):", "        cs_src = CS(pts_b[n],Vec(pts_b[n],pts_a[n]),Vec(pts_b[n],pts_a[n+1]))", "        fpts_b.append(pts_a[n+1]*Xform.change_basis(cs_src,cs_tar))", "        cs_tar = CS(fpts_b[-1],Vec(fpts_b[-1],fpts_a[-1]),Vec(1,0))         ", "        cs_src = CS(pts_a[n+1],Vec(pts_a[n+1],pts_b[n]),Vec(pts_a[n+1],pts_b[n+1]))", "        fpts_a.append(pts_b[n+1]*Xform.change_basis(cs_src,cs_tar))", "        cs_tar = CS(fpts_a[-1],Vec(fpts_a[-1],fpts_b[-1]),Vec(1,0))", "    # return points on either side of flattened strip", "    return fpts_a , fpts_b", "", "" ],
          "end" : 40,
          "start" : 21
        },
        "description" : "\nFlatten Pointstrip\nUnrolls a given strip, defined by two lists of points on either side of strip\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "def mesh_from_ptstrip(pts_a,pts_b,flip = False, quad = False):", "    msh = Mesh()", "    # if quad faces", "    if quad:", "        for pt in pts_a + pts_b : msh.append(pt)", "        for n in range(len(pts_b)):", "            pi_0 = n", "            pi_1 = n+1", "            pi_2 = n+len(pts_b)+1", "            pi_3 = n+len(pts_b)", "            msh.add_face(pi_0, pi_1, pi_2, pi_3)", "    # else if triangular faces", "    else:", "        if flip:", "            for pt in pts_a + pts_b : msh.append(pt)", "            for n in range(len(pts_b)):", "                pi_0 = n", "                pi_1 = n+1", "                pi_2 = n+len(pts_b)+1", "                pi_3 = n+len(pts_b)", "                msh.add_face(pi_0,pi_2, pi_1)", "                msh.add_face(pi_2, pi_0, pi_3)        ", "        else:", "            #flip the order that mesh vertices are stored", "            for pt in pts_b + pts_a : msh.append(pt)", "            for n in range(len(pts_b)):", "                pi_0 = n", "                pi_1 = n+1", "                pi_2 = n+len(pts_a)+1", "                pi_3 = n+len(pts_a)", "                msh.add_face(pi_0,pi_1, pi_2)", "                msh.add_face(pi_2, pi_3, pi_0)        ", "    ", "    return msh", "", "    ", "" ],
          "end" : 80,
          "start" : 44
        },
        "description" : "\nMesh Pointstrip\nCreates a mesh on a strip with optional quad or triangular faces and optional direction of triangles\n",
        "end" : 44,
        "start" : 41
      } ],
      "documentation" : {
        "description" : [ "4.05.L02a", "Functions for transforming a strip in space defined by two lists of points into a flattened mesh in the plane." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Flatness/4.05.L02a.py",
      "name" : "4.05.L02a.py",
      "references" : {
        "classes" : {
          "CS" : 5,
          "Mesh" : 1,
          "Point" : 2,
          "Ray" : 1,
          "Vec" : 11,
          "Xform" : 2
        }
      },
      "required" : [ "pts_a ([Point]) Points defining one side of the strip", "pts_b ([Point]) Points defining other side of the strip", "init_ray(Ray) Ray deterimining arrangement of neighboring strips", "flip (bool) Determines direction of a mesh triangle while preserving orientation", "quad (bool) Determines if faces are quad or triangular" ],
      "result" : [ "flat_ptstr (func) Unrolling function", "mesh_ptstr (func) Meshing function" ]
    },
    "cb62ff7a-143b-4517-b130-e543cd30005b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def rescale(pl,len):", "    factor = len / pl.pts[0].distance(pl.pts[-1])", "    # return a scale transformation from the spt of a PLine", "    return pl * Xform.scale(factor,pl.pts[0])", "" ],
          "end" : 25,
          "start" : 20
        },
        "description" : "\nRescale Function\nRescales a given PLine by a factor based on distance to a given point\n[noprint]\n",
        "end" : 20,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def reorient(pl,seg,do_flip=False):", "    # Ray from the PLine's start Point to its end Point", "    src = Ray(pl.pts[0],Vec(pl.pts[0],pl.pts[-1])) ", "    # Ray from the hexagon's start Point to its end Point", "    tar = Ray(seg.spt,seg.vec)", "    # if the Segment will be flipped: flip the Ray", "    if do_flip: tar = Ray(seg.ept,seg.vec.inverted())", "    cs1 = CS(src.spt,src._vec,Vec(0,0,1))", "    # transform the basis of a CS from the PLine to the edge", "    xf = Xform.change_basis(cs1,CS(tar.spt,tar._vec,Vec(0,0,1)))", "    # Create a new PLine with the transformed points", "    if do_flip:", "        pts = [pt for pt in pl.pts]", "        pts.reverse()", "        return PLine(pts) * xf", "    return PLine(pl.pts) * xf", "    " ],
          "end" : 47,
          "start" : 30
        },
        "description" : "\nReorient Function\nReorients a PLine to a given segment\n[noprint]\n",
        "end" : 30,
        "start" : 26
      }, {
        "code" : {
          "content" : [ "def join(plines):", "    pts = [pt for pt in plines[0].pts]", "    for n in range(1,len(plines)): pts.extend(plines[n].pts[1:])", "    return PLine(pts)", "" ],
          "end" : 57,
          "start" : 52
        },
        "description" : "\nJoin Function\nJoins a given set of PLines\n[noprint]\n",
        "end" : 52,
        "start" : 48
      }, {
        "code" : {
          "content" : [ "", "# create a coordinate system", "ctr = CS()", "# set the edge length", "edge_len = 1.5", "# get the apothem of a hexagon", "apothem = RGon(6,edge_length=edge_len).apothem", "", "for v in range(cnt_v):", "    tiles = []", "    # set the CS according to a Point", "    ctr.origin = Point(0,v*apothem*2,0)", "    for u in range(cnt_u):", "        # create a hexagon", "        hex = RGon(6,edge_length=edge_len,basis=ctr)", "        dx = 1.5*edge_len", "        dy = apothem", "        # rotate every other row to properly tile", "        hex.rotate(v*-2)", "        # if the column number is odd: move it down", "        if u%2!=0 :", "            dy *=-1", "            # rotate every other column to properly tile", "            hex.rotate(2) ", "        tiles.append(hex)", "        # Move the CS origin", "        ctr.origin += Vec(dx,dy,0)", "" ],
          "end" : 89,
          "start" : 61
        },
        "description" : "\nHexagonal Grid Routine\nCreate a hexagonal grid with the P3 wallpaper pattern. \n",
        "end" : 61,
        "start" : 58
      }, {
        "code" : {
          "content" : [ "# scale the modified edges to be applied to edges 0, 2, 4", "edge_length = tiles[0].edges[0].length", "pl_a = rescale(pl_a,edge_length)", "pl_b = rescale(pl_b,edge_length)", "pl_c = rescale(pl_c,edge_length)", "", "for tile in tiles:", "    sides = []", "\t# apply modified edge to edge 0", "    sides.append(reorient(pl_a,tile.edges[0]))", "    # rotate to get edge 1", "    sides.append(reorient(pl_a,tile.edges[1],True))", "\t# apply modified edge to edge 2", "    sides.append(reorient(pl_b,tile.edges[2]))", "\t# rotate to get edge 3", "    sides.append(reorient(pl_b,tile.edges[3],True))", "\t# apply modified edge to edge 4", "    sides.append(reorient(pl_c,tile.edges[4]))", "\t# rotate to get edge 5", "    sides.append(reorient(pl_c,tile.edges[5],True))", "    " ],
          "end" : 114,
          "start" : 94
        },
        "description" : "\nApply Tiles\nApply construction of modified tile to every hexagon in the grid\n[pseudo]\n",
        "end" : 94,
        "start" : 90
      } ],
      "documentation" : {
        "description" : [ "4.01.L03a", "Create a hexagonal grid with a given number of rows and columns. Tile three given segments to create an Escher tiling." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Escher Tessellation/4.01.L03a.py",
      "name" : "4.01.L03a.py",
      "references" : {
        "classes" : {
          "CS" : 3,
          "PLine" : 3,
          "Point" : 1,
          "RGon" : 2,
          "Ray" : 3,
          "Vec" : 4,
          "Xform" : 2
        }
      },
      "required" : [ "cnt_u (int) U number of tiles (int).", "cnt_v (int) V number of tiles (int).", "pl_a (PLine) first PLine of tiling.", "pl_b (PLine) first PLine of tiling.", "pl_c (PLine) first PLine of tiling." ],
      "result" : [ "ret ([PLine]) Escher tiling." ]
    },
    "cc2b4d3e-9d4c-48e3-8722-f747b64f35ee" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def sphere_invert(p, origin, r_i):", "    vec = Vec(origin,p)", "    vec.length = r_i**2/vec.length", "    return origin + vec", "\t", "" ],
          "end" : 22,
          "start" : 16
        },
        "description" : "\nSphere Inversion\nInverts a point with respect to a sphere centered at origin with radius r_i\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "max_rad = 3*r_i", "v = Vec(1,1,1).normalized()", "#vectors perpendicular to v", "v_perp_1 = Vec(-1,0,1).normalized()", "v_perp_2 = Vec(1,-1,0).normalized()", "v_perp_3 = Vec(0.5, 0.5, -1).normalized()", "", "#inversion of a point", "ln_pt = Segment(origin, v*max_rad)", "pt = ln_pt.eval(pt_rad)", "pt_i = sphere_invert(pt, origin, r_i)", "print Vec(origin, pt).length*Vec(origin, pt_i).length, r_i**2", "", "#inversion of a circle not going through origin invert to circles", "circ = Circle(Plane(pt, v), circ_rad*max_rad)", "#find points on circle", "pt1 = pt + v_perp_1*circ.rad", "pt2 = pt + v_perp_2*circ.rad", "pt3 = pt + v_perp_3*circ.rad", "pt1_i = sphere_invert(pt1, origin, r_i)", "pt2_i = sphere_invert(pt2, origin, r_i)", "pt3_i = sphere_invert(pt3, origin, r_i)", "circ_i = Circle.thru_pts(pt1_i, pt2_i, pt3_i)", "", "def get_tangent(circle, pt):", "    n_vec = circle._vec", "    circ_center = circle.plane.origin", "    return Vec(circ_center, pt).cross(n_vec)", "" ],
          "end" : 55,
          "start" : 26
        },
        "description" : "\nInversion of Points and Circles\n[noprint]\n",
        "end" : 26,
        "start" : 23
      }, {
        "code" : {
          "content" : [ "max_rad = 3*r_i", "", "r = max_rad*circ_rad", "", "p1 = Point(-r,0,0)", "p2 = Point(0,-r,0) #hinge point", "p3 = Point(r,0,0)", "circ_fixed = Circle.thru_pts(p1, p2, p3)", "", "rot = Xform().rotation(center = Point(), axis = Vec(0,1,0), angle = angle)", "p1_rot = p1*rot", "p2_rot = p2*rot", "p3_rot = p3*rot", "circ_rot = Circle.thru_pts(p1_rot, p2_rot, p3_rot)", "", "p1_i = sphere_invert(p1, origin, r_i)", "p2_i = sphere_invert(p2, origin, r_i)", "p3_i = sphere_invert(p3, origin, r_i)", "circ_fixed_i = Circle.thru_pts(p1_i, p2_i, p3_i)", "", "p1_rot_i = sphere_invert(p1_rot, origin, r_i)", "p2_rot_i = sphere_invert(p2_rot, origin, r_i)", "p3_rot_i = sphere_invert(p3_rot, origin, r_i)", "circ_rot_i = Circle.thru_pts(p1_rot_i, p2_rot_i, p3_rot_i)", "", "#check angle between tangents of inverted circles at hinge point", "tan = get_tangent(circ_fixed_i, p2_i)", "tan_rot = get_tangent(circ_rot_i, p2_rot_i)", "angle_i = tan.angle(tan_rot)", "print \"Angle between circles at hinge is\", degrees(angle)", "print \"Angle between inverted circles is\", degrees(angle_i)", "" ],
          "end" : 91,
          "start" : 60
        },
        "description" : "\nDemo of Invariance of Angle\nCreate two circles with a common hinge point and invert them\n[noprint]\n",
        "end" : 60,
        "start" : 56
      } ],
      "documentation" : {
        "description" : [ "4.03.L04b", "Inversion with respect to a sphere and some demos of its properties" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Pre-Rational Torus Studies/4.03.L04b.py",
      "name" : "4.03.L04b.py",
      "references" : {
        "classes" : {
          "Circle" : 6,
          "Plane" : 1,
          "Point" : 4,
          "Segment" : 1,
          "Vec" : 9,
          "Xform" : 1
        }
      },
      "required" : [ "origin (Point) - center of inversion", "r_i (float) - radius of inversion" ],
      "result" : [ "sphere_invert (func)" ]
    },
    "cc373816-4619-4c2c-928f-7c8df23ee673" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def child_by_face(trunc, pt_num):", "    # define a CS at the center of the specified triangular face", "    face_pts = trunc.trunc_pts[pt_num]", "    cent = Point.centroid(face_pts)", "    # the x-axis orientation of the CS is determined by pt_num", "    cen = 1 if pt_num % 2 else 0", "    cs = CS(cent, Vec(cent,face_pts[cen]),Vec(cent,face_pts[2]))", "    # construct a new scaled-down Tetrahedron", "    new_tet = Tetrahedron.from_face_center(cs,0.375*trunc.tetra.rad2)", "    # return a TruncTet", "    return TruncTet(new_tet, 0.75)", "" ],
          "end" : 31,
          "start" : 19
        },
        "description" : "\nChild of TruncTet\nGiven a parent TruncTet, creates a child that rests upon a triangular face corresponding to a given index\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "def brother_by_face(trunc, pt_num, do_hex = False, flip = False):", "    face_pts = trunc.trunc_pts[pt_num]", "    cent = Point.centroid(face_pts)", "    #vector from the sibling's center to the center of face", "    vec =  Vec(trunc.tetra.basis.origin, trunc.tetra.pts[pt_num]) * 0.8333", "    # if we want a hex face, simply reverse this vector", "    if do_hex : vec = -vec", "    ", "    # construct the CS for the desired TruncTet", "    x_axis = Vec(cent,face_pts[1])", "    y_axis = -Vec(cent,face_pts[0])", "    # reverse the y_axis in certain conditions to avoid overlaps", "    if (pt_num %2 == 1) or flip : y_axis = -y_axis", "    cs = CS(cent+vec, x_axis, y_axis)", "    ", "    # construct the new TruncTet at the same radius as sibling", "    n_trunc = Tetrahedron.from_face_center(cs, trunc.tetra.rad2)", "    return TruncTet(n_trunc, .75)", "    " ],
          "end" : 54,
          "start" : 35
        },
        "description" : "\nBrother of TruncTet\nGiven a sibling TruncTet, creates a brother that rests upon a hex face or a triangular face\n",
        "end" : 35,
        "start" : 32
      }, {
        "code" : {
          "content" : [ "# a matrix describing topological connections of ring", "topo =( \\", "        ((0,2,2),(3,0,0)), \\", "        ((3,0,3),(2,3,2)), \\", "        ((0,0,3),(2,2,0)), \\", "        ((0,3,3),(3,2,2)) )", "", "def tet_ring(trunc, face_num):", "    # a child on each face except the one to be encircled", "    children = [child_by_face(trunc, f) for f in range(4) if f != face_num]", "    siblings = []", "    # for each of the three children:", "    for i, tet in enumerate(children):", "        # create three brothers", "        siblings.append(brother_by_face(tet, topo[face_num][0][i]))", "        siblings.append(brother_by_face(tet, topo[face_num][1][i]))", "        siblings.append(brother_by_face(tet, topo[face_num][1][i], flip=True))", "    ", "    return children + siblings", "" ],
          "end" : 78,
          "start" : 58
        },
        "description" : "\nRing of TruncTets\nCreates a ring of children that encircles a hexagonal face corresponding to a given index\n",
        "end" : 58,
        "start" : 55
      }, {
        "code" : {
          "content" : [ "# start with a single seed Tetrahedron", "seed_tet = Tetrahedron.from_face_center()", "", "# create a series of large TruncTets", "tet_a = TruncTet(seed_tet, .75)", "# Brother by hex face", "tet_b = brother_by_face(tet_a, 2, do_hex = True)", "# Brothers by tri face", "tet_c = brother_by_face(tet_b, 1)", "tet_d = brother_by_face(tet_c, 0)", "# Brother by hex face", "tet_e = brother_by_face(tet_d, 1, do_hex = True)", "", "# create rings of mediumTets on selected largeTets", "ring_a = tet_ring(tet_a, face_select)", "ring_b = tet_ring(tet_c, face_select)", "ring_c = tet_ring(tet_e, face_select)", "med_ring = ring_a + ring_b + ring_c", "", "" ],
          "end" : 102,
          "start" : 82
        },
        "description" : "\nThe Morning Line Pavilion Arrangement\nSelectively deploying each of the TruncTet generation functions above, composes an arrangement of medium-sized TruncTets that recalls the Morning Line Pavilion\n",
        "end" : 82,
        "start" : 79
      }, {
        "code" : {
          "content" : [ "smalls = []", "for tet in med_ring :", "    for n in range(4):", "        if random.random() < probability :", "            smalls.append(child_by_face(tet,n))", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          "end" : 129,
          "start" : 106
        },
        "description" : "\nRandomly Place Small TruncTets\nSmall TruncTets are randomly spawned from rings of medium-sized TruncTets, some of which will intersect unpleasantly and will require removal.\n",
        "end" : 106,
        "start" : 103
      } ],
      "documentation" : {
        "description" : [ "4.01.F01d", "A Composed Aggregation of TruncTets" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Aranda Lasch Fractal/4.01.F01d.py",
      "name" : "4.01.F01d.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Point" : 2,
          "Tetrahedron" : 3,
          "TruncTet" : 3,
          "Vec" : 5
        }
      },
      "required" : [ "face_select (int) Selects the position of ring of medium-sized TruncTets", "face_list ([PLine]) Faces of a set of TruncTets", "face_options ([[Pline]]) List of optional tile patterns" ],
      "result" : [ "med_ring([TruncTet]) A list of the medium TruncTets", "smalls([TruncTet]) A list of the small TruncTets", "pavilion ([[PLine]]) A list of Polylines representing the pattern for each face of the pavilion." ]
    },
    "cd09b325-1bc2-498c-960c-78ade5f7d9ba" : {
      "documentation" : {
        "description" : [ "2.01.E01g", "The conditional statement (or \"if\" statement) is one of the most recognizable structures of code, and operates as we might expect: statements contained within the \"code block\" following the conditional are only executed if the \"boolean condition\" is evaluated to be true." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01g.py",
      "name" : "2.01.E01g.py",
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "d04411f3-a695-4d3f-a019-778149c4a4db" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class TruncTet(object):", "    def __init__(self, base_tet, trunc_val):", "        self.trunc = trunc_val", "        self.tetra = base_tet", "    ", "    \"\"\"", "    Truncation Points", "    Returns the truncation points (trunc_pts) of the Truncated Tetrahedron structured as nested lists of points, grouped in relation to each of the four points of the larger Tetrahedron (tetra_pts)", "    \"\"\"", "    @property", "    def trunc_pts(self):", "        #returns a list of trunc_pts for a given tetra_pt", "        def func(idx):", "            # the edges adjacent to a given tetra_pt", "            edges = self.tetra.adjacent_edges(idx)", "            # returns trucation points for each adjacent edge", "            return [edge.eval(self.trunc/2) for edge in edges]", "            ", "        # returns a list of trunc_pts for each of the four tetra_pts", "        return map(func,range(4))", "     ", "    \"\"\"", "    Truncation Tips", "    Returns the smaller 'left over' Tetrahedrons at the corners of this TruncTet", "    \"\"\"", "    @property", "    def tips(self):", "        # returns a Tetrahedron for a given set of trunc_pts", "        def func(pts):", "            ctr = Point.centroid(pts)", "            rad = ctr.distance(pts[0])", "            # the x-axis is oriented toward the first trunc_pt", "            cs = CS(ctr,Vec(ctr, pts[0]),Vec(ctr, pts[1]))", "            return Tetrahedron.from_face_center(cs,rad)", "            ", "        # returns a Tetrahedron for each of the four sets of trunc_pts", "        return map(func,self.trunc_pts)", "", "    \"\"\"", "    Creates a mesh from the Truncated Tetrahedron", "    [noprint]", "    \"\"\"", "    def to_mesh(self):", "        # Initiate the mesh object. ", "        msh = Mesh()", "        msh_pts = []", "        # For each group of points:", "        for pts in self.trunc_pts:", "            # For every point in points:", "            for p in pts:", "                msh.append(p)", "                msh_pts.append(p)", "        # Append the centroid of a tetrahedron face to the mesh vertices.", "        msh.append(PGon([msh_pts[1],msh_pts[2], msh_pts[6], msh_pts[7], msh_pts[9], msh_pts[11]]).centroid)", "        # Define the faces of the mesh.", "        msh.add_face(12,1,2)", "        msh.add_face(12,7,1)", "        msh.add_face(12,6,7)", "        msh.add_face(12,11,6)", "        msh.add_face(12,9,11)", "        msh.add_face(12,2,9)", "        ", "        msh.append(PGon([msh_pts[1],msh_pts[0], msh_pts[8], msh_pts[3], msh_pts[5], msh_pts[7]]).centroid)", "        msh.add_face(13,1,7)", "        msh.add_face(13,7,8)", "        msh.add_face(13,8,3)", "        msh.add_face(13,3,5)", "        msh.add_face(13,5,0)", "        msh.add_face(13,0,1)", "        ", "        msh.append(PGon([msh_pts[0],msh_pts[2], msh_pts[4], msh_pts[5], msh_pts[10], msh_pts[9]]).centroid)", "        msh.add_face(14,2,0)", "        msh.add_face(14,0,5)", "        msh.add_face(14,5,4)", "        msh.add_face(14,4,10)", "        msh.add_face(14,10,9)", "        msh.add_face(14,9,2)", "        ", "        msh.append(PGon([msh_pts[3],msh_pts[4], msh_pts[6], msh_pts[8], msh_pts[10], msh_pts[11]]).centroid)", "        msh.add_face(15,4,3)", "        msh.add_face(15,3,8)", "        msh.add_face(15,8,6)", "        msh.add_face(15,6,11)", "        msh.add_face(15,11,10)", "        msh.add_face(15,10,4)", "        ", "        msh.add_face(0,2,1)", "        msh.add_face(3,4,5)", "        msh.add_face(6,8,7)", "        msh.add_face(9,10,11)", "              ", "        return msh", "        ", "    \"\"\"", "    Hexagonal Face", "    Returns a polygon representation of an hexagonal face of this TruncTet. Each face is indexed according to the tetra_pt that it lies across from.", "    \"\"\"", "    def hex_face(self, idx):", "        # three tetra_pts, excluding pt related to given index", "        pts = [pt for n,pt in enumerate(self.tetra.pts) if n != idx]", "        # construct a CS from the face centroid and two vectors", "        ctr = Point.centroid(pts)", "        cs = CS(ctr, Vec(ctr, pts[0]), Vec(ctr, pts[1]))", "        # construct the points required to make this face", "        hex_pts = []", "        for f in range(len(pts)):", "            hex_pts.append(PLine([pts[f], pts[f-1]]).eval(self.trunc/2))", "            hex_pts.append(PLine([pts[f], pts[f-2]]).eval(self.trunc/2))", "        # create a polygon using points defined relative to the CS", "        verts = [cs.deval(pt) for pt in hex_pts]", "        return PGon(verts,cs)", "", "    \"\"\"", "    Returns polygons for all faces.", "    [noprint]", "    \"\"\"", "    def hex_faces(self):", "        ret = [self.hex_face(f) for f in range(4)]", "        return ret", "" ],
          "end" : 140,
          "start" : 21
        },
        "description" : "\nTruncated Tetrahedron Class\nCreates a Truncated Tetrahedron from a base Tetrahedron and a truncation value\n",
        "end" : 21,
        "start" : 18
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Aranda Lasch Fractal/4.01.F01b.py",
      "name" : "4.01.F01b.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Mesh" : 1,
          "PGon" : 5,
          "PLine" : 2,
          "Point" : 2,
          "Tetrahedron" : 1,
          "TruncTet" : 1,
          "Vec" : 4
        }
      }
    },
    "d13720e9-7414-4800-93ec-87e9d0d1afe2" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def facade_area(func, res=10):", "    circumferences = []", "    # for every interval in the intervals:", "    for ival in Interval()//res:", "        # evaluate 2 Points on the Surface", "        pt_a = func(0.5,ival.a).origin", "        pt_b = func(0.5,ival.b).origin", "        # get the center Point of the floor", "        cpt = Point(0,0,pt_a.z)", "        # get the radius of the floor", "        radius = cpt.distance(pt_a)", "        # get the circunference of the floor", "        circ = math.pi * 2 * radius", "        # get the facade area of a single floor", "        circumferences.append(circ * (pt_b.z - pt_a.z) )", "    # get the area of all the facade", "    fac_area = sum(circumferences)", "    # add in a roof to the facade area", "    top_pt = func(0.5,1.0).origin", "    top_radius = top_pt.distance(Point(0,0,top_pt.z))", "    fac_area += math.pi * (top_radius**2)", "    # return the total facade area", "    return (fac_area)", "" ],
          "end" : 42,
          "start" : 17
        },
        "description" : "\nCalculate Facade Area\nMethod that returns the facade area of a given rotational surface.\n",
        "end" : 17,
        "start" : 14
      }, {
        "code" : {
          "content" : [ "", "def floor_area(func):", "    floor_areas = []", "    # for every interval in the intervals:", "    for ival in Interval()//floor_count:", "        # evaluate a Point on the surface", "        pt_a = func(0.5,ival.a).origin", "        # get the center Point of the floor", "        cpt = Point(0,0,pt_a.z)", "        # get the radius of the floor", "        radius = cpt.distance(pt_a)", "        # get the area of the whole floor", "        area_out = math.pi * (radius**2)", "        # get the minor radius", "        radius = max([0.01,radius-max_floor_depth])", "        # get the area of the minor Circle", "        area_in = math.pi * (radius**2)", "        # get the floor area by subtracting the Circles ", "        floor_areas.append(area_out-area_in)", "    # get the sum of all floor areas", "    flr_area = sum(floor_areas)", "    return (flr_area)", "" ],
          "end" : 69,
          "start" : 46
        },
        "description" : "\nCalculate Floor Area\nMethod that returns the floor area of a given rotational surface.\n",
        "end" : 46,
        "start" : 43
      }, {
        "code" : {
          "content" : [ "def floor_circs(func):", "    in_circs = []", "    out_circs = []", "    # for every interval in the intervals:", "    for ival in Interval()//floor_count:", "        # evaluate a Point on the surface", "        pt_a = func(0.5,ival.a)", "        # get the center Point of the floor", "        cpt = Point(0,0,pt_a.z)", "        # get the radius of the floor", "        radius = cpt.distance(pt_a)", "        # create the outer Circle", "        out_circs.append(Circle(Plane(Point(0,0,pt_a.z)),radius))", "        # get the radius of the inner Circle", "        radius = max([0.01,radius-max_floor_epth])", "        # create the inner Circle", "        in_circs.append(Circle(Plane(Point(0,0,pt_a.z)),radius))", "    return ([out_circs,in_circs])", "", "", "" ],
          "end" : 94,
          "start" : 73
        },
        "description" : "\nCreate inner and outer floor Circles from a given Surface.\n[noprint]\n",
        "end" : 73,
        "start" : 70
      }, {
        "code" : {
          "content" : [ "", "# set initial values for the calculation", "max_floor_depth = 0.153", "floor_count = 5", "# get the floor to facade area ratio", "ff_ratio = facade_area(surf) / floor_area(surf)", "" ],
          "end" : 104,
          "start" : 98
        },
        "description" : "\nCalculate Floor-to-Facade Area Ratio\nSubdivides a given Surface into a given number of floors, and calculate the floor to facade area ratio with this division\n",
        "end" : 98,
        "start" : 95
      } ],
      "documentation" : {
        "description" : [ "4.07.L02b", "Given a cylindrical surface, and using internalized values for floor count and depth, calculate the facade area and floor area, as well as the fitness ratio between the two." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Floor-Facade Area Optimization/4.07.L02b.py",
      "name" : "4.07.L02b.py",
      "references" : {
        "classes" : {
          "Circle" : 2,
          "Interval" : 3,
          "Plane" : 2,
          "Point" : 6
        }
      },
      "required" : [ "surf (Surface) A surface." ],
      "result" : [ "new_mesh (Mesh) A Mesh representation of the facade.", "a series of circles representing the floors", "ff_ratio (float) Floor to facade ratio." ]
    },
    "d1a5bb51-5100-4b3f-ab8d-f63c03c14710" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "count = 3", "for n in range(count):", "    print \"n is equal to\", n", "    " ],
          "end" : 19,
          "start" : 15
        },
        "description" : "\nA loop that uses the built-in range function\n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "for dictum in [\"more.\" , \"a bore.\"]:", "    print \"Less is\", dictum" ],
          "end" : 23,
          "start" : 22
        },
        "description" : "\nA loop that iterates through an explicitly defined list\n",
        "end" : 22,
        "start" : 20
      } ],
      "documentation" : {
        "description" : [ "2.01.E01h", "A loop is a statement which indicates that the code block to follow, while only written once, is to be executed multiple times in succession until a given condition is met or a given sequence is exhausted." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01h.py",
      "name" : "2.01.E01h.py",
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "d1c3af98-a546-4478-8011-e7ddc6f91cf5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "taken_nodes = []", "dead_agents = []", "faces_left_unoccupied = 200", "", "# keep going until a given number of faces is occupied", "while len(taken_nodes) < len(graph.nodes)- faces_left_unoccupied:", "    # a new agent that knows which faces have been taken", "    agent = DirectedWalker(graph, choice_func, taken_nodes)", "    # let the agent run", "    while agent.is_alive: agent.step()", "    # record which faces this agent has occupied", "    for p in agent.hist: taken_nodes.append(p)", "    # append it to the dead agent list", "    dead_agents.append(agent)", "", "", "" ],
          "end" : 29,
          "start" : 13
        },
        "description" : "\nDirected Walking Routine\nCreates a series of directed walking agents, and steps each one until he dies\n",
        "end" : 13,
        "start" : 10
      } ],
      "documentation" : {
        "description" : [ "4.02.F02c", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Fornes/4.02.F02c.py",
      "name" : "4.02.F02c.py",
      "references" : {
        "classes" : {
          "DirectedWalker" : 1
        }
      }
    },
    "d4fbd02c-e935-41bf-82f1-990a79b09ded" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def color_pt(r,g,b,wei=False):", "    pt = Point(r,g,b)", "    pt.set_color(r,g,b)", "    if wei: pt.set_weight(wei)", "    return pt", "", "" ],
          "end" : 21,
          "start" : 13
        },
        "description" : "\nRGB Point\nGiven an RGB value, create a Point at the appropriate location in RGB space, and assign the given RGB color and display weight.\n",
        "end" : 13,
        "start" : 10
      }, {
        "code" : {
          "content" : [ "# divide an interval into a range of values", "vals = Interval().divide(cnt,True)", "# create a Point for each combination of rgb values:", "pts = [color_pt(r,g,b,20) for r,g,b in itertools.product(vals,repeat=3)]" ],
          "end" : 28,
          "start" : 25
        },
        "description" : "\nColor Cube\nCreate a collection of Points positioned within a 'design space' of RGB colors wherein colors are assigned based upon the XYZ position of each Point.\n",
        "end" : 25,
        "start" : 22
      } ],
      "documentation" : {
        "description" : [ "4.04.L01a", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/Design Space of Colors/4.04.L01a.py",
      "name" : "4.04.L01a.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 1
        }
      }
    },
    "d662a720-730e-4fae-9233-3f0965115177" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# create the interior and exterior Circles ", "cir1 = Curve.circle(Point(),rad_small).divide(divs,False)", "cir2 = Curve.circle(Point(),rad_large).divide(divs,False)", "", "humps = 3", "sin = math.sin(i)+1", "# create a list of sine values", "sine = [sin * strength for i in Interval(0,math.pi*2*humps).divide(divs)]", "all_pts = []", "# for every index and Point in cir2:", "for i, pt in enumerate(cir2):", "    # translate the points of the larger circle in Z", "    pt = pt + Vec(0,0,sine[i])", "    mid = Segment(cir1[i],pt).eval(mid_pt)+Vec(0,0,height)", "    # append the starting Point, mid Point and end Points", "    all_pts.append([cir1[i],mid,pt])", "" ],
          "end" : 39,
          "start" : 21
        },
        "description" : "\nPlot Guide Points\nCreate 2 Circles of given radii and subdvide each into a number of Points. Construct segments between each pair of the points, and displace the midpoint of the the z-direction. \n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "do_flip = []", "# for every index in the number of Point lists:", "for i in range(len(all_pts)):", "    # if the value is even: flip the direction of the Curve ", "    if i%2 == 0: do_flip.append(True)", "    else: do_flip.append(False)", "    ", "# for every index and Point in the lists of Points: ", "for i, pts in enumerate(all_pts):", "    # if reverse is True: flip the order of the list", "    if do_flip[i]: pts.reverse()", "    # create a Curve with the list of points", "    curve = Curve.bezier(pts)" ],
          "end" : 55,
          "start" : 43
        },
        "description" : "\nString Beziers\nFlip the direction of every other of a given set of point lists. Create a bezier that interpolates the results.\n",
        "end" : 43,
        "start" : 40
      } ],
      "documentation" : {
        "description" : [ "4.05.F01a", "Given 2 Circle radii, create 2 Circles and subdivide them in a given number of Points. Translate the Points of the larger Circle in Z direction with a sine function. Create bezier Curves with the Points of both Circles and a mid Point." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Bending Active/4.05.F01a.py",
      "name" : "4.05.F01a.py",
      "references" : {
        "classes" : {
          "Curve" : 3,
          "Interval" : 1,
          "Point" : 2,
          "Segment" : 1,
          "Vec" : 2
        }
      },
      "required" : [ "rad_small (float) Radius of the inner Circle.", "rad_large (float) Radius of the outter Circle.", "divs (int) Number of divisions for the Circle.", "mid_pt (float) Value to evaluate the Segments between inner and outer Circle to get the mid Point.", "height (float) Heigth of the bezier Curve.", "strength (float) Displacement strength for the Points affected by the sine function." ],
      "result" : [ "curve (Curve) Bezier Curves." ]
    },
    "d684bad3-5c14-438b-b571-dce5a47e92b8" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "alpha = math.atan(rec_h/rec_w)", "pi = math.pi", "pi_over_2 = 0.5*pi", "", "def func_rec(t):", "    c = math.cos(t)", "    s = math.sin(t)", "    ", "    if (t >=0) and (t < alpha):", "        l_coord = 0.5*rec_w*s/c", "        pt_out = Point(rec_w/2, l_coord)", "    elif (t >= alpha) and (t < pi-alpha):", "        l_coord = 0.5*rec_h*c/s", "        pt_out = Point(l_coord, rec_h/2)", "    elif (t >= pi-alpha) and (t < pi + alpha):", "        l_coord = -0.5*rec_w*s/c", "        pt_out = Point(-rec_w/2, l_coord)", "    elif (t >= pi + alpha) and (t < 2*pi - alpha):", "        l_coord = -0.5*rec_h*c/s", "        pt_out = Point(l_coord, -rec_h/2) ", "    elif (t >= 2*pi-alpha) and (t <= 2*pi):", "        l_coord = 0.5*rec_w*s/c", "        pt_out = Point(rec_w/2, l_coord)", "    else:", "        print \"Out-of-bounds!\"", "   ", "    return pt_out", "", "    " ],
          "end" : 43,
          "start" : 14
        },
        "description" : "\n",
        "end" : 14,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "crv_rec = Curve(func,Interval.twopi())", "" ],
          "end" : 47,
          "start" : 45
        },
        "description" : "\n",
        "end" : 45,
        "start" : 44
      }, {
        "code" : {
          "content" : [ "crv_side = Curve(func_rec,Interval(0,alpha))", "crv_top = Curve(func_rec, Interval(alpha, pi_over_2))", "" ],
          "end" : 52,
          "start" : 49
        },
        "description" : "\n",
        "end" : 49,
        "start" : 48
      }, {
        "code" : {
          "content" : [ "def func(t):", "    pt_a = curve_a.eval(t)", "    pt_b = curve_b.eval(t)", "    return Point.interpolate(pt_a,pt_b,tt) ", "" ],
          "end" : 59,
          "start" : 54
        },
        "description" : "\n",
        "end" : 54,
        "start" : 53
      }, {
        "code" : {
          "content" : [ "def func_interpolate(t):", "    pts = [Point(1,0),Point(rad_mid,mid_height),Point(0,1)]", "    m_curve = Curve.bezier(pts).eval(m)", "    return curve_a.eval(t)*m_curve.x + curve_b.eval(t)*m_curve.y", "    ", "    " ],
          "end" : 67,
          "start" : 61
        },
        "description" : "\n",
        "end" : 61,
        "start" : 60
      }, {
        "code" : {
          "content" : [ "for tt in Interval().divide(10):      ", "    crv_out = Curve(func,Interval())", "    a.put(crv_out.surrogate)" ],
          "end" : 71,
          "start" : 69
        },
        "description" : "\n",
        "end" : 69,
        "start" : 68
      } ],
      "documentation" : {
        "description" : [ "3.07.E02c", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Parametrization/3.07.E02c.py",
      "name" : "3.07.E02c.py",
      "references" : {
        "classes" : {
          "Curve" : 5,
          "Interval" : 5,
          "Point" : 9
        }
      },
      "required" : [ "TODO" ],
      "result" : [ "TODO" ]
    },
    "d6a94c19-7ba3-48cd-ae45-c01ef886da67" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_danzer.py",
      "definitions" : [ {
        "code" : [ "        #create a child TileB by mapping child pts[2,1,0] to parent pts[0,1,3]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,2,1,0 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,0,1,3 )", "        tileB0 = self.child_by_explicit(\"B0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[1,2,0] to parent pts[3,2,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,1,2,0 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,3,2,1 )", "        tileC0 = self.child_by_explicit(\"C0\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        #create a child TileC by mapping child pts[2,3,1] to parent pts[2,0,1]", "        cs_chld = DzTileC().cs_by_base_pts(self.rlvl+1,2,3,1, True )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,2,0,1 )", "        tileC1 = self.child_by_explicit(\"C1\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mapping child pts[2,0,3] to parent pts[3,1,0]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,2,0,3, True)", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,3,1,0 )", "        tileK0 = self.child_by_explicit(\"K0\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK0.cs_by_tile_pts(0,1,3)", "        tileK1 = tileK0.sibling_by_mirror(\"K1\",cs_mir)", "        ", "        #create a child TileB by mapping child pts[2,3,1] to parent pts[0,3,2]", "        cs_chld = DzTileB().cs_by_base_pts(self.rlvl+1,2,3,1 )", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,0,3,2 )", "        tileB1 = self.child_by_explicit(\"B1\",cs_chld,cs_prnt,self.flip) # same handedness as parent", "        tileB2 = self.child_by_explicit(\"B2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mapping child pts[1,0,2] to parent pts[1,3,2]", "        cs_chld = DzTileK().cs_by_base_pts(self.rlvl+1,1,0,2, True)", "        cs_prnt = DzTileA().cs_by_base_pts(self.rlvl,1,3,2 )", "        tileK2 = self.child_by_explicit(\"K2\",cs_chld,cs_prnt,not self.flip) # opposite handedness as parent", "        #create a child TileK by mirroring the previous tile", "        cs_mir = tileK2.cs_by_tile_pts(0,1,3)", "        tileK3 = tileK2.sibling_by_mirror(\"K3\",cs_mir)", "        ", "        #create two child TileK by mirroring the previous two tiles", "        cs_mir = tileK2.cs_by_tile_pts(0,2,3)", "        tileK4 = tileK2.sibling_by_mirror(\"K4\",cs_mir)##", "        tileK5 = tileK3.sibling_by_mirror(\"K5\",cs_mir)", "        ", "        #return all children", "        return [tileB0,tileC0,tileC1,tileK0,tileK1,tileB1,tileB2,tileK2,tileK3,tileK4,tileK5]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 204,
        "name" : "inflate",
        "start" : 164
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 204,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DzTileA",
      "references" : {
        "classes" : {
          "DzTile" : 1,
          "DzTileA" : 7,
          "DzTileB" : 2,
          "DzTileC" : 2,
          "DzTileK" : 2,
          "Point" : 4,
          "_base_pts" : 1
        },
        "functions" : {
          "inflate" : 1
        }
      },
      "start" : 153
    },
    "d74d8ba6-4d91-4854-829d-b92e9fcbba46" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def epw_data(filepath):", "    radValues = parse_epw_file(filepath, \"DirNormIrad\")", "    # collect all the values from the file", "    metadata = epw_metadata(filepath)", "    # create a dictionary with all the relevant values", "    dict = {}", "    dict['lat'] = metadata['lat']", "    dict['long'] = metadata['long']", "    dict['timezone'] = metadata['timezone']", "    dict['name'] = metadata['name']", "    dict['radiation'] = radValues", "    # return the dictionary", "    return dict", "" ],
          "end" : 36,
          "start" : 21
        },
        "description" : "\nParse EPW Data\nGiven a path to an EPW file, extracts the direct normal irradiance, lat, long, tmz.\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "def sun_vec(hr, epwdata):", "    # initiate a SolarGeom object with a lat, lon and time ", "    sg = SolarGeom(epwdata['lat'], epwdata['long'], epwdata['timezone'])", "    # define a day of the year from a date", "    day = int(hr/24)", "    # define the hour", "    hr = hr%24", "    # return vectors at a given day and hour", "    return sg.vec_at(day, hr)", "" ],
          "end" : 50,
          "start" : 40
        },
        "description" : "\nCalculate Solar Vector\nReturns a sun Vec for a given place and hour.\n",
        "end" : 40,
        "start" : 37
      }, {
        "code" : {
          "content" : [ "", "def srf_irradiance(plane,sunvec,epwdata,hourOfYr):", "    # find the angle between our Plane and the sun direction", "    incidence_angle = abs(sunvec.angle(plane))", "    # if the sun is behind our plane: return zero", "    if incidence_angle > math.pi/2 : ", "        srfIrr = 0.0 ", "    # otherwise, calculate the amount of radiation ", "    else : ", "        srfIrr = epwdata['radiation'][hourOfYr] * math.cos(incidence_angle)", "        # return the irradiation value", "    return srfIrr", "" ],
          "end" : 67,
          "start" : 54
        },
        "description" : "\nCalculate Irradiance\nUsing EPW data, calculates the irradiance striking a given oriented Plane at a given hour for a given location.\n",
        "end" : 54,
        "start" : 51
      }, {
        "code" : {
          "content" : [ "", "# parse the EPW data", "epwdata = epw_data(path)", "", "# find the normals for each Mesh face", "normals = [mesh.face_normal(i) for i in range(len(mesh.faces))]", "", "# create a range of hours to evaluate", "hrs = range(int(start_hr),int(end_hr))", "", "# evaluate the hours and get the solar Vecs", "sunvecs = [sun_vec(hr, epwdata) for hr in hrs]", "for normal in normals:", "    # calculate the solar irradiance for a range of hours", "    irr_arr = []", "    for i, sunvec in enumerate(sunvecs):", "        irr_arr.append(srf_irradiance(normal,sunvec,epwdata,hrs[i]))", "    # calculates maximum radiation for a given hr Interval", "    max_irr = max(irr_arr)", "" ],
          "end" : 91,
          "start" : 71
        },
        "description" : "\nMesh Irradiation\nGiven a Mesh, EPW data, a location and a time Interval, calculate solar irradiation on a given Mesh. \n",
        "end" : 71,
        "start" : 68
      }, {
        "code" : {
          "content" : [ "", "# setup minimum and maximum Color values for geometries", "colorA = Color.HSB(0.75) ", "colorB = Color.HSB(0.0) ", "", "# for every index and Vec in Normals:", "for i, normal in enumerate(normals):", "    #Remap the values between 0 and 1", "    val = Interval.remap(vals[i],interval)", "    #Create a new color interpolating between 2 values", "    color = Color.interpolate(colorA,colorB,val)", "    #Create a ray", "    ray = Ray(mesh.face_centroid(i), normal)", "    #Set the color and length of the ray", "    ray.set_color(color)", "    ray.vec.length = val * 5", "", "# setup minimum and maximum Color values for geometries", "colorA = Color.HSB(0.75) ", "colorB = Color.HSB(0.0)", "", "# for every index and face in Mesh faces:", "for i, msh in enumerate(Mesh.explode(mesh)):", "    #Create a new color interpolating between 2 values", "    color = Color.interpolate(colorA,colorB,Interval.remap(vals[i],interval))", "    #Set the color of the mesh", "    msh.set_color(color)" ],
          "end" : 121,
          "start" : 95
        },
        "description" : "\nVisualize Mesh Irradiation\nGiven a Mesh, solar Vecs, and irradiation values, create a Ray for every Vec, and color the Mesh and the Rays according to irradiation. \n",
        "end" : 95,
        "start" : 92
      } ],
      "documentation" : {
        "description" : [ "4.07.L07a", "Methods for calculating solar incident radiation from a given Mesh, a hard-coded position,  and an EPW file that associates date/time with radiation level. Calculates the amount of radiation striking the Plane." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Solar Gain/4.07.L07a.py",
      "name" : "4.07.L07a.py",
      "references" : {
        "classes" : {
          "Color" : 6,
          "Interval" : 2,
          "Mesh" : 1,
          "Ray" : 1,
          "SolarGeom" : 1
        }
      },
      "required" : [ "path (str) File path for EPW file.", "mesh (Mesh) Input mesh for solar calculation.", "start_hr (int) Starting hr for solar calculation.", "end_hr (int) End hr for solar calculation.", "interval (Interval) Interval for remapping the values." ],
      "result" : [ "normal ([Vec]) Normal Vec to the Mesh according to irradiation.", "max_irr ([float]) Maximum irradiation value." ]
    },
    "d7d3185a-e90b-4281-a764-d64fe7df1f0e" : {
      "code" : [ "    vals = string.split(\",\")", "    if isinstance(desired_keys, basestring):", "        return float(vals[epw_keycols[desired_keys]])" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 71,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/parse_epw.py",
      "name" : "_parse_epw_line",
      "start" : 69
    },
    "d8a78ea6-a24e-47da-a957-1810a6e02f63" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "u_val = surf.domain_u.divide(u_div,True)", "v_val = surf.domain_v.divide(v_div,True)", "", "pts = []", "", "#if unrolling in the U direction", "if swap:", "    #traverse in V, storing rows of isocurves in U direction", "    for v in v_val:", "        row = []", "        for u in u_val:", "            row.append(surf.deval(u,v))", "        pts.append(row)", "#if unrolling in the V direction", "else:", "    #traverse in U, storing rows of isocurves in V direction", "    for u in u_val:", "        row = []", "        for v in v_val:", "            row.append(surf.deval(u,v))", "        pts.append(row)", "", "# set the initial position and ray in the plane", "pos = Point()", "init_ray = Ray(Point(),Vec(0,1))", "", "fmsh_out = []", "for i in range(len(pts)-1):    ", "    # flatten strip", "    fpts_a, fpts_b= flat_ptstr(pts[i],pts[i+1],init_ray)", "    # mesh the flattened strip, alternating orientation", "    fmsh = mesh_ptstr(fpts_a,fpts_b, flip = i%2) ", "    trans = Vec(fpts_b[0],pos)", "    xform = Xform.translation(trans)", "    pos = trans", "    # translate into position", "    fmsh_out.append(fmsh*xform)", "" ],
          "end" : 60,
          "start" : 22
        },
        "description" : "\nUnroll Surface\nDecomposes surface into strips which are then flattened in the plane\n",
        "end" : 22,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "flat_components = []", "for n, face in enumerate(mesh.faces):", "    # vertices and edges of the mesh face at index n", "    pts = mesh.face_pts(n)  ", "    edges = [Segment(pts[0], pts[1]), Segment(pts[1], pts[2]), Segment(pts[2], pts[0])]", "    pts_joint = [] #this will contain the points of the triangular face with the notch joints", "    for i, edge in enumerate(edges):", "        pts_joint.append(pts[i])", "        vec = edge.vec.normalized()", "        p0 = edge.eval(pos)", "        p3 = p0 + vec*width", "        vec_perp = vec.cross(Vec(0,0,1)).normalized()", "        p1 = p0+vec_perp*length", "        p2 = p3+vec_perp*length", "        pts_joint.append(p0)", "        pts_joint.append(p1)", "        pts_joint.append(p2)", "        pts_joint.append(p3)", "    pts_joint.append(pts[0])", "    flat_components.append(PLine(pts_joint))", " " ],
          "end" : 84,
          "start" : 64
        },
        "description" : "\nFlat Components with Simple Notch Joint\nThe same definition for the joint is applied to all triangular faces\n",
        "end" : 64,
        "start" : 61
      } ],
      "documentation" : {
        "description" : [ "4.05.L02b", "Flattens a Surface by decomposing into strips along isocurves which are in turn flattened in the plane.", "A simple notch joint can then be applied to the resulting flat mesh faces." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Fabrication/Flatness/4.05.L02b.py",
      "name" : "4.05.L02b.py",
      "references" : {
        "classes" : {
          "PLine" : 1,
          "Point" : 2,
          "Ray" : 1,
          "Segment" : 3,
          "Vec" : 3,
          "Xform" : 1
        }
      },
      "required" : [ "surf (Surface) Surface to be divided and unrolled.", "u_div (int) Number of U divisions.", "v_div (int) Number of V divisions.", "swap (bool) Determines the direction (U or V) of unrolling", "mesh_ptstr (func) Meshing function.", "flat_ptstr (func) Unrolling function." ],
      "result" : [ "fmsh_out ([Mesh]) Flattened surface strips.", "flat_components ([PLines]) Flat components of triangular faces with notch joint applied on each edge" ]
    },
    "d8f11d83-04ef-4e85-8360-f64a47861c12" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "def func(u,v):", "    # Create a point in u and v", "    x = u", "    y = v", "    # The z value of the point is the product of lines", "    z = h*(u + w)*(u - w)*(v + l)*(v - l)", "    return Point(x,y,z)", "   ", "# Setting up the dimensions of the rectangle", "w = 0.5*rec_w", "l = 0.5*rec_l", "h = 0.3", "", "# Make a Surface with the product of lines function", "srf = Surface(func, Interval(-w,w), Interval(-l,l) )" ],
          "end" : 32,
          "start" : 17
        },
        "description" : "\nProduct of Lines Surface\nMethod that generates Points resulting from the product of lines. \n",
        "end" : 17,
        "start" : 14
      } ],
      "documentation" : {
        "description" : [ "4.07.F02a", "Given a width and a length, generate a Surface resulting from the product of lines." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Williams Biot-Savart/4.07.F02a.py",
      "name" : "4.07.F02a.py",
      "references" : {
        "classes" : {
          "Interval" : 2,
          "Point" : 1,
          "Surface" : 1
        }
      },
      "required" : [ "rec_w: rectangle width (float)", "rec_l: rectangle length(float)" ],
      "result" : [ "srf (Surface) Surface created by the product of lines function." ]
    },
    "da0eb7f5-9bda-4573-bfc9-1f04fd936daf" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "pts_a = [Point(1,0),Point(1.5,0.25),Point(2,0),Point(1.5,-0.25)]", "pg_a = PGon(pts_a)", "", "" ],
          "end" : 20,
          "start" : 16
        },
        "description" : "\nThe basic construction of a PGon. \nIf no basis is defined, one is created using the given points.\n",
        "end" : 16,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "pts_b = [Point(-0.5,0),Point(0,0.25),Point(0.5,0),Point(0,-0.25,10)]", "# throws a Geometric Error", "pg_b = PGon(pts)", "", "# creates a PGon by projecting non-conforming Points to CS", "pg_b = PGon(pts_b,cs)", "", "" ],
          "end" : 31,
          "start" : 23
        },
        "description" : "\nOffering a non-planar set of points will return an error, unless a basis is explictly defined.\n",
        "end" : 23,
        "start" : 21
      }, {
        "code" : {
          "content" : [ "#TODO: some methods and properties of a PGon", "pass", "" ],
          "end" : 36,
          "start" : 33
        },
        "description" : "\n",
        "end" : 33,
        "start" : 32
      }, {
        "code" : {
          "content" : [ "res = 20", "dough = PGon.doughnut(pt,Interval(n1, n2),res=res)", "seg = dough.edges[2]", "", "" ],
          "end" : 45,
          "start" : 40
        },
        "description" : "\nThe PGon class offers static methods for easily constructing useful 'stock' polygons.\nHere, a 'doughnut' is constructed, and a single edge is extracted.\n",
        "end" : 40,
        "start" : 37
      }, {
        "code" : {
          "content" : [ "PHI = 0.6126979252", "height = 2.0", "def func(theta):", "    r = PHI**theta", "    z = theta/math.pi/2.0*height", "    return CS().eval_cyl(r,theta*turns,z)", "", "spiral = Curve(func,Interval.twopi(),0.1)", "" ],
          "end" : 58,
          "start" : 49
        },
        "description" : "\nConstructs a golden spiral as a Curve\n[noprint]\n",
        "end" : 49,
        "start" : 46
      }, {
        "code" : {
          "content" : [ "def cs_on_curve(crv,t):", "    pln = crv.eval_pln(t)", "    vec_y = pln.normal.cross(pln.origin).inverted()", "    vec_x = pln.normal.cross(vec_y)", "    return CS(pln.origin,vec_x,vec_y)", "", "cs = cs_on_curve(spiral,t)", "" ],
          "end" : 69,
          "start" : 61
        },
        "description" : "\nGiven a curve and a parameter t, returns a CS oriented to the curve at parameter t such that the x-axis of the resulting CS points away from the world origin.\n",
        "end" : 61,
        "start" : 59
      }, {
        "code" : {
          "content" : [ "pgon_count = 20", "edge_count = 6", "pow = 1.8", "r0,r1 = 0.01,0.25", "", "pgons = []", "for t in Interval().divide(pgon_count,True):", "    t = t**pow", "    cs = cs_on_curve(curve,t)", "    rad_out = Interval(r1,r0*0.25).eval(t**(1/pow))", "    rad_in = Interval(r0,r1*0.25).eval(t**(1/pow))", "    pgon = PGon.doughnut(cs,Interval(rad_out,rad_in),res=edge_count)", "    pgons.append(pgon)", "", "    ", "    " ],
          "end" : 88,
          "start" : 72
        },
        "description" : "\nConstructs a number of PGons, each on a CS oriented to a given Curve.\n",
        "end" : 72,
        "start" : 70
      }, {
        "code" : {
          "content" : [ "for n in range(len(pgons)-1):", "    pgon_a = pgons[n]", "    pgon_b = pgons[n+1]", "    off = len(pgon_a.pts)", "    ", "    msh = Mesh()", "    msh.append(pgon_a.pts)", "    msh.append(pgon_b.pts)", "    ", "    for e in range(off):", "        if e != (off/2)-1:", "            msh.add_face(e,e+1,e+off+1)", "            msh.add_face(e+off+1,e+off,e)", "" ],
          "end" : 104,
          "start" : 91
        },
        "description" : "\nMeshes between edges of sequential PGons\n",
        "end" : 91,
        "start" : 89
      } ],
      "documentation" : {
        "description" : [ "3.08.E00c", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Collection/NOGHX/3.08.E00c.py",
      "name" : "3.08.E00c.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Curve" : 1,
          "Interval" : 6,
          "Mesh" : 1,
          "PGon" : 5,
          "PHI" : 2,
          "Point" : 8
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "dafba134-c885-44c2-81df-9a7b88b9ad94" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/lsystem.py",
      "definitions" : [ {
        "code" : [ "        self.axiom = axiom", "        self.rules = []", "        self.clear()", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 13,
        "name" : "__init__",
        "start" : 10
      }, {
        "code" : [ "        # check on structure of rulething and convert to tuple", "        rule = rulething", "        try:", "            rule.strip()", "            rule = [str.strip() for str in rulething.split(\"->\")]", "        except:", "            try:", "                rule = rulething[0],rulething[1]", "            except:", "                raise TypeError(\"oh snap\")", "        self.rules.append(rule)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 26,
        "name" : "add_rule",
        "start" : 15
      }, {
        "code" : [ "        self.hist = [self.axiom]", "        self.rules = []", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 30,
        "name" : "clear",
        "start" : 28
      }, {
        "code" : [ "    def cur_gen(self): return self.hist[-1]", "            " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 33,
        "name" : "cur_gen",
        "start" : 32
      }, {
        "code" : [ "        # check the rules for the appropriate one to apply", "        for rule in self.rules:", "            if char == rule[0]:", "                return rule[1]", "                break", "        return char", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 41,
        "name" : "apply_rules",
        "start" : 35
      }, {
        "code" : [ "        nxt_gen = \"\"", "        for chr in self.cur_gen: nxt_gen += str(self.apply_rules(chr))", "        self.hist.append(nxt_gen) # add this string to our history", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 46,
        "name" : "step",
        "start" : 43
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 46,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/lsystem.py",
      "name" : "LEngine",
      "references" : {
        "classes" : {
          "LEngine" : 1
        },
        "functions" : {
          "__init__" : 1,
          "add_rule" : 1,
          "apply_rules" : 1,
          "clear" : 1,
          "cur_gen" : 1,
          "step" : 1
        }
      },
      "start" : 8
    },
    "de535338-8e8b-4f6f-b192-ba6e280f5339" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "#nearest neighbors of pt in question; used for discrete approx calcs", "pt_t, pt_plus, pt_minus = nearest_neighbors(crv,t)", "", "#approximation to tangent vector", "vec_t = Vec(pt_plus - pt_minus)", "", "#calculates the curvature at t", "v1 = Vec(pt_plus - pt_t)", "v2 = Vec(pt_minus - pt_t)", "v3 = Vec(pt_plus - pt_minus)", "", "rad_osc = 0.5*v1.length*v2.length*v3.length/(v1*v3).length", "denom = 2*(v1.cross(v3).length)*(v1.cross(v3).length)", "a1 = v3.length*v3.length*v1.dot(v2)/denom", "a2 = v2.length*v2.length*v1.dot(v3)/denom", "a3 = v1.length*v1.length*(-v2.dot(v3))/denom", "center_osc = pt_t*a1 + pt_plus*a2 + pt_minus*a3", "", "#draws Frenet frame (T, N, B) at t ", "vec_T = vec_t.normalized()", "#the direction of vec_N gives a visualization of inflection pts", "vec_N = Vec(center_osc-pt_t).normalized()", "cs_out = CS(pt_t, vec_T, vec_N)" ],
          "end" : 40,
          "start" : 17
        },
        "description" : "\nIllustrates the key geometric objects of Frenet frame\n",
        "end" : 17,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "3.07.E03d", "Use of nearest neighbor calculations to draw Frenet frame." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Geometric Properties/3.07.E03d.py",
      "name" : "3.07.E03d.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Vec" : 5
        }
      },
      "required" : [ "t (float) parameter at which to evaluate", "crv (Curve) a curve to evaluate", "nearest_neighbors (function) a function that returns the nearest neighbor points of a given evaluation parameter" ],
      "result" : [ "pt_out (Point) the point at parameter t", "ln_out (Segment) a line segment representing the curve tangent at the given parameter" ]
    },
    "df061dec-0da7-4633-bb9a-1d8b5d9bac44" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/lsystem.py",
      "definitions" : [ {
        "code" : [ "        self.inst = instructions", "        self.pts = [Point()]", "        self.css = [CS()]", "        self.angle = math.pi/4", "        self.step_size = 1.0", "" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 56,
        "name" : "__init__",
        "start" : 51
      }, {
        "code" : [ "        lines = []", "        while len(self.inst)>0:", "            chr = self.inst[0]", "            # move the turtle based on the current string character", "            if chr == '-': #yaw right", "                self.do_xform(self.css[-1].zAxis,self.angle)", "            elif chr == '+': #yaw left", "                self.do_xform(self.css[-1].zAxis,-self.angle)", "            elif chr == '^': #pitch up", "                self.do_xform(self.css[-1].xAxis,-self.angle)", "            elif chr == '&': #pitch down", "                self.do_xform(self.css[-1].xAxis,self.angle)", "            elif chr == '}': #roll right", "                self.do_xform(self.css[-1].yAxis,self.angle)", "            elif chr == '{': # roll left", "                self.do_xform(self.css[-1].yAxis,-self.angle)", "            elif chr == 'F': # draw line", "                nxt_pt = self.pts[-1] + (self.css[-1].yAxis * self.step_size)", "                lines.append(Segment(self.pts[-1],nxt_pt))", "                self.pts[-1] = nxt_pt", "            elif chr == '[': #push the stack", "                self.push(self.pts[-1], self.css[-1])", "            elif chr == ']': #pop the stack", "                self.pop() ", "            self.inst = self.inst[1:]", "        return lines", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 84,
        "name" : "go",
        "start" : 58
      }, {
        "code" : [ "        xf = Xform.rotation(axis=axis,angle=angle)", "        self.css[-1] = self.css[-1] * xf", "        pass", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 89,
        "name" : "do_xform",
        "start" : 86
      }, {
        "code" : [ "        self.pts.append(pt)", "        self.css.append(cs)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 93,
        "name" : "push",
        "start" : 91
      }, {
        "code" : [ "        self.pts = self.pts[:-1]", "        self.css = self.css[:-1]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 97,
        "name" : "pop",
        "start" : 95
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 97,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/lsystem.py",
      "name" : "LTurtle",
      "references" : {
        "classes" : {
          "CS" : 1,
          "LTurtle" : 1,
          "Point" : 1,
          "Segment" : 1,
          "Xform" : 1
        },
        "functions" : {
          "__init__" : 1,
          "do_xform" : 1,
          "go" : 1,
          "pop" : 1,
          "push" : 1
        }
      },
      "start" : 49
    },
    "e097a83a-090f-4859-945b-20974462fd4f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def eval_line(t):", "    x = x0*t**n", "    y = y0*t**n", "    return Point(x,y)", "", "ival = Interval(0,1) ", "tol = ival.delta/pt_count", "line_out = Curve(eval_line,ival,tol)", "", "pts = []", "for t in ival.divide(pt_count, include_last = True): ", "    pts.append(eval_line(t))", "", "" ],
          "end" : 32,
          "start" : 18
        },
        "description" : "\nA whole family of parametrizations for the line\n",
        "end" : 18,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "", "def eval_normal(t):", "    x = cos(t)", "    y = sin(t)", "    return Point(x,y)", "", "ival = Interval(0,2*pi) ", "tol = ival.delta/pt_count", "cir_normal = Curve(eval_normal,ival,tol)", "", "pts = []", "for t in ival/pt_count: ", "    pts.append(eval_normal(t))", "" ],
          "end" : 49,
          "start" : 35
        },
        "description" : "\nThe \"normal\" parameterization of a circle\n",
        "end" : 35,
        "start" : 33
      }, {
        "code" : {
          "content" : [ "def eval_goofy(t):", "    x = (1 - t**2)/(1 + t**2)", "    y = 2*t/(1+t**2)", "    return Point(x,y)", "", "large_number = 50", "ival = Interval(-large_number,large_number) ", "tol = ival.delta/pt_count", "cir_goofy = Curve(eval_goofy,ival,tol)", "pts = []", "for t in ival.divide(pt_count, include_last = True): ", "    pts.append(eval_goofy(t))" ],
          "end" : 63,
          "start" : 52
        },
        "description" : "\nThe \"goofy\" parameterization of a circle\n",
        "end" : 52,
        "start" : 50
      } ],
      "documentation" : {
        "description" : [ "3.07.E01c", "Parametrizations are not unique.  Here we look at a whole family of parametrizations for a line", "and two parametrizations of a circle, and see the", "resulting points on the curve associated to an even division of the t-interval" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Curve/Curve Basics/3.07.E01c.py",
      "name" : "3.07.E01c.py",
      "references" : {
        "classes" : {
          "Curve" : 3,
          "Interval" : 3,
          "Point" : 3
        }
      },
      "required" : [ "pt_count (int) - the number of points shown along the curve" ],
      "result" : [ "a Decodes curve defined by each function on an interval with a tolerance defined by pt_count", "a set of points along the curve corresponding to equally spaced parameter values in the domain interval" ]
    },
    "e1f99e2e-c7af-4651-9af2-e987b1a59a44" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "vec_a = Vec(pt_a,pt_b)", "vec_b = Vec(0,1,1)", "print vec_b", "" ],
          "end" : 19,
          "start" : 15
        },
        "description" : "\nVector construction \n",
        "end" : 15,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "pt_c = Point(2,3)", "pt_d = pt_c + vec_b", "print pt_d" ],
          "end" : 24,
          "start" : 22
        },
        "description" : "\nPoint-vector interaction\n",
        "end" : 22,
        "start" : 20
      } ],
      "documentation" : {
        "description" : [ "2.01.E01c", "Vectors, like points, carry x,y, and z coordinate information, but in the case of vectors this information is interpreted not as a position in space, but rather as a direction and a magnitude relative an origin at (0,0,0)." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E01 - Amuse-Bouche/2.01.E01c.py",
      "name" : "2.01.E01c.py",
      "references" : {
        "classes" : {
          "Point" : 1,
          "Vec" : 2
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "e35e04c0-65ce-47b6-8804-0d8c236f3f4b" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "for n, pt in enumerate(pts):", "    print \"point at index \",n,\" is \",pt", "    ", "   " ],
          "end" : 18,
          "start" : 14
        },
        "description" : "\n",
        "end" : 14,
        "start" : 13
      }, {
        "code" : {
          "content" : [ "a_list = [item_a,item_b,item_c]", "", "a_tuple = (item_a,item_b,item_c)", "", "a_dict = {'pt_a': Point(), 'pt_b': Point(1,0), 'pt_c': Point(0,1)}", "", "" ],
          "end" : 27,
          "start" : 20
        },
        "description" : "\n",
        "end" : 20,
        "start" : 19
      }, {
        "code" : {
          "content" : [ "char_list = ['a','b','c']", "char_list.append('d')", "print char_list", "", "char_list.extend(['e','f'])", "print char_list", "", "char_list.insert(3,Point())", "print char_list", "", "" ],
          "end" : 40,
          "start" : 29
        },
        "description" : "\n",
        "end" : 29,
        "start" : 28
      }, {
        "code" : {
          "content" : [ "char_list = ['a','b','c']", "print char_list.pop()", "print char_list", "", "" ],
          "end" : 47,
          "start" : 42
        },
        "description" : "\n",
        "end" : 42,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "ival = Interval(0,math.pi)", "some_pts = [Point(t,math.sin(t)) for t in ival/cnt]", "", "" ],
          "end" : 52,
          "start" : 49
        },
        "description" : "\n",
        "end" : 49,
        "start" : 48
      } ],
      "documentation" : {
        "description" : [ "2.03.E00c", "This file is not downloadable, and is only to be used to generate marked-up code" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/03-Collections/2.03.E00 - NOGHX/2.03.E00c.py",
      "name" : "2.03.E00c.py",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "Point" : 5
        }
      },
      "required" : [ "None" ],
      "result" : [ "None" ]
    },
    "e4464099-33e3-4b70-92e1-a3415e740798" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "# initialize lists of cells separating  circles and stars", "circs = []", "stars = []", "", "# for each x and y index:", "for yi in range(2*res):", "    for xi in range(res):", "        # find the x-coordinate for the center of this cell ", "        if yi%2 ==0: x = 4*xi", "        # offsetting the x-position for every other line.", "        else: x = 4*xi+2", "        y = 2*yi", "        ", "        # calculate a number based on distance to a Point", "        val = math.floor(att_point.distance(Point(x,y))*4/10) #int between 0-11", "        # use this number to create a rotated CS", "        ang = math.radians(11.25*val) #times 11.25 degrees for stepped rotation", "        cs = CS.on_xy(x,y,rot=ang)", "        # construct a \"circle\" Cell based upon this CS", "        circs.append(Cell(cs))", "        # construct a \"star\" Cell based upon the next CS ", "        stars.append(Cell(CS(x+2,y,0),is_star=True))", "        ", "" ],
          "end" : 44,
          "start" : 19
        },
        "description" : "\nCreate Cells Routine\nCreates cells by walking a two-dimensional grid, constructing Cells at each step\n[pseudo]\n",
        "end" : 19,
        "start" : 15
      }, {
        "code" : {
          "content" : [ "ret = [] # an empty list for storing heterogeneous geometric results", "", "# For each star, switch between square lines or arc lines depending upon their proximity to the attractor point. ", "# Note that the method shown here assumes that the cells are sized to 1.0 units, and will break if this is not the case.", "", "for s in stars:", "    if s.basis.origin.distance(att_point) > res*3: ret.append(s.arc_lines)", "    else: ret.append(s.square_lines)", "", "#Construct resulting geometry for the \"circle\" cells.", "ret.extend([c.arc_lines for c in circs])" ],
          "end" : 58,
          "start" : 48
        },
        "description" : "\nConstructs the resulting geometry using the Cells we've just created, starting with the \"star\" cells.\n[noprint]\n",
        "end" : 48,
        "start" : 45
      } ],
      "documentation" : {
        "description" : [ "4.01.F02b", "Cell Aggregation" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Aggregation/Neil Katz Tiling/4.01.F02b.py",
      "name" : "4.01.F02b.py",
      "references" : {
        "classes" : {
          "CS" : 2,
          "Cell" : 2,
          "Point" : 1
        }
      },
      "required" : [ "Cell (Class) A Class that provides methods for positioning, manipulating, and creating various styles of geometry for a star cell and a circle cell.", "res (int) The number of Cells along one side of our square array.", "att_point (Point) An \"attractor\" Point that determines both the line style (Arcs or Polylines) as well as the rotation of each circle Cell." ],
      "result" : [ "ret ([Arc] or [PLine]) A heterogeneous list that may include Polylines and/or Arcs." ]
    },
    "e773874a-37a4-4b36-9f72-ba5a9774df3a" : {
      "code" : [ "        \"\"\"Places sorted lengths into Strips.", "            :param lengths  : material lengths to be placed", "            :type lengths   : list of float ", "            :returns        : Bins with the polygons within them", "            :rtype          : list of Bins", "        \"\"\"", "", "        # initialize", "        strips = [Strip(stock_size.a,stock_size.b)]", "        no_strips = 1", "", "        for i, r in enumerate(lengths):", "            flag = False", "            for j, s in enumerate(strips):", "                test_strip = s.can_fit(r)", "                if test_strip <> None:", "                    test_strip.put_item(r)", "                    print \"packing into strip \",j", "                    flag = True", "                    break", "            # if we get here we have not placed the rectangle", "            # so we need to add a new one", "            if not flag:", "                strips.append(Strip(no_strips*stock_size.a, stock_size.b))", "                no_strips += 1", "                strips[no_strips-1].put_item(r)", "                print \"adding strip \", no_strips-1", "", "        return strips", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "Places sorted lengths into Strips." ],
        "rtype" : "list of Bins"
      },
      "end" : 86,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/packing.py",
      "name" : "bin_strips",
      "start" : 57
    },
    "e8aa7b01-9c30-4876-b15f-742e84ceab61" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "", "for pt in pts: ", "    # first, create a vector from 'pt' to the attractor point", "    vec = Vec(pt,attr_pt)", "    ", "    # next, calculate the distance to move 'pt'", "    dist = min(vec.length*max_dist,vec.length**power)", "    ", "    # create a new point in the desired position", "    new_pt = pt + vec.normalized(dist)", "    ", "    # put this new point in our outie", "    outie.put(new_pt)" ],
          "end" : 29,
          "start" : 17
        },
        "description" : "\nIterate through each given point using a loop, applying the attractor routine to each point in succession.\n",
        "end" : 17,
        "start" : 15
      } ],
      "documentation" : {
        "description" : [ "2.01.E02a", "Pulls a set of points toward an attractor point." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/01-Elements/2.01.E02 - Attractors/2.01.E02a.py",
      "name" : "2.01.E02a.py",
      "references" : {
        "classes" : {
          "Vec" : 1
        }
      },
      "required" : [ "pts [Point]A list of points to displace.", "attr_pt Point An \"attractor\" point that influences a given list of points.", "power float The strength of the attraction, described as the exponent number to raise the distance between a given point and the attractor point. For example, a power value of 0.5 will apply a square root function to the measured distance, while a power value of 3.0 will raise the measured distance to the power of three.", "max_dist float The maximum distance that any point may move." ],
      "result" : [ "outie   An outie containing a list of points that have been moved" ]
    },
    "eb99293a-b490-407a-85af-6c8c09a0bbbe" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def grid_pgon(pgon):", "    pt_lst = []", "    grid_spacing = 4", "    space_factor = 4", "    # find the circle in which the PGon bounds are inscribed", "    largest_circle = math.sqrt(pgon.bounds.dim_x**2+pgon.bounds.dim_y**2)/2", "    # for every step outward from the center of the circle:", "    for x in range(1,int(math.ceil(largest_circle)), grid_spacing):", "        # for every step along the edge of the circle:", "        for y in Interval(0,2*math.pi).divide(x*space_factor):", "            # create a Point at that location", "            pt = Point( x * math.cos(y), x * math.sin(y), 0) + pgon.centroid", "            # if that Point is within the PGon bounds", "            if pt in pgon:", "                # add it to the Point list", "                pt_lst.append(pt)", "    return pt_lst", "    ", "    " ],
          "end" : 40,
          "start" : 21
        },
        "description" : "\nGrid Polygon\nA function that creates radial grids on PGons\n",
        "end" : 21,
        "start" : 18
      }, {
        "code" : {
          "content" : [ "def make_arc(pts):", "    min_radius = 2", "    min_segment = 2", "    ", "    # create a Segment from the center Point to one end Point", "    seg1 = Segment(pts[1],pts[0])", "    # create a Segment from the center Point to the end Point", "    seg2 = Segment(pts[1],pts[2])", "", "    # distance from joint to the closest Point on Segments", "    ja_tan_sp1 = seg1.eval((min_radius / math.tan(angle/2))/seg1.length)", "    ja_tan_sp2 = seg2.eval((min_radius / math.tan(angle/2))/seg2.length)", "    ", "    # distance from joint to the farthest Point on Segments ", "    ja_tan_ep1 = seg1.eval(((seg1.length-min_segment)/2)/seg1.length)", "    ja_tan_ep2 = seg2.eval(((seg2.length-min_segment)/2)/seg2.length)", "    ", "    seg1 = Segment(ja_tan_sp1, ja_tan_ep1)", "    seg2 = Segment(ja_tan_sp2, ja_tan_ep2)", "    # make an Arc from the evaluated Points, and a Vec", "    return Arc.from_tan(seg1.eval(slide),seg2.eval(slide), Vec(pts[0],pts[1]))", "" ],
          "end" : 66,
          "start" : 44
        },
        "description" : "\nArc from Points\nA function to make arcs from points\n",
        "end" : 44,
        "start" : 41
      }, {
        "code" : {
          "content" : [ "def arc_pts(pts, pgon):", "    resolution = 10", "    # create the first arc", "    arc = make_arc(pts)", "    # get the center Point on the Arc", "    cp = arc.eval(.5)", "    # for a set amount of tries:", "    for j in Interval().divide(resolution):", "        # if the Arc center Point is not in the PGon:", "        if not cp in pgon:", "            # create an Intersector", "            xsor = Intersector()", "            # if the arc lies outside the PGon:", "            if xsor.of(arc, Plane(pgon.basis.origin, pgon.basis.z_axis)):", "                if not xsor.results[0] in pgon:", "                    # move it closer to the PGon edge", "                    pts[1]+=Vec(xsor.results[0], pgon.near_pt(xsor.results[0]))", "            # create a new Arc", "            arc = make_arc(pts)", "            # and create a new Point to test", "            cp = arc.eval(.5)", "        # if the Arc center point is in the PGon bounds:", "        else:", "            # keep the Arc where it is", "            break", "    # return the moved Point", "    return pts[1]", "" ],
          "end" : 98,
          "start" : 70
        },
        "description" : " \nArc Points\nA function that returns arcs from evaluated points along segments\n",
        "end" : 70,
        "start" : 67
      }, {
        "code" : {
          "content" : [ "pgpt_lst, near_lst, arc_lst, final_lst = [],[],[],[]", "# for every PGon in the given list", "for i in range(len(pg_lst)):", "    # if it is the first or last PGon:", "    if i == 0 or i == len(pg_lst):", "        # append its centroid to the list of Points", "        pgpt_lst.append([pg_lst[i].centroid])", "    # else:", "    else:", "        # append a grid of Points to the list of Points", "        pgpt_lst.append(grid_pgon(pg_lst[i]))", "        ", "# create a Graph", "graph = Graph()", "# for every PGon in the given list excluding the last:", "for i in range(len(pgpt_lst)-1):", "    # for every Point in the corresponding Point grid:", "    for j in range(len(pgpt_lst[i])):", "        # make a key from a Point PGon index and Point index", "        node = str(i)+ \",\" + str(j)", "        # and add a node to the graph", "        graph.add_node(node)", "        # for every Point in the next Point grid:", "        for k in range(len(pgpt_lst[i+1])):", "            # find the key for the point in this and the next Point grid", "            key1 = str(i) + \",\" + str(j)", "            key2 = str(i+1) + \",\" + str(k)", "            # find the distance between the two Points and add an edge", "            dist = pgpt_lst[i][j].distance(pgpt_lst[i+1][k])", "            graph.add_edge(key1,key2,dist)", "", "# find the key for the point to reach", "last = str(len(pg_lst)-1) + \",\" + str(0)", "# create a list of the keys on the shortest path", "sp_lst = shortest_path(graph,\"0,0\",last)", "", "# for every key in the list of keys", "for sp in sp_lst:", "    # if it is the first key:", "    if sp == 0:", "        # append the starting Point to the list of Points", "        near_lst.append(pgpt_lst[0][0])", "    # if it is not the first key", "    if sp != 0:", "        # get the PGon and Point number from the key", "        pg_num = int(sp.split(\",\")[0])", "        pt_num = int(sp.split(\",\")[1])", "        # add the Point to the shortest path list", "        near_lst.append(pgpt_lst[pg_num][pt_num])", "", "# create a list of Points for Arcs", "mod_pt_lst = [near_lst[0]]", "# for every Point in near_lst excluding first and last:", "for i in range(1,len(near_lst)-1):", "    # get the angle at the joint", "    angle = Vec(near_lst[i],near_lst[i-1]).angle(Vec(near_lst[i],near_lst[i+1]))", "    # if the angle is not straight:", "    if not angle < 0.0001:", "        # get a moved Point for arc creation", "        pts1 = [near_lst[i-1], near_lst[i], near_lst[i+1]]", "        mod_pt_lst.append(arc_pts(pts1, pg_lst[i]))", "# add the last Point to the list", "mod_pt_lst.append(near_lst[-1])", "", "# for every point in the moved Point list:", "for i in range(1, len(mod_pt_lst)-1):", "    # create an Arc", "    arc_lst.append(make_arc([mod_pt_lst[i-1], mod_pt_lst[i], mod_pt_lst[i+1]]))", "", "# add the first Segment to the final path list", "final_lst.append(Segment(near_lst[0],arc_lst[0].spt))", "# for every arc in the Arc list excluding the last:", "for i in range(len(arc_lst)-1):", "    # append the Arc and Segment to the relevant lists", "    final_lst.append(arc_lst[i])", "    final_lst.append(Segment(arc_lst[i].ept,arc_lst[i+1].spt))", "# append the final Arc and Segment", "final_lst.append(arc_lst[-1])", "final_lst.append(Segment(arc_lst[-1].ept,near_lst[-1]))", "", "" ],
          "end" : 183,
          "start" : 103
        },
        "description" : "\nCurve Decomposition with Volume Constraint\nFinds a \"best\" curve within contour polygons using straight lines and arcs\n[pseudo]\n",
        "end" : 103,
        "start" : 99
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Martin Zahner/4.03.F03b.py",
      "name" : "4.03.F03b.py",
      "references" : {
        "classes" : {
          "Arc" : 1,
          "Graph" : 1,
          "Intersector" : 1,
          "Interval" : 2,
          "Plane" : 1,
          "Point" : 1,
          "Segment" : 7,
          "Vec" : 4
        }
      }
    },
    "ebcbe674-9f2f-49f2-a3ca-78ae331d057c" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_bounds.py",
      "definitions" : [ {
        "code" : [ "        \"\"\" QuadTree constructor.", "        ", "            :param capacity: Total number of points to contain.", "            :type capacity: int", "            :param bounds: Bounds.", "            :type bounds: Bounds", "            :result: QuadTree object.", "            :rtype: QuadTree", "        ", "        \"\"\"", "    ", "        self.cap = capacity", "        self.bnd = bounds", "        self._pts = []", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "QuadTree constructor." ],
          "parameters" : {
            "bounds" : "Bounds.\n",
            "capacity" : "Total number of points to contain.\n"
          },
          "rtype" : "QuadTree",
          "rvalue" : "QuadTree object.\n",
          "types" : {
            "bounds" : "Bounds\n",
            "capacity" : "int\n"
          }
        },
        "end" : 376,
        "name" : "__init__",
        "start" : 362
      }, {
        "code" : [ "    def has_children(self):", "        \"\"\" Returns True if QuadTree has children.", "        ", "            :result: Boolean value.", "            :rtype: bool", "        ", "        \"\"\"", "    ", "        if hasattr(self,'children'):return True ", "        return False", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns True if QuadTree has children." ],
          "rtype" : "bool",
          "rvalue" : "Boolean value.\n"
        },
        "end" : 388,
        "name" : "has_children",
        "start" : 378
      }, {
        "code" : [ "    def pts(self):", "        \"\"\" Recursively returns all the points in this QuadTree.", "        ", "            :result: List of Points.", "            :rtype: [Point]", "        \"\"\"", "        ret_pts = []", "        if not self.has_children :", "            ret_pts = list(self._pts)", "        else :", "            for child in self.children: ret_pts.extend(child.pts)", "        return ret_pts", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Recursively returns all the points in this QuadTree." ],
          "rtype" : "[Point]",
          "rvalue" : "List of Points.\n"
        },
        "end" : 402,
        "name" : "pts",
        "start" : 390
      }, {
        "code" : [ "        \"\"\" Appends the given point to the points in this QuadTree.", "        ", "            :param pt: Point", "            :type pt: Point", "            :result: Boolean Value", "            :rtype: bool", "        ", "        \"\"\"", "    ", "        if not self.contains(pt) : return False", "        if not self.has_children :", "            if len(Point.cull_duplicates(self._pts)) < self.cap:", "                self._pts.append(pt)", "                return True", "            else :", "                self._divide()", "        ", "        if self.has_children :", "            for child in self.children:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Appends the given point to the points in this QuadTree." ],
          "parameters" : {
            "pt" : "Point\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 422,
        "name" : "append",
        "start" : 404
      }, {
        "code" : [ "        \"\"\" Divides self into sub regions. Starts at bottom left and moves clockwise.", "        ", "            :result: Boolean Value", "            :rtype: bool", "        \"\"\"", "        if self.has_children: return False", "        ", "        if equalize_bounds: ", "            sub_bnds = self.bnd.subbounds(1,equalize=True)", "        else:", "            sub_bnds = self.bnd//2", "            ", "        self.children = [QuadTree(self.cap,sub_bnd) for sub_bnd in sub_bnds]", "        for child in self.children: child.parent = self", "        ", "        for pt in self._pts : ", "            accepted = False", "            for child in self.children:", "                if child.append(pt) : ", "                    accepted = True", "                    break", "            if not accepted : \"no child accepted this point!\"", "            ", "        self._pts = None", "        return True", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Divides self into sub regions. Starts at bottom left and moves clockwise." ],
          "rtype" : "bool",
          "rvalue" : "Boolean Value\n"
        },
        "end" : 454,
        "name" : "_divide",
        "start" : 429
      }, {
        "code" : [ "        \"\"\" Returns true if given point is in this QuadTree.", "        ", "            :param pt: Point to test for containment.", "            :type pt: Point", "            :result: Boolean Value.", "            :rtype: bool", "            ", "        \"\"\"", "        if self.has_children:", "            return any([child.contains(pt) for child in self.children])" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns true if given point is in this QuadTree." ],
          "parameters" : {
            "pt" : "Point to test for containment.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean Value.\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 465,
        "name" : "contains",
        "start" : 456
      }, {
        "code" : [ "        \"\"\" Finds all points that fall within a given bounds.", "        ", "            :param bounds: bounds", "            :type bounds: Bounds", "            :result: List of Points in Bounds.", "            :rtype: [Point]", "            ", "        \"\"\"", "        if not self.bnd.overlaps(bounds) : return []", "        ret_pts = []", "        if not self.has_children :", "            for pt in self._pts :", "                if pt in bounds :  ret_pts.append(pt)", "        else :", "            for child in self.children: ret_pts.extend(child.pts_in_bounds(bounds))", "        return ret_pts", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Finds all points that fall within a given bounds." ],
          "parameters" : {
            "bounds" : "bounds\n"
          },
          "rtype" : "[Point]",
          "rvalue" : "List of Points in Bounds.\n",
          "types" : {
            "bounds" : "Bounds\n"
          }
        },
        "end" : 486,
        "name" : "pts_in_bounds",
        "start" : 470
      }, {
        "code" : [ "        if self.has_children:", "            ret = []" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 490,
        "name" : "flatten",
        "start" : 489
      }, {
        "code" : [ "        if not pt in self.bnd: raise Exception(\"point does not lie within the bounds of this QTree\")", "        if not self.has_children: return self", "        for child in self.children:", "            if pt in child.bnd: return child.container_of(pt)", "            " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 502,
        "name" : "container_of",
        "start" : 498
      }, {
        "code" : [ "        return self.container_of(pt).pts", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 506,
        "name" : "pts_neighboring",
        "start" : 505
      }, {
        "code" : [ "        container = self.container_of(pt)", "        bnd = container.bnd.scaled(1.10)", "        others = self.flatten()", "        ret = []", "        for other in others:", "            if other.bnd.overlaps(bnd): ret.append(other)", "        return ret", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 515,
        "name" : "containers_neighboring",
        "start" : 508
      }, {
        "code" : [ "        if not src_pt in self.bnd : src_pt = self.bnd.near_pt(src_pt)", "        container = self.container_of(src_pt)", "        #a.put(container.bnd.to_pline())", "        near_pts = container.pts", "        ", "        proj_pts = [Point(container.bnd.ival_x.a,src_pt.y,src_pt.z), Point(container.bnd.ival_x.b,src_pt.y,src_pt.z),Point(src_pt.x,container.bnd.ival_y.a,src_pt.z), Point(src_pt.x,container.bnd.ival_y.b,src_pt.z)]", "        if container.bnd.is_3d: proj_pts.extend([Point(src_pt.x,src_pt.y,container.bnd.ival_z.a), Point(src_pt.x,src_pt.y,container.bnd.ival_z.b)])", "        for edge in container.bnd.edges: proj_pts.append(edge.near_pt(src_pt))", "        ", "        for p in proj_pts:", "            p += Vec(src_pt,p)*EPSILON", "            #a.put(Segment(src_pt,p))", "            try:", "                adj_container = self.container_of(p)", "                a.put(adj_container.bnd.to_pline())", "                for adj_pt in adj_container.pts:", "                    if adj_pt not in near_pts: near_pts.append(adj_pt)", "            except:", "                # no adjacent container", "                pass", "        near_pts.sort(key = lambda p: p.distance2(src_pt))", "        return near_pts", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 539,
        "name" : "pts_nearby",
        "start" : 517
      }, {
        "code" : [ "    def encompass(capacity = 4, pts = [Point()]):", "        \"\"\" Returns a QuadTree that encompasses the given points.", "        ", "            :param capacity: Capacity of points within the Bounds.", "            :type capacity: int", "            :param pts: List of Points.", "            :type pts: [Point]", "            :result: QuadTree encompassing the given points.", "            :rtype: QuadTree", "        ", "        \"\"\"", "    ", "        q = QuadTree(capacity, Bounds.encompass(pts))", "        q._divide(equalize_bounds=True)", "        for p in pts : q.append(p)", "        return q", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a QuadTree that encompasses the given points." ],
          "parameters" : {
            "capacity" : "Capacity of points within the Bounds.\n",
            "pts" : "List of Points.\n"
          },
          "rtype" : "QuadTree",
          "rvalue" : "QuadTree encompassing the given points.\n",
          "types" : {
            "capacity" : "int\n",
            "pts" : "[Point]\n"
          }
        },
        "end" : 558,
        "name" : "encompass",
        "start" : 542
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 558,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_bounds.py",
      "name" : "QuadTree",
      "references" : {
        "classes" : {
          "Bounds" : 1,
          "EPSILON" : 1,
          "Point" : 8,
          "QuadTree" : 3,
          "Vec" : 1
        },
        "functions" : {
          "__init__" : 1,
          "_divide" : 1,
          "append" : 1,
          "container_of" : 1,
          "containers_neighboring" : 1,
          "contains" : 1,
          "encompass" : 1,
          "flatten" : 1,
          "has_children" : 1,
          "pts" : 1,
          "pts_in_bounds" : 1,
          "pts_nearby" : 1,
          "pts_neighboring" : 1
        }
      },
      "start" : 361
    },
    "eddadb34-dd01-43e8-a39d-1a44a426a099" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# initialize a single instance of the Guy class", "debord = Guy(start_pt,start_vel)", "path_pts = []", "", "" ],
          "end" : 24,
          "start" : 19
        },
        "description" : "\n[noprint]\n",
        "end" : 19,
        "start" : 17
      }, {
        "code" : {
          "content" : [ "# for every time step:", "for n in range(count):", "    # find the vector nearest to the Guy", "    fvec = vf.vec_near(debord.pos)    ", "    # steer the guy", "    debord.steer(fvec)", "    debord.step()   ", "    path_pts.append(debord.pos)", "", "path_line = PLine(path_pts)", "" ],
          "end" : 38,
          "start" : 28
        },
        "description" : "\nVector Field Routine\nCreates a guy and lets it wander while under the influence of a vector field\n",
        "end" : 28,
        "start" : 25
      } ],
      "documentation" : {
        "description" : [ "4.02.L04d", "Have guy respond to a vector field" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Walkers/4.02.L04d.py",
      "name" : "4.02.L04d.py",
      "references" : {
        "classes" : {
          "Guy" : 1,
          "PLine" : 1
        }
      },
      "required" : [ "Guy (class) A class of walker", "start_pt (Point) Initial point of the wandering Guy", "start_vel (Vec) Initial velocity of the the wandering Guy", "count (int) Amount of time for Guy to wander", "vf (VecField) A vector field for guy to wander in" ],
      "result" : [ "path_pts (list of Points) Guy's locations", "path_line (PLine) Guy's path" ]
    },
    "ef013d53-a664-4652-8633-45fdf8c22880" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_line.py",
      "definitions" : [ {
        "code" : [ "    def __div__(self, divs): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 400,
        "name" : "__truediv__",
        "start" : 400
      }, {
        "code" : [ "        \"\"\" Overloads the division **(/)** operator. Calls Segment.divide(divs).", "        ", "           :param divs: Number of divisions.", "           :type divs: int        ", "           :result: List of Points equally spaced along this Segment", "           :rtype: list", "        \"\"\"", "        return self.divide(divs)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the division **(/)** operator. Calls Segment.divide(divs)." ],
          "parameters" : {
            "divs" : "Number of divisions.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of Points equally spaced along this Segment\n",
          "types" : {
            "divs" : "int        \n"
          }
        },
        "end" : 409,
        "name" : "__div__",
        "start" : 401
      }, {
        "code" : [ "        \"\"\" Overloads the integer division **(//)** operator. Calls Segment.subinterval(divs).", "            ", "            :param divs: Number of subsegments.", "            :type divs: int", "            :result: List of smaller Segments. ", "            :rtype: list", "            ", "        \"\"\"", "        return self.subsegment(divs)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the integer division **(//)** operator. Calls Segment.subinterval(divs)." ],
          "parameters" : {
            "divs" : "Number of subsegments.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of smaller Segments. \n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 420,
        "name" : "__floordiv__",
        "start" : 411
      }, {
        "code" : [ "       " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 423,
        "name" : "__repr__",
        "start" : 423
      }, {
        "code" : [ "    def ept(self): ", "        \"\"\" Returns the end Point of a LinearEntity.", "", "            :result: End Point.", "            :rtype: Point", "        \"\"\"", "        return self._pt+self._vec", "    @ept.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the end Point of a LinearEntity." ],
          "rtype" : "Point",
          "rvalue" : "End Point.\n"
        },
        "end" : 432,
        "name" : "ept",
        "start" : 425
      }, {
        "code" : [ "    def ept(self, point): ", "        \"\"\" Sets the end Point of a LinearEntity.", "", "            :param point: End Point.", "            :type point: Point", "            :result: End Point.", "            :rtype: None", "        \"\"\"", "        self._vec = point-self._pt    ", "    " ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the end Point of a LinearEntity." ],
          "parameters" : {
            "point" : "End Point.\n"
          },
          "rtype" : "None",
          "rvalue" : "End Point.\n",
          "types" : {
            "point" : "Point\n"
          }
        },
        "end" : 442,
        "name" : "ept",
        "start" : 433
      }, {
        "code" : [ "    def length(self): ", "      \"\"\" Returns the length of this segment.", "            ", "            :result: Length of line segment.", "            :rtype: float", "      ", "      \"\"\"", "      return self.vec.length        ", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the length of this segment." ],
          "rtype" : "float",
          "rvalue" : "Length of line segment.\n"
        },
        "end" : 452,
        "name" : "length",
        "start" : 444
      }, {
        "code" : [ "    def midpoint(self): ", "      \"\"\" Returns the midpoint of this segment", "      ", "            :result: Midpoint of Segment.", "            :rtype: Point", "      ", "      \"\"\"", "      return Point.interpolate(self.spt, self.ept)", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the midpoint of this segment" ],
          "rtype" : "Point",
          "rvalue" : "Midpoint of Segment.\n"
        },
        "end" : 462,
        "name" : "midpoint",
        "start" : 454
      }, {
        "code" : [ "    def pts(self): ", "      \"\"\" Returns the start and end points of this Segment.", "            ", "            :result: The start and end Points of this Segment.", "            :rtype: [Point]", "      ", "      \"\"\"", "      return self.spt, self.ept", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the start and end points of this Segment." ],
          "rtype" : "[Point]",
          "rvalue" : "The start and end Points of this Segment.\n"
        },
        "end" : 472,
        "name" : "pts",
        "start" : 464
      }, {
        "code" : [ "        \"\"\" Returns True if the given Segment shares termination Points and direction with this Segment", "        ", "            :param other: Segment to be compared.", "            :type other: Segment", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param vec_tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type vec_tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_seg.is_equal(other_seg)", "        \"\"\"", "        return self.spt.is_equal(other.spt,pt_tol) and self.vec.is_equal(other.vec,vec_tol)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Segment shares termination Points and direction with this Segment" ],
          "parameters" : {
            "other" : "Segment to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n",
            "vec_tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Segment\n",
            "pos_tol" : "float               \n",
            "vec_tol" : "float\n"
          }
        },
        "end" : 491,
        "name" : "is_equal",
        "start" : 475
      }, {
        "code" : [ "        \"\"\" Returns True if the given Segment shares termination Points but not necessarily direction with this Segment", "        ", "            :param other: Segment to be compared.", "            :type other: Segment             ", "            :param tol: Tolerance of point difference that does not correspond to an actual distance, but is treated as a separate numeric delta for x, y, and z coordinates.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_seg.is_equal(other_seg)", "        \"\"\"", "        if self.spt.is_equal(other.spt,tol) and self.ept.is_equal(other.ept,tol): return True", "        if self.spt.is_equal(other.ept,tol) and self.ept.is_equal(other.spt,tol): return True", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Segment shares termination Points but not necessarily direction with this Segment" ],
          "parameters" : {
            "other" : "Segment to be compared.\n",
            "tol" : "Tolerance of point difference that does not correspond to an actual distance, but is treated as a separate numeric delta for x, y, and z coordinates.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Segment             \n",
            "tol" : "float\n"
          }
        },
        "end" : 509,
        "name" : "is_coincident",
        "start" : 493
      }, {
        "code" : [ "        \"\"\" Returns True if the given Segment shares any Points along its length with this Segment", "        ", "            :param other: Segment to be compared.", "            :type other: Segment             ", "            :param tol: Tolerance of point projection.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_seg.is_overlapping(other_seg)", "        \"\"\"", "        if not self.is_collinear(other): return False", "        if self.contains(other.spt) or self.contains(other.ept): return True", "        if other.is_encompassing(self): return True", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Segment shares any Points along its length with this Segment" ],
          "parameters" : {
            "other" : "Segment to be compared.\n",
            "tol" : "Tolerance of point projection.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Segment             \n",
            "tol" : "float\n"
          }
        },
        "end" : 529,
        "name" : "is_overlapping",
        "start" : 512
      }, {
        "code" : [ "        \"\"\" Returns True if the given Segment shares all the Points along its length with this Segment", "        ", "            :param other: Segment to be compared.", "            :type other: Segment             ", "            :param tol: Tolerance of point projection.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_seg.is_encompassing(other_seg)", "        \"\"\"", "        return self.contains(other.spt) and self.contains(other.ept)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Segment shares all the Points along its length with this Segment" ],
          "parameters" : {
            "other" : "Segment to be compared.\n",
            "tol" : "Tolerance of point projection.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Segment             \n",
            "tol" : "float\n"
          }
        },
        "end" : 545,
        "name" : "is_encompassing",
        "start" : 531
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given line segment, its t value and the distance from the Point to the near Point.", "       ", "            :param p: Point to look for a near Point on the Segment.", "            :type p: Point", "            :result: Tuple of near point on Segment, t value and distance from point to near point.", "            :rtype: (Point, float, float)", "        \"\"\"", "        ", "        near = super(Segment,self).near(p)", "        if near[1] < 0:", "            near = (self.spt,0.0,p.distance(self.spt))", "        elif near[1] > 1:", "            near = (self.ept,1.0,p.distance(self.ept))", "        return near", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given line segment, its t value and the distance from the Point to the near Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the Segment.\n"
          },
          "rtype" : "(Point, float, float)",
          "rvalue" : "Tuple of near point on Segment, t value and distance from point to near point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 561,
        "name" : "near",
        "start" : 547
      }, {
        "code" : [ "        \"\"\" Return a new Segment between the ept and spt of this Segment, but pointing in the opposite direction.", "        ", "            :result: Inverted vector.", "            :rtype: Vec", "        \"\"\" ", "        return Segment(self.ept,self._vec.inverted())", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Return a new Segment between the ept and spt of this Segment, but pointing in the opposite direction." ],
          "rtype" : "Vec",
          "rvalue" : "Inverted vector.\n"
        },
        "end" : 572,
        "name" : "inverted",
        "start" : 566
      }, {
        "code" : [ "        \"\"\"| Divides this segment into a list of Points equally spaced between its start-point and endpoint.", "           | Number of Points returned will be one more than integer divs, such that if this Segment is divided into two, three Points are returned.", "        ", "           :param divs: Number of divisions.", "           :type divs: int        ", "           :result: List of Points equally spaced along this Segment", "           :rtype: list", "        \"\"\"", "        tt = Interval().divide(divs, True)", "        return [self.eval(t) for t in tt]", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Divides this segment into a list of Points equally spaced between its start-point and endpoint.", "| Number of Points returned will be one more than integer divs, such that if this Segment is divided into two, three Points are returned." ],
          "parameters" : {
            "divs" : "Number of divisions.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of Points equally spaced along this Segment\n",
          "types" : {
            "divs" : "int        \n"
          }
        },
        "end" : 585,
        "name" : "divide",
        "start" : 575
      }, {
        "code" : [ "        \"\"\" Divides this Segment into a list of smaller equally-sized Segments.", "        ", "            :param divs: Number of subsegments.", "            :type divs: int", "            :result: List of smaller Segments. ", "            :rtype: list", "        \"\"\"", "        pts = self.divide(divs)", "        return [Segment(pa,pb) for pa,pb in zip(pts[:-1],pts[1:]) ]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Divides this Segment into a list of smaller equally-sized Segments." ],
          "parameters" : {
            "divs" : "Number of subsegments.\n"
          },
          "rtype" : "list",
          "rvalue" : "List of smaller Segments. \n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 596,
        "name" : "subsegment",
        "start" : 587
      }, {
        "code" : [ "    def by_coords2d(x0=0.0,y0=0.0,x1=1.0,y1=1.0): ", "        \"\"\" Returns a 2D LinearEntity from two sets of x and y coordinates.", "        ", "            :param x0: First x-coord.", "            :type x0: float", "            :param y0: First y-coord.", "            :type y0: float", "            :param x1: Second x-coord.", "            :type x1: float", "            :param y1: Second y-coord.", "            :type y1: float", "            :result: Segment", "            :rtype: Segment", "            ", "        \"\"\"", "    ", "        return Segment(Point(x0,y0),Point(x1,y1))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a 2D LinearEntity from two sets of x and y coordinates." ],
          "parameters" : {
            "x0" : "First x-coord.\n",
            "x1" : "Second x-coord.\n",
            "y0" : "First y-coord.\n",
            "y1" : "Second y-coord.\n"
          },
          "rtype" : "Segment",
          "rvalue" : "Segment\n",
          "types" : {
            "x0" : "float\n",
            "x1" : "float\n",
            "y0" : "float\n",
            "y1" : "float\n"
          }
        },
        "end" : 616,
        "name" : "by_coords2d",
        "start" : 599
      }, {
        "code" : [ "    def by_coords3d(x0=0.0,y0=0.0,z0=0.0,x1=1.0,y1=1.0,z1=1.0): ", "        \"\"\" Returns a 3D LinearEntity from two sets of x,y and z coordinates.", "        ", "            :param x0: First x-coord.", "            :type x0: float", "            :param y0: First y-coord.", "            :type y0: float", "            :param z0: First z-coord.", "            :type z0: float", "            :param x1: Second x-coord.", "            :type x1: float", "            :param y1: Second y-coord.", "            :type y1: float", "            :param z1: Second z-coord.", "            :type z1: float", "            :result: Segment", "            :rtype: Segment", "            ", "        \"\"\"", "        return Segment(Point(x0,y0,z0),Point(x1,y1,z1))        ", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a 3D LinearEntity from two sets of x,y and z coordinates." ],
          "parameters" : {
            "x0" : "First x-coord.\n",
            "x1" : "Second x-coord.\n",
            "y0" : "First y-coord.\n",
            "y1" : "Second y-coord.\n",
            "z0" : "First z-coord.\n",
            "z1" : "Second z-coord.\n"
          },
          "rtype" : "Segment",
          "rvalue" : "Segment\n",
          "types" : {
            "x0" : "float\n",
            "x1" : "float\n",
            "y0" : "float\n",
            "y1" : "float\n",
            "z0" : "float\n",
            "z1" : "float\n"
          }
        },
        "end" : 638,
        "name" : "by_coords3d",
        "start" : 618
      }, {
        "code" : [ "    def merge(seg_a, seg_b, tol=None):", "        if not seg_a.is_overlapping(seg_b,tol): return False", "        pts = [seg_a.spt,seg_a.ept,seg_b.spt,seg_b.ept]", "        t_vals = sorted([seg_a.to_line().near(p)[1] for p in pts])", "        return Segment(seg_a.eval(t_vals[0]), seg_a.eval(t_vals[-1]))", "        " ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 645,
        "name" : "merge",
        "start" : 640
      }, {
        "code" : [ "    def chain(pts,periodic=None):", "        if periodic is None: return [Segment(pa,pb) for pa,pb in zip(pts[:-1],pts[1:])]", "        return [Segment(pts[-1],pts[0])]+[Segment(pa,pb) for pa,pb in zip(pts[:-1],pts[1:])]        ", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 650,
        "name" : "chain",
        "start" : 647
      } ],
      "documentation" : {
        "description" : [ "A directed line segment in space." ]
      },
      "end" : 650,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_line.py",
      "name" : "Segment",
      "references" : {
        "classes" : {
          "Interval" : 1,
          "LinearEntity" : 1,
          "Point" : 5,
          "Segment" : 10
        },
        "functions" : {
          "__div__" : 1,
          "__floordiv__" : 1,
          "__repr__" : 1,
          "__truediv__" : 1,
          "by_coords2d" : 1,
          "by_coords3d" : 1,
          "chain" : 1,
          "divide" : 1,
          "ept" : 2,
          "inverted" : 1,
          "is_coincident" : 1,
          "is_encompassing" : 1,
          "is_equal" : 1,
          "is_overlapping" : 1,
          "length" : 1,
          "merge" : 1,
          "midpoint" : 1,
          "near" : 1,
          "pts" : 1,
          "subsegment" : 1
        }
      },
      "start" : 397
    },
    "f024beb1-3890-40db-83b8-9ad6b7ab84a5" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_line.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"LinearEntity Constructor.", "", "            :param a: Starting point.", "            :type a: Point", "            :param b: Second point or Vector.", "            :type b: Point or Vector", "            :result: LinearEntity object.", "            :rtype: LinearEntity", "        \"\"\"", "        self._pt = a if isinstance(a,Point) else Point(a.x,a.y,a.z)", "        if isinstance(b,Point) : self._vec = Vec(b-a)", "        elif isinstance(b,Plane) : self._vec = Vec(b.origin-a)" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "LinearEntity Constructor." ],
          "parameters" : {
            "a" : "Starting point.\n",
            "b" : "Second point or Vector.\n"
          },
          "rtype" : "LinearEntity",
          "rvalue" : "LinearEntity object.\n",
          "types" : {
            "a" : "Point\n",
            "b" : "Point or Vector\n"
          }
        },
        "end" : 27,
        "name" : "__init__",
        "start" : 16
      }, {
        "code" : [ "        \"\"\"| Overloads the addition **(+)** operator. ", "           | Adds the given vector to LinearEntity._pt, effectively translating this LinearEntity.", "        ", "           :param other: Vec to be added.", "           :type other: Vec", "           :result: LinearEntity", "           :rtype: LinearEntity", "        \"\"\"", "        self._pt = self._pt + other", "        return self", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the addition **(+)** operator.", "| Adds the given vector to LinearEntity._pt, effectively translating this LinearEntity." ],
          "parameters" : {
            "other" : "Vec to be added.\n"
          },
          "rtype" : "LinearEntity",
          "rvalue" : "LinearEntity\n",
          "types" : {
            "other" : "Vec\n"
          }
        },
        "end" : 42,
        "name" : "__add__",
        "start" : 32
      }, {
        "code" : [ "        \"\"\"| Overloads the multiplication **(*)** operator. ", "           | If given a scalar, transforms this LinearEntity by multiplying the vector of this LinearEntity by the scalar, and returns this LinearEntity", "        ", "           :param other: Scalar to be multiplied.", "           :type other: float", "           :result: This LinearEntity", "           :rtype: LinearEntity", "           ", "           ::", "           ", "                my_le * float", "        \"\"\"  ", "        from .dc_xform import Xform", "        if isinstance(other, Xform) : return other * self", "        else :        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the multiplication **(*)** operator.", "| If given a scalar, transforms this LinearEntity by multiplying the vector of this LinearEntity by the scalar, and returns this LinearEntity" ],
          "parameters" : {
            "other" : "Scalar to be multiplied.\n"
          },
          "rtype" : "LinearEntity\n\n",
          "rvalue" : "This LinearEntity\n",
          "types" : {
            "other" : "float\n"
          }
        },
        "end" : 58,
        "name" : "__mul__",
        "start" : 44
      }, {
        "code" : [ "        \"\"\"| Overloads the equality **(==)** operator. ", "           | Calls the is_equal method", "           ", "           ::", "           ", "                my_le == other_le", "        \"\"\"  ", "        return self.is_equal(other)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the equality **(==)** operator.", "| Calls the is_equal method", "::", "my_le == other_le" ]
        },
        "end" : 71,
        "name" : "__eq__",
        "start" : 63
      }, {
        "code" : [ "        \"\"\" Overloads the containment **(in)** operator", "        ", "            :param number: Point whose containment must be determined.", "            :type number: Point", "            :result: Boolean result of containment.", "            :rtype: bool", "            ", "        \"\"\"", "        return self.contains(other)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the containment **(in)** operator" ],
          "parameters" : {
            "number" : "Point whose containment must be determined.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of containment.\n",
          "types" : {
            "number" : "Point\n"
          }
        },
        "end" : 82,
        "name" : "__contains__",
        "start" : 73
      }, {
        "code" : [ "    def spt(self): ", "        \"\"\" Returns the starting Point of a LinearEntity.", "", "            :result: Starting Point.", "            :rtype: Point", "        \"\"\"", "        return self._pt", "    @spt.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the starting Point of a LinearEntity." ],
          "rtype" : "Point",
          "rvalue" : "Starting Point.\n"
        },
        "end" : 91,
        "name" : "spt",
        "start" : 84
      }, {
        "code" : [ "    def spt(self, point): ", "        \"\"\" Sets the starting Point of a LinearEntity.", "", "            :param point: Starting Point.", "            :type point: Point", "            :result: Sets a starting point.", "            :rtype: None", "        \"\"\"", "        self._pt = point  ", "    @property" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the starting Point of a LinearEntity." ],
          "parameters" : {
            "point" : "Starting Point.\n"
          },
          "rtype" : "None",
          "rvalue" : "Sets a starting point.\n",
          "types" : {
            "point" : "Point\n"
          }
        },
        "end" : 101,
        "name" : "spt",
        "start" : 92
      }, {
        "code" : [ "    def vec(self): ", "        \"\"\" Returns the Vec direction of a LinearEntity.", "", "            :result: Vector.", "            :rtype: Vec", "        \"\"\"", "        return self._vec", "    @vec.setter" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the Vec direction of a LinearEntity." ],
          "rtype" : "Vec",
          "rvalue" : "Vector.\n"
        },
        "end" : 109,
        "name" : "vec",
        "start" : 102
      }, {
        "code" : [ "    def vec(self, vec):", "        \"\"\" Sets the Vec direction of a LinearEntity.", "", "            :param vec: New Vec direction.", "            :type vec:Vec", "            :result: Sets the Vec direction.", "            :rtype: None", "        \"\"\"    ", "        self._vec = vec", "" ],
        "decorators" : "setter",
        "documentation" : {
          "description" : [ "Sets the Vec direction of a LinearEntity." ],
          "parameters" : {
            "vec" : "New Vec direction.\n"
          },
          "rtype" : "None",
          "rvalue" : "Sets the Vec direction.\n",
          "types" : {
            "vec" : "Vec\n"
          }
        },
        "end" : 119,
        "name" : "vec",
        "start" : 110
      }, {
        "code" : [ "    def coefficients(self):", "        \"\"\" Returns the coefficients (a,b,c) of this line for equation ax+by+c=0", "        ", "            :result: coefficients of the equation of a line (a,b,c).", "            :rtype: tuple", "        ", "            .. warning:: This method is not yet implemented.", "        \"\"\"", "        raise NotImplementedError()", "        return (self.p1[1]-self.p2[1],", "                self.p2[0]-self.p1[0]," ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the coefficients (a,b,c) of this line for equation ax+by+c=0" ],
          "rtype" : "tuple\n\n.. warning",
          "rvalue" : "coefficients of the equation of a line (a,b,c).\n"
        },
        "end" : 132,
        "name" : "coefficients",
        "start" : 122
      }, {
        "code" : [ "    def is_identical(self,other): return self.is_coincident(other)" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 136,
        "name" : "is_equal",
        "start" : 136
      }, {
        "code" : [ "    def is_coincident(self, other):  raise NotImplementedError()" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 137,
        "name" : "is_identical",
        "start" : 137
      }, {
        "code" : [ "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 138,
        "name" : "is_coincident",
        "start" : 138
      }, {
        "code" : [ "        \"\"\" Returns True if the LinearEntities contain vectors with equal or opposite direction within a given tolerance.", "", "            :param other: LinearEntity to be compared.", "            :type other: LinearEntity", "            :param tol: Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type tol: float              ", "            :result: Boolean result of comparison.", "            :rtype: bool", "        ", "            ", "        \"\"\"", "        return self.vec.is_parallel(other.vec,tol)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the LinearEntities contain vectors with equal or opposite direction within a given tolerance." ],
          "parameters" : {
            "other" : "LinearEntity to be compared.\n",
            "tol" : "Tolerance of difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "LinearEntity\n",
            "tol" : "float              \n"
          }
        },
        "end" : 152,
        "name" : "is_parallel",
        "start" : 140
      }, {
        "code" : [ "        \"\"\" Returns True if the LinearEntities contain vectors with perpendicular to one another within a given tolerance.", "           ", "            :param other: LinearEntity to be compared.", "            :type other: LinearEntity", "            :param tol: Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.", "            :type tol: float              ", "            :result: Boolean result of comparison.", "            :rtype: bool", "                     ", "        \"\"\"", "        if self.vec.is_perpendicular(other.vec,tol):", "            la = Line(self.spt, self.vec)", "            lb = Line(other.spt, other.vec)", "            from .dc_intersection import Intersector", "            xsec = Intersector()", "            if xsec.of(la,lb): return True", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the LinearEntities contain vectors with perpendicular to one another within a given tolerance." ],
          "parameters" : {
            "other" : "LinearEntity to be compared.\n",
            "tol" : "Tolerance of vector direction difference that does not correspond to an angular dimension or distance, but is treated as a separate numeric delta for x, y, and z coordinates of the normalized vectors.\n"
          },
          "rtype" : "bool\n         ",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "LinearEntity\n",
            "tol" : "float              \n"
          }
        },
        "end" : 171,
        "name" : "is_perpendicular",
        "start" : 154
      }, {
        "code" : [ "        \"\"\" Returns True if the LinearEntities are parallel within a given tolerance ang_tol, and lie on the same line within another tolerance pos_tol.", "           ", "            :param other: LinearEntity to be compared.", "            :type other: LinearEntity", "            :param pos_tol: Tolerance of point projection distance.", "            :type pos_tol: float               ", "            :param ang_tol: Tolerance of vector direction difference ", "            :type ang_tol: float              ", "            :result: Boolean result of comparison.", "            :rtype: bool", "                     ", "        \"\"\"", "        if self.vec.is_parallel(other.vec,ang_tol):", "            if pos_tol is None: pos_tol = EPSILON", "            la, lb = Line(self.spt, self.vec), Line(other.spt, other.vec)", "            if la.near(other.spt)[2] <= pos_tol and lb.near(self.spt)[2] <= pos_tol : return True", "        return False", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the LinearEntities are parallel within a given tolerance ang_tol, and lie on the same line within another tolerance pos_tol." ],
          "parameters" : {
            "ang_tol" : "Tolerance of vector direction difference \n",
            "other" : "LinearEntity to be compared.\n",
            "pos_tol" : "Tolerance of point projection distance.\n"
          },
          "rtype" : "bool\n         ",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "ang_tol" : "float              \n",
            "other" : "LinearEntity\n",
            "pos_tol" : "float               \n"
          }
        },
        "end" : 190,
        "name" : "is_collinear",
        "start" : 173
      }, {
        "code" : [ "        \"\"\" Returns True if the LinearEntities lie on the same plane within a given tolerance tol", "           ", "            :param other: LinearEntity to be compared.", "            :type other: LinearEntity", "            :param tol: Tolerance of vector direction difference", "            :type tol: float  ", "            :result: Boolean result of comparison.", "            :rtype: bool", "                     ", "        \"\"\"", "        p0,p1 = self.spt,self.spt+self.vec", "        q0,q1 = other.spt, other.spt+other.vec", "        n_vec = Vec(q0,p1).cross(Vec(q0,p0))", "        if tol is None: tol = EPSILON", "        if n_vec.dot(Vec(q0,q1)) < tol: return True", "        return False", " " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the LinearEntities lie on the same plane within a given tolerance tol" ],
          "parameters" : {
            "other" : "LinearEntity to be compared.\n",
            "tol" : "Tolerance of vector direction difference\n"
          },
          "rtype" : "bool\n         ",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "LinearEntity\n",
            "tol" : "float  \n"
          }
        },
        "end" : 208,
        "name" : "is_coplanar",
        "start" : 192
      }, {
        "code" : [ "        \"\"\" Returns True if the given Point lines along this Segment within a given tolerance", "", "            :param other: Point to be appraised.", "            :type other: Point             ", "            :param tol: Tolerance of point projection.", "            :type tol: float", "            :result: Boolean result of comparison.", "            :rtype: bool", "            ", "            ::", "            ", "                my_seg.contains(pt)", "        \"\"\"", "        if tol is None: tol = EPSILON", "        if self.near(pt)[2] < tol: return True", "        return False", " " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if the given Point lines along this Segment within a given tolerance" ],
          "parameters" : {
            "other" : "Point to be appraised.\n",
            "tol" : "Tolerance of point projection.\n"
          },
          "rtype" : "bool\n\n",
          "rvalue" : "Boolean result of comparison.\n",
          "types" : {
            "other" : "Point             \n",
            "tol" : "float\n"
          }
        },
        "end" : 227,
        "name" : "contains",
        "start" : 211
      }, {
        "code" : [ "        \"\"\" Returns an angle formed between the two linear entities.", "        ", "            :param other: Other LinearEntity", "            :type other: LinearEntity", "            :result: Angle in radians.", "            :rtype: float      ", "       \"\"\"", "        return self.vec.angle(other.vec)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns an angle formed between the two linear entities." ],
          "parameters" : {
            "other" : "Other LinearEntity\n"
          },
          "rtype" : "float      ",
          "rvalue" : "Angle in radians.\n",
          "types" : {
            "other" : "LinearEntity\n"
          }
        },
        "end" : 238,
        "name" : "angle",
        "start" : 230
      }, {
        "code" : [ "        \"\"\" Returns a new Line which is parallel to this linear entity and passes through the specified point.", "        ", "            :param p: Point that the LinearEntity will pass through.", "            :type p: Point", "            :result: New LinearEntity.", "            :rtype: LinearEntity", "        \"\"\"", "        return Line(p, self.vec)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a new Line which is parallel to this linear entity and passes through the specified point." ],
          "parameters" : {
            "p" : "Point that the LinearEntity will pass through.\n"
          },
          "rtype" : "LinearEntity",
          "rvalue" : "New LinearEntity.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 248,
        "name" : "parallel_line_through",
        "start" : 240
      }, {
        "code" : [ "        \"\"\" Returns a tuple of the closest point to a given LinearEntity, its t value and the distance from the Point to the near Point.", "       ", "            :param p: Point to look for a near Point on the LinearEntity.", "            :type p: Point", "            :result: Tuple of near point on LinearEntity, t value and distance from point to near point.", "            :rtype: (Point, float, float)", "        \"\"\"", "        t = Vec(self.spt,p).dot(self.vec)/self.vec.dot(self.vec)", "        point = self.eval(t)", "        return (point, t,point.distance(p))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a tuple of the closest point to a given LinearEntity, its t value and the distance from the Point to the near Point." ],
          "parameters" : {
            "p" : "Point to look for a near Point on the LinearEntity.\n"
          },
          "rtype" : "(Point, float, float)",
          "rvalue" : "Tuple of near point on LinearEntity, t value and distance from point to near point.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 260,
        "name" : "near",
        "start" : 250
      }, {
        "code" : [ "        \"\"\" Returns the closest point to a given LinearEntity", "       ", "            :param p: Point to look for a near Point on the LinearEntity.", "            :type p: Point", "            :result: Near point on LinearEntity.", "            :rtype: Point", "        \"\"\"", "        return self.near(p)[0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point to a given LinearEntity" ],
          "parameters" : {
            "p" : "Point to look for a near Point on the LinearEntity.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Near point on LinearEntity.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 270,
        "name" : "near_pt",
        "start" : 262
      }, {
        "code" : [ "        \"\"\" Evaluates a LinearEntity at a given number.", "        ", "            :param t: Number between 0 and 1 to evaluate the LinearEntity at.", "            :type t: float", "            :result: Evaluated Point on LinearEntity.", "            :rtype: Point", "        \"\"\"", "        return self.spt + (self.vec * t)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Evaluates a LinearEntity at a given number." ],
          "parameters" : {
            "t" : "Number between 0 and 1 to evaluate the LinearEntity at.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Evaluated Point on LinearEntity.\n",
          "types" : {
            "t" : "float\n"
          }
        },
        "end" : 280,
        "name" : "eval",
        "start" : 272
      }, {
        "code" : [ "        return Line(self.spt,self.vec)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 283,
        "name" : "to_line",
        "start" : 282
      } ],
      "documentation" : {
        "description" : [ "A linear entity (line, ray, segment, etc) in space.", ".. warning:: This is an abstract class and is not meant to be instantiated." ]
      },
      "end" : 283,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_line.py",
      "name" : "LinearEntity",
      "references" : {
        "classes" : {
          "EPSILON" : 3,
          "Geometry" : 1,
          "Intersector" : 1,
          "Line" : 6,
          "LinearEntity" : 1,
          "Plane" : 1,
          "Point" : 3,
          "Vec" : 7,
          "Xform" : 1
        },
        "functions" : {
          "__add__" : 1,
          "__contains__" : 1,
          "__eq__" : 1,
          "__init__" : 1,
          "__mul__" : 1,
          "angle" : 1,
          "coefficients" : 1,
          "contains" : 1,
          "eval" : 1,
          "is_coincident" : 1,
          "is_collinear" : 1,
          "is_coplanar" : 1,
          "is_equal" : 1,
          "is_identical" : 1,
          "is_parallel" : 1,
          "is_perpendicular" : 1,
          "near" : 1,
          "near_pt" : 1,
          "parallel_line_through" : 1,
          "spt" : 2,
          "to_line" : 1,
          "vec" : 2
        }
      },
      "start" : 9
    },
    "f1335b83-ff87-4248-9834-eb7be3f53b4b" : {
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/Loose Examples/2.XX.XX - Spirograph/2.E02c.py",
      "name" : "2.E02c.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Interval" : 1,
          "Point" : 2,
          "Segment" : 1
        }
      }
    },
    "f1b1f8bc-1a8e-40fd-9a3a-c576d6260647" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def distance_curve_segment(crv, seg):", "    step = crv.tol", "    t_now = crv.domain.a + step", "    t_max = t_now", "    dist_max = 0", "    while t_now < crv.domain.b:", "        pt_crv = crv.deval(t_now)", "        dist = seg.near(pt_crv)[2]", "        if dist > dist_max:", "            dist_max = dist", "            t_max = t_now", "        t_now += step", "    return dist_max, t_max", "", "" ],
          "end" : 36,
          "start" : 22
        },
        "description" : "\nDistance from Curve to Line Segment\n",
        "end" : 22,
        "start" : 20
      } ],
      "documentation" : {
        "description" : [ "4.03.L02a", "Computes the distance between a given curve and a line segment using points along", "the curve determined by its tolerance.  Returns the distance and the t-value", "on the curve at which this distance is achieved. Distance is defined as the", "maximal perpendicular distance between the curve and segment if the projected", "point falls on the line segment or the distance to the nearest endpoint if the", "projected point doesn't fall on the segment." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Curve Decomposition/4.03.L02a.py",
      "name" : "4.03.L02a.py",
      "required" : [ "curve (Curve) The Curve for distance Computation", "seg (Segment) The Segment for distance computation" ],
      "result" : [ "dist_max (float) The maximum distance from the Curve to the Segment", "t_max (float) The domain evaluation on the curve where the max distance happens." ]
    },
    "f200e65b-0cad-4ed8-8e09-fc89f3907aa5" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "# initialize a dictionary to hold tiles", "dict = {}", "", "# for every node in the graph:", "for n0 in gph.nodes:", "    # initialize a list indexed to this node in our dict", "    dict[n0] = []", "    # for every possible pair of connections to this node:", "    for n1 in gph.edges[n0]:", "        for n2 in set(gph.edges[n0]) - set([n1]):", "            # if they are connected to each other:", "            if n2 in gph.edges[n1] or n1 in gph.edges[n2]:", "                # create a TriTile", "                tri = TriTile(n0,n1,n2)", "                # store it if it doesn't already exist", "                if not any(pt in dict and tri in dict[pt] for pt in tri.pts):", "                    dict[n0].append(tri)", "                    " ],
          "end" : 33,
          "start" : 15
        },
        "description" : "\nTriTile Construction\nGiven a graph of points and connections, creates Tritiles wherever possible.\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "", "for tri in tris:", "    for other in set(tris) - set([tri]):", "        if tri.shares_pts(other,1) : tri.neighbors.append(other)" ],
          "end" : 40,
          "start" : 37
        },
        "description" : "\nTriTile neighborhood creation\nGiven a list of TriTiles, computes all adjacencies and stores references to neighbors\n",
        "end" : 37,
        "start" : 34
      } ],
      "documentation" : {
        "description" : [ "4.02.F01d", "TODO" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Complexity/Sabin/4.02.F01d.py",
      "name" : "4.02.F01d.py",
      "references" : {
        "classes" : {
          "TriTile" : 1
        }
      }
    },
    "f22a08f6-dbc5-4198-a806-adae47fe17d8" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def torus_param(major_radius):", "    #set torus parameters", "    div_u = 30", "    div_v = 30", "    tor_vals = {'cs':CS.on_yz(0,-3,Vec.uz()),", "                 'major_radius':major_radius,", "                 'minor_radius':2.7,", "                 'dom_u':Interval.twopi(),", "                 'dom_v':Interval.twopi(),", "                 'param_type':False}", "    #set rotation angle", "    rot_angle = -0.3", "    # Type 3 Parameterization", "    if param == 3:", "        tor_vals['param_type']=1", "        # create a torus of type 1", "        torus = Torus(**tor_vals)", "        # create a second torus of type 2", "        tor_vals['param_type']=2", "        torus2 = Torus(**tor_vals)", "    ", "    elif param == 4 or param == 5:", "        # Type 4 parameterization", "        if param == 4:", "            # create a torus of type 1", "            tor_vals['param_type']=1", "            torus = Torus(**tor_vals)", "            # create a second torus of type 0", "            tor_vals['param_type']=0", "            torus2 = Torus(**tor_vals)", "         # Type 5 parameterization", "        else: ", "            # create a torus of type 2", "            tor_vals['param_type']=2", "            torus = Torus(**tor_vals)", "            # create a torus of type 0", "            tor_vals['param_type']=0", "            torus2 = Torus(**tor_vals)", "    ", "    # Type 1 or 2 Parameterization", "    else:", "        # create a single torus on a given domain", "        tor_vals['param_type']=param", "        torus = Torus(**tor_vals)", "        torus2 = False", "", "    # modify the position of the first torus' CS by rotation angle", "    torus.cs *= Xform.rotation(axis=Vec(0,1,0), angle=rot_angle)", "    # extract the u and v isocurves for all toruses", "    tor_lines_u = [torus.isocurve(u_val=i) for i in tor_vals['dom_u'].divide(div_u)]", "    tor_lines_v = [torus.isocurve(v_val=i) for i in tor_vals['dom_v'].divide(div_v)]", "    # if there is a second torus involved", "    if torus2:", "        # modify the position of the second torus' CS by rotation angle", "        torus2.cs *= Xform.rotation(axis=Vec(0,1,0), angle=rot_angle)", "        # select one set of isocurves from each torus ", "        for line in [torus2.isocurve(u_val=i) for i in tor_vals['dom_u'].divide(div_u)]:", "            tor_lines_u.append(line)", "        for line in [torus2.isocurve(v_val=i) for i in tor_vals['dom_v'].divide(div_v)]:", "            tor_lines_v.append(line)", "    return tor_lines_u, tor_lines_v", "" ],
          "end" : 78,
          "start" : 16
        },
        "description" : "\nTorus Patch Parameterization\nCombine a number of Tori to create different Torus parameterizations.\n[pseudo]\n",
        "end" : 16,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "radius = 5.00", "offset = 0.06", "# Get all u and v isocurves for the torus", "tor_lines_u, tor_lines_v = torus_param(radius)", "# get all the offset isocurves", "tor_lines_secondary_u, tor_lines_secondary_v = torus_param(radius+offset)", "cut_plane = Plane(Point(0,0,1), Vec(0,0,1))", "split_lines = []", "split_lines_offset = []", "", "# split all isocurves with the cutplane", "for line in tor_lines_u:", "    split_lines.append(split_arc(line, cut_plane))", "for line in tor_lines_v:", "    split_lines.append(split_arc(line, cut_plane))", "for line in tor_lines_secondary_u:", "    split_lines_offset.append(split_arc(line, cut_plane))", "for line in tor_lines_secondary_v:", "    split_lines_offset.append(split_arc(line, cut_plane))", "", "" ],
          "end" : 102,
          "start" : 82
        },
        "description" : "\nSplitting with Intersect Plane\n[pseudo]\n",
        "end" : 82,
        "start" : 79
      } ],
      "documentation" : {
        "description" : [ "4.03.F01c", "Create a Torus and a Plane to split it. Return a list with the split portions of the Torus." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Decomposition/Foster Pre-Rational Studies/4.03.F01c.py",
      "name" : "4.03.F01c.py",
      "references" : {
        "classes" : {
          "CS" : 1,
          "Interval" : 2,
          "Plane" : 1,
          "Point" : 1,
          "Torus" : 7,
          "Vec" : 4,
          "Xform" : 2
        }
      }
    },
    "f5094255-27a0-45f2-be6b-7ef0db4fa4b0" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_curve.py",
      "definitions" : [ {
        "code" : [ "    def __div__(self, divs): " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 12,
        "name" : "__truediv__",
        "start" : 12
      }, {
        "code" : [ "        \"\"\"Overloads the division **(/)** operator. Calls Curve.divide(divs).", "        ", "            :param divs: Number of curve planes to divide the curve in.", "            :type divs: float", "            :result: List of curve segments.", "            :rtype: [Point]", "        \"\"\"", "        return self.divide(divs)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the division **(/)** operator. Calls Curve.divide(divs)." ],
          "parameters" : {
            "divs" : "Number of curve planes to divide the curve in.\n"
          },
          "rtype" : "[Point]",
          "rvalue" : "List of curve segments.\n",
          "types" : {
            "divs" : "float\n"
          }
        },
        "end" : 21,
        "name" : "__div__",
        "start" : 13
      }, {
        "code" : [ "        \"\"\"Overloads the integer division **(//)** operator. Calls Interval.subdivide(divs).", "        ", "            :param divs: Number of segments to divide the curve in.", "            :type divs: float", "            :result: List of curve segments.", "            :rtype: [Curve]", "        \"\"\"", "        return self.subdivide(divs)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the integer division **(//)** operator. Calls Interval.subdivide(divs)." ],
          "parameters" : {
            "divs" : "Number of segments to divide the curve in.\n"
          },
          "rtype" : "[Curve]",
          "rvalue" : "List of curve segments.\n",
          "types" : {
            "divs" : "float\n"
          }
        },
        "end" : 31,
        "name" : "__floordiv__",
        "start" : 23
      }, {
        "code" : [ "    def func(self): return self._func", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 34,
        "name" : "func",
        "start" : 33
      }, {
        "code" : [ "        \"\"\"| Finds a location on this curve which is nearest to the given Point.", "           | Unstable and inaccurate.", "           | Recursive function that searches for closer points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "           | Returns a tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point.", "            ", "           :param pt: Point to look for the nearest point on a curve.", "           :type pt: Point", "           :param tolerance: Tolerance to search for the near point. Defaults to None.", "           :type tolerance: float", "           :param max_recursion: Maximum number of loops to look for the nearest point. Defaults to 20.", "           :type max_recursion: int", "           :result: Tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point.", "           :rtype: (Point, float, float)", "           ", "           ::", "", "                def func(u):", "                    return Point(math.sin(u),u)", "                Inv=Interval(0,20)", "                crv = Curve(func,Inv)", "", "                n_tup=crv.near(Point(0,0,0))", "", "        \"\"\"", "        if tolerance is None : tolerance = self.tol/10.0", "        t = self._nearfar(Point.near_index,pt,tolerance,max_recursion,resolution)", "        result = self.deval(t)", "        return(result,t,pt.distance(result))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Finds a location on this curve which is nearest to the given Point.", "| Unstable and inaccurate.", "| Recursive function that searches for closer points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "| Returns a tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point." ],
          "parameters" : {
            "max_recursion" : "Maximum number of loops to look for the nearest point. Defaults to 20.\n",
            "pt" : "Point to look for the nearest point on a curve.\n",
            "tolerance" : "Tolerance to search for the near point. Defaults to None.\n"
          },
          "rtype" : "(Point, float, float)\n\n",
          "rvalue" : "Tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point.\n",
          "types" : {
            "max_recursion" : "int\n",
            "pt" : "Point\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 65,
        "name" : "near",
        "start" : 37
      }, {
        "code" : [ "        \"\"\"| Finds a location on this curve which is nearest to the given Point.", "           | Unstable and inaccurate.", "           | Recursive function that searches for closer points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "           | Returns a Point.", "            ", "           :param pt: Point to look for the nearest point on a curve.", "           :type pt: Point", "           :param tolerance: Tolerance to search for the near point. Defaults to None.", "           :type tolerance: float", "           :param max_recursion: Maximum number of loops to look for the nearest point. Defaults to 20.", "           :type max_recursion: int", "           :result: Point.", "           :rtype: Point", "        \"\"\"", "", "        return self.near(pt,tolerance,max_recursion,resolution)[0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Finds a location on this curve which is nearest to the given Point.", "| Unstable and inaccurate.", "| Recursive function that searches for closer points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "| Returns a Point." ],
          "parameters" : {
            "max_recursion" : "Maximum number of loops to look for the nearest point. Defaults to 20.\n",
            "pt" : "Point to look for the nearest point on a curve.\n",
            "tolerance" : "Tolerance to search for the near point. Defaults to None.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Point.\n",
          "types" : {
            "max_recursion" : "int\n",
            "pt" : "Point\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 83,
        "name" : "near_pt",
        "start" : 67
      }, {
        "code" : [ "        \"\"\"| Finds a location on this curve which is furthest from the given Point.", "           | Unstable and inaccurate.", "           | Recursive function that searches for further points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "           | Returns a tuple containing a Point, a t-value associated with this Point, and the distance from this Point to the given Point.", "            ", "           :param pt: Point to look for the farthest point on a curve.", "           :type pt: Point", "           :param tolerance: Tolerance to search for the far point. Defaults to None.", "           :type tolerance: float", "           :param max_recursion: Maximum number of loops to look for the farthest point. Defaults to 20.", "           :type max_recursion: int", "           :result: Tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point.", "           :rtype: (Point, float, float)", "           ", "           ::", "           ", "                def func(u):", "                    return Point(math.sin(u),u)", "                Inv=Interval(0,20)", "                crv = Curve(func,Inv)   ", "                ", "                f_tup=crv.far(Point(0,0,0))", "                      ", "        \"\"\"", "        if tolerance is None : tolerance = self.tol/10.0", "        t = self._nearfar(Point.far_index,pt,tolerance,max_recursion,resolution)", "        result = self.deval(t)", "        return(result,t,pt.distance(result))", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Finds a location on this curve which is furthest from the given Point.", "| Unstable and inaccurate.", "| Recursive function that searches for further points (at a given division resolution) until the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "| Returns a tuple containing a Point, a t-value associated with this Point, and the distance from this Point to the given Point." ],
          "parameters" : {
            "max_recursion" : "Maximum number of loops to look for the farthest point. Defaults to 20.\n",
            "pt" : "Point to look for the farthest point on a curve.\n",
            "tolerance" : "Tolerance to search for the far point. Defaults to None.\n"
          },
          "rtype" : "(Point, float, float)\n\n",
          "rvalue" : "Tuple containing a Point, a t-value associated with this point, and the distance from this Point to the given Point.\n",
          "types" : {
            "max_recursion" : "int\n",
            "pt" : "Point\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 113,
        "name" : "far",
        "start" : 85
      }, {
        "code" : [ "        \"\"\"| Finds a location on this curve which is furthest from the given Point.", "           | Unstable and inaccurate.", "           | Recursive function that searches for further points u (at a given division resolution) ntil the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "           | Returns a Point.", "            ", "           :param pt: Point to look for the furthest point on a curve.", "           :type pt: Point", "           :param tolerance: Tolerance to search for the far point. Defaults to None.", "           :type tolerance: float", "           :param max_recursion: Maximum number of loops to look for the nearest point. Defaults to 20.", "           :type max_recursion: int", "           :result: Point.", "           :rtype: Point", "        \"\"\"", "", "        return self.far(pt,tolerance,max_recursion,resolution)[0]", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Finds a location on this curve which is furthest from the given Point.", "| Unstable and inaccurate.", "| Recursive function that searches for further points u (at a given division resolution) ntil the search area shrinks to given tolerance (Curve.tol/10 by default) in domain space.", "| Returns a Point." ],
          "parameters" : {
            "max_recursion" : "Maximum number of loops to look for the nearest point. Defaults to 20.\n",
            "pt" : "Point to look for the furthest point on a curve.\n",
            "tolerance" : "Tolerance to search for the far point. Defaults to None.\n"
          },
          "rtype" : "Point",
          "rvalue" : "Point.\n",
          "types" : {
            "max_recursion" : "int\n",
            "pt" : "Point\n",
            "tolerance" : "float\n"
          }
        },
        "end" : 131,
        "name" : "far_pt",
        "start" : 115
      } ],
      "documentation" : {
        "description" : [ "Abstract class for describing functionality common to Curves and Surfaces" ]
      },
      "end" : 131,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_curve.py",
      "name" : "IsParametrized",
      "references" : {
        "classes" : {
          "Geometry" : 1,
          "IsParametrized" : 1,
          "Point" : 2
        },
        "functions" : {
          "__div__" : 1,
          "__floordiv__" : 1,
          "__truediv__" : 1,
          "far" : 1,
          "far_pt" : 1,
          "func" : 1,
          "near" : 1,
          "near_pt" : 1
        }
      },
      "start" : 8
    },
    "f58a95ea-334d-4709-a3b6-20c558693d90" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "def color_point(r_val,g_val,b_val):", "    # create a Point from Color values", "    res = Point(r_val,g_val,b_val)", "    # set a Color to the Point", "    res.set_color(r_val,g_val,b_val)", "    return res", "" ],
          "end" : 26,
          "start" : 19
        },
        "description" : "\nGiven Red, Green, and Blue values, return a Point object with a Color property set.\n[noprint]\n",
        "end" : 19,
        "start" : 16
      }, {
        "code" : {
          "content" : [ "", "# define the best results", "best_clr = Color(0,0,0)", "best_fit = 0.0", "pts = []", "thresh = 0.75", "", "# create an interval with n steps", "color_interval = Interval(0.0,1.0).divide(n)", "# for every ri in the Color interval", "for ri in color_interval:", "    # for every gi in the Color interval", "    for gi in color_interval:", "        # for every bi in the Color interval", "        for bi in color_interval:", "            # create a Point with those RGB values", "            pt = color_point(ri,gi,bi)", "            # check how close its Color is with the goal Color", "            fit = fitness(pt.get_color())", "            # if the current color is closer than the previous color:", "            if fit > best_fit:", "                # save the value of the closeness", "                best_fit = fit ", "                # make the current Color the best Color", "                best_clr = pt.get_color()", "            source = Interval(max([thresh,0.8]),1.0)", "            # set a weight to the Point", "            pt.set_weight(Interval.remap(fit, source,Interval(0,10)) )", "            # if the fitness is smaller than the thresh:", "            if fit > thresh : ", "                # keep the Point", "                pts.append(pt)" ],
          "end" : 61,
          "start" : 30
        },
        "description" : " \nBrute Force Color Optimization\nUses a function that returns a list of Colors near to a given Color in order to perform a rudimentary optimization.\n",
        "end" : 30,
        "start" : 27
      } ],
      "documentation" : {
        "description" : [ "4.07.L01b", "Given a fitness function and a number of samples, perform a brute force search of the solution space (n X n X n samples). Output only values that pass a certain threshold." ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Optimization/Color Optimization/4.07.L01b.py",
      "name" : "4.07.L01b.py",
      "references" : {
        "classes" : {
          "Color" : 1,
          "Interval" : 4,
          "Point" : 1
        }
      },
      "required" : [ "fitness (func) Fitness function.", "n (int Number of samples." ],
      "result" : [ "pts ([Point]) Points with colors.", "best_clr (Color) Best fit Color.", "best_fit (float) Value of best fit." ]
    },
    "f7444f5c-ed2d-4993-bf0d-fd29f2e2ccd3" : {
      "code" : [ "    \"\"\" returns the metadata of an EPW file", "    path (string) filepath to the EPW file", "    out: a dict containing EPW metadata", "    \"\"\"", "    with open(path) as myfile:", "        head=[myfile.next() for x in xrange(number_of_epw_header_lines)]", "    ", "    #city,state/province/region,country,data source,wmo number,lat,long,timezone,elevation", "    #LOCATION,San Francisco Intl Ap,CA,USA,TMY3,724940,37.62,-122.40,-8.0,2.0", "    dict = {}", "    vals = head[0].split(\",\")", "    dict['name'] = vals[1]", "    dict['state'] = vals[2]", "    dict['country'] = vals[3]", "    dict['datasource'] = vals[4]", "    dict['wmo'] = int(vals[5])", "    dict['lat'] = float(vals[6])", "    dict['long'] = float(vals[7])", "    dict['timezone'] = float(vals[8])", "    dict['elevation'] = float(vals[9])", "    return dict", "" ],
      "decorators" : "method",
      "documentation" : {
        "description" : [ "returns the metadata of an EPW file", "path (string) filepath to the EPW file", "out: a dict containing EPW metadata" ]
      },
      "end" : 48,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/parse_epw.py",
      "name" : "epw_metadata",
      "start" : 27
    },
    "f7962d15-36e2-43f5-b81a-67a88464e2e2" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/core/dc_bounds.py",
      "definitions" : [ {
        "code" : [ "        \"\"\"A Bounds may be constructed two ways: By setting \"center\", \"dim_x\", \"dim_y\", and optionally \"dim_z\" OR by setting \"ival_x\", \"ival_y\", and optionally \"ival_z\"", "        ", "            :param \\**kargs: Function that accepts multiple parameters to be passed. Parameters include center, x, y and z dimension OR x, y and z intervals.", "            :type \\**kargs: (float, float), float, float OR Interval, Interval", "            :result: Bounds", "            :rtype: Bounds", "        ", "        \"\"\"", "        if len(kargs)==0:", "            self.ival_x = Interval()" ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "A Bounds may be constructed two ways: By setting \"center\", \"dim_x\", \"dim_y\", and optionally \"dim_z\" OR by setting \"ival_x\", \"ival_y\", and optionally \"ival_z\"" ],
          "parameters" : {
            "\\**kargs" : "Function that accepts multiple parameters to be passed. Parameters include center, x, y and z dimension OR x, y and z intervals.\n"
          },
          "rtype" : "Bounds",
          "rvalue" : "Bounds\n",
          "types" : {
            "\\**kargs" : "(float, float), float, float OR Interval, Interval\n"
          }
        },
        "end" : 20,
        "name" : "__init__",
        "start" : 11
      }, {
        "code" : [ "    def cpt(self):", "        \"\"\" Returns the center Point of the Bounds.", "            ", "            :result: Center Point of Bounds.", "            :rtype: Point", "        ", "        \"\"\"", "        try:", "            return Point(self.ival_x.mid,self.ival_y.mid,self.ival_z.mid)", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns the center Point of the Bounds." ],
          "rtype" : "Point",
          "rvalue" : "Center Point of Bounds.\n"
        },
        "end" : 50,
        "name" : "cpt",
        "start" : 41
      }, {
        "code" : [ "    def dim_x(self):", "        \"\"\" Returns x dimension of Bounds.", "        \"\"\"", "        ", "        return self.ival_x.delta", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns x dimension of Bounds." ]
        },
        "end" : 59,
        "name" : "dim_x",
        "start" : 54
      }, {
        "code" : [ "    def dim_y(self):", "        \"\"\" Returns y dimension of Bounds.", "        \"\"\"", "        ", "        return self.ival_y.delta", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns y dimension of Bounds." ]
        },
        "end" : 66,
        "name" : "dim_y",
        "start" : 61
      }, {
        "code" : [ "    def dim_z(self):", "        \"\"\" Returns z dimension of Bounds.", "        \"\"\"", "        ", "        try:", "            return self.ival_z.delta", "        except:" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns z dimension of Bounds." ]
        },
        "end" : 74,
        "name" : "dim_z",
        "start" : 68
      }, {
        "code" : [ "    def is_2d(self):", "        \"\"\" Returns True if Bounds is 2-dimensional (no z component). Otherwise returns False.", "        \"\"\"", "        return not hasattr(self, 'ival_z')", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns True if Bounds is 2-dimensional (no z component). Otherwise returns False." ]
        },
        "end" : 82,
        "name" : "is_2d",
        "start" : 78
      }, {
        "code" : [ "    def is_3d(self): ", "        \"\"\" Returns True if Bounds is 3-dimensional (x, y and z components). Otherwise returns False.", "        \"\"\"", "        return hasattr(self, 'ival_z')", "" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Returns True if Bounds is 3-dimensional (x, y and z components). Otherwise returns False." ]
        },
        "end" : 88,
        "name" : "is_3d",
        "start" : 84
      }, {
        "code" : [ "    def corners(self):", "        \"\"\" Moves counter clockwise, like so:", "        ", "        (-,-)(+,-)(+,+)(-,+)", "        ", "        \"\"\"", "        cpts = []", "        try:", "            cpts.append(Point(self.ival_x.a,self.ival_y.a,self.ival_z.a))", "            cpts.append(Point(self.ival_x.b,self.ival_y.a,self.ival_z.a))", "            cpts.append(Point(self.ival_x.b,self.ival_y.b,self.ival_z.a))", "            cpts.append(Point(self.ival_x.a,self.ival_y.b,self.ival_z.a))", "", "            cpts.append(Point(self.ival_x.a,self.ival_y.a,self.ival_z.b))", "            cpts.append(Point(self.ival_x.b,self.ival_y.a,self.ival_z.b))", "            cpts.append(Point(self.ival_x.b,self.ival_y.b,self.ival_z.b))", "            cpts.append(Point(self.ival_x.a,self.ival_y.b,self.ival_z.b))", "        except:", "            cpts.append(Point(self.ival_x.a,self.ival_y.a))", "            cpts.append(Point(self.ival_x.b,self.ival_y.a))", "            cpts.append(Point(self.ival_x.b,self.ival_y.b))", "            cpts.append(Point(self.ival_x.a,self.ival_y.b))", "        return cpts", "    " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "Moves counter clockwise, like so:", "(-,-)(+,-)(+,+)(-,+)" ]
        },
        "end" : 113,
        "name" : "corners",
        "start" : 90
      }, {
        "code" : [ "    def edges(self):", "        from .dc_line import Segment", "        cnrs = self.corners", "        if self.is_2d:", "            return [" ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 119,
        "name" : "edges",
        "start" : 115
      }, {
        "code" : [ "        \"\"\"| Overloads the containment **(in)** operator.", "", "           .. note:: Less-than or equal-to logic applied, points that lie on any edge of the bounds will be considered to be contained within it.", "        ", "           :param pt: Point whose containment must be determined.", "           :type pt: Point", "           :result: Boolean value", "           :rtype: bool", "        ", "        \"\"\"", "        if not (pt.x in self.ival_x) : return False", "        if not (pt.y in self.ival_y) : return False", "        try:", "            if not (pt.z in self.ival_z) : return False", "            return True", "        except:" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "| Overloads the containment **(in)** operator.", ".. note:: Less-than or equal-to logic applied, points that lie on any edge of the bounds will be considered to be contained within it." ],
          "parameters" : {
            "pt" : "Point whose containment must be determined.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value\n",
          "types" : {
            "pt" : "Point\n"
          }
        },
        "end" : 162,
        "name" : "__contains__",
        "start" : 147
      }, {
        "code" : [ "        \"\"\" Overloads the integer division **(//)** operator. Calls Bounds.subbounds(other).", "        ", "            :param other: Number of sub-boundaries.", "            :type other: int", "            :result: a Bounds divided into sub-bounds.", "            :rtype: Bounds", "        \"\"\"", "        return self.subbounds(other)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Overloads the integer division **(//)** operator. Calls Bounds.subbounds(other)." ],
          "parameters" : {
            "other" : "Number of sub-boundaries.\n"
          },
          "rtype" : "Bounds",
          "rvalue" : "a Bounds divided into sub-bounds.\n",
          "types" : {
            "other" : "int\n"
          }
        },
        "end" : 174,
        "name" : "__floordiv__",
        "start" : 166
      }, {
        "code" : [ "        \"\"\" Returns a point at normalized coordinates (u,v,w). If all coordinates are within a range of [0,1] then the point is in the Bounds. Otherwise the point is outside the Bounds.", "        ", "            :param u: u-coordinate of a Point.", "            :type u: float", "            :param v: v-coordinate of a Point.", "            :type v: float", "            :param w: w-coordinate of a Point.", "            :type w: float", "            :result: A Point with normalized coordinates in the Bounds.", "            :rtype: Point", "        \"\"\"", "        if self.is_2d:", "            return Point(self.ival_x.eval(u),self.ival_y.eval(v))", "        return Point(self.ival_x.eval(u),self.ival_y.eval(v),self.ival_z.eval(w))", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a point at normalized coordinates (u,v,w). If all coordinates are within a range of [0,1] then the point is in the Bounds. Otherwise the point is outside the Bounds." ],
          "parameters" : {
            "u" : "u-coordinate of a Point.\n",
            "v" : "v-coordinate of a Point.\n",
            "w" : "w-coordinate of a Point.\n"
          },
          "rtype" : "Point",
          "rvalue" : "A Point with normalized coordinates in the Bounds.\n",
          "types" : {
            "u" : "float\n",
            "v" : "float\n",
            "w" : "float\n"
          }
        },
        "end" : 190,
        "name" : "eval",
        "start" : 176
      }, {
        "code" : [ "        f2 = (factor-1.0)/2.0", "        pts = [self.eval(0-f2,0-f2,0-f2),self.eval(1+f2,1+f2,1+f2)]", "        ix = Interval.encompass([p.x for p in pts])", "        iy = Interval.encompass([p.y for p in pts])", "        if self.is_2d:  return Bounds(ival_x = ix, ival_y = iy)", "        iz = Interval.encompass([p.z for p in pts])", "        return Bounds(ival_x = ix, ival_y = iy, ival_z = iz)", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 199,
        "name" : "scaled",
        "start" : 192
      }, {
        "code" : [ "        \"\"\" Returns True if this Bounds overlaps the given Bounds.", "        ", "            :param other: Given Bounds to be compared with this Bounds.", "            :type other: Bounds", "            :result: Boolean value", "            :rtype: bool", "            ", "        \"\"\"", "        #if any([pt in self for pt in other.corners] + [pt in other for pt in self.corners]): return True", "        #if self.is_2d: return ((self.ival_x in other.ival_x and other.ival_y in self.ival_y) or (other.ival_x in self.ival_x and self.ival_y in other.ival_y))", "        #return ((self.ival_x in other.ival_x or other.ival_x in self.ival_x) and (self.ival_y in other.ival_y or other.ival_y in self.ival_y) and (self.ival_z in other.ival_z or other.ival_z in self.ival_z) )", "        #return False", "        if self.is_2d: ", "            return(" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns True if this Bounds overlaps the given Bounds." ],
          "parameters" : {
            "other" : "Given Bounds to be compared with this Bounds.\n"
          },
          "rtype" : "bool",
          "rvalue" : "Boolean value\n",
          "types" : {
            "other" : "Bounds\n"
          }
        },
        "end" : 215,
        "name" : "overlaps",
        "start" : 202
      }, {
        "code" : [ "        \"\"\" Produces sub-boundaries. Starts at bottom left, moves from left to right and then bottom to top.", "        ", "            :param divs: Number of sub-boundaries.", "            :type divs: int", "            :result: A Bounds divided into sub-bounds.", "            :rtype: Bounds", "        ", "        \"\"\"", "        if equalize:", "            divdim = min(self.ival_x.delta / divs, self.ival_y.delta / divs)", "            if self.is_3d: divdim = min(divdim, self.ival_z.delta / divs)", "            divs_x = int(round(self.ival_x.delta/divdim))", "            divs_y = int(round(self.ival_y.delta/divdim))", "            subival_x = self.ival_x // divs_x", "            subival_y = self.ival_y // divs_y", "            if self.is_3d: ", "                divs_z = int(round(self.ival_z.delta/divdim))", "                subival_z = self.ival_z // divs_z", "        else:", "            subival_x = self.ival_x//divs", "            subival_y = self.ival_y//divs", "            if self.is_3d: subival_z = self.ival_z//divs", "        ret = []", "        if self.is_3d:", "            for iz in subival_z:", "                for iy in subival_y:", "                    for ix in subival_x:", "                        ret.append(Bounds(ival_x=ix,ival_y=iy,ival_z=iz))", "        else:", "            for iy in subival_y:", "                for ix in subival_x:", "                    ret.append(Bounds(ival_x=ix,ival_y=iy))", "", "        return ret", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Produces sub-boundaries. Starts at bottom left, moves from left to right and then bottom to top." ],
          "parameters" : {
            "divs" : "Number of sub-boundaries.\n"
          },
          "rtype" : "Bounds",
          "rvalue" : "A Bounds divided into sub-bounds.\n",
          "types" : {
            "divs" : "int\n"
          }
        },
        "end" : 261,
        "name" : "subbounds",
        "start" : 227
      }, {
        "code" : [ "        \"\"\" Returns the closest point within this Bounds.  If the point is already within the bounds and force_project is False, simply returns the point; if force_project is True, the point is projected to the edge of this bounds.", "        ", "            :param p: Point.", "            :type p: Point", "            :result: A Point within this Bounds.", "            :rtype: Point", "            ", "        \"\"\"", "        p = Point(p.x,p.y,p.z)", "        if p in self : ", "            if force_project:", "                dx = self.ival_x.a - p.x if p.x - self.ival_x.a < self.ival_x.b - p.x else self.ival_x.b - p.x", "                dy = self.ival_y.a - p.y if p.y - self.ival_y.a < self.ival_y.b - p.y else self.ival_y.b - p.y", "                dz = self.ival_z.a - p.z if p.z - self.ival_z.a < self.ival_z.b - p.z else self.ival_z.b - p.z", "                ", "                deltas = (abs(dx),abs(dy),abs(dz))", "                mn = deltas.index(min(deltas))", "                if mn == 0: p.x += dx", "                elif mn == 1: p.y += dy", "                else : p.z += dz", "            ", "        else:", "            if p.x < self.ival_x.a : p.x = self.ival_x.a", "            if p.x > self.ival_x.b : p.x = self.ival_x.b", "            if p.y < self.ival_y.a : p.y = self.ival_y.a", "            if p.y > self.ival_y.b : p.y = self.ival_y.b", "        ", "            if self.is_2d: p.z = 0", "            else:", "                if p.z < self.ival_z.a : p.z = self.ival_z.a", "                if p.z > self.ival_z.b : p.z = self.ival_z.b", "        ", "        return p", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns the closest point within this Bounds.  If the point is already within the bounds and force_project is False, simply returns the point; if force_project is True, the point is projected to the edge of this bounds." ],
          "parameters" : {
            "p" : "Point.\n"
          },
          "rtype" : "Point",
          "rvalue" : "A Point within this Bounds.\n",
          "types" : {
            "p" : "Point\n"
          }
        },
        "end" : 296,
        "name" : "near_pt",
        "start" : 263
      }, {
        "code" : [ "        \"\"\" Returns a PLine along the perimeter of a Bounds.", "        ", "            :result: PLine around the Bounds.", "            :rtype: PLine", "            ", "        \"\"\"", "        from .dc_pline import PLine", "        if self.is_2d: return PLine(self.corners+[self.corners[0]])", "        else: " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "Returns a PLine along the perimeter of a Bounds." ],
          "rtype" : "PLine",
          "rvalue" : "PLine around the Bounds.\n"
        },
        "end" : 307,
        "name" : "to_pline",
        "start" : 299
      }, {
        "code" : [ "    def encompass(pts = [Point()]):", "        \"\"\" Constructs a Bounds that encompasses all Points in pts.", "        ", "            :param pts: A list of Points.", "            :type pts: [Point]", "            :result: A Bounds that includes all Points in pts.", "            :rtype: Bounds", "        ", "        \"\"\"", "        ix = Interval.encompass([p.x for p in pts],nudge=True)", "        iy = Interval.encompass([p.y for p in pts],nudge=True)", "        try:", "            iz = Interval.encompass([p.z for p in pts])", "            if not iz: raise", "            return Bounds(ival_x = ix, ival_y = iy, ival_z = iz)", "        except:" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Constructs a Bounds that encompasses all Points in pts." ],
          "parameters" : {
            "pts" : "A list of Points.\n"
          },
          "rtype" : "Bounds",
          "rvalue" : "A Bounds that includes all Points in pts.\n",
          "types" : {
            "pts" : "[Point]\n"
          }
        },
        "end" : 328,
        "name" : "encompass",
        "start" : 313
      }, {
        "code" : [ "    def unit_square(dimension = 1.0, cpt=False):", "        \"\"\" Returns a unit square Bounds (2D) in the xy plane.", "        ", "            :result: Unit square Bounds.", "            :rtype: Bounds", "            ", "        \"\"\"", "        d2 = dimension/2", "        if not cpt: return Bounds(ival_x=Interval(-d2,d2),ival_y=Interval(-d2,d2))", "        return Bounds(ival_x=Interval(cpt.x-d2,cpt.x+d2),ival_y=Interval(cpt.y-d2,cpt.y+d2))", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a unit square Bounds (2D) in the xy plane." ],
          "rtype" : "Bounds",
          "rvalue" : "Unit square Bounds.\n"
        },
        "end" : 343,
        "name" : "unit_square",
        "start" : 333
      }, {
        "code" : [ "    def unit_cube():", "        \"\"\" Returns a unit cube Bounds (3D).", "            ", "            :result: Unit cube Bounds.", "            :rtype: Bounds", "        ", "        \"\"\"", "    ", "        return Bounds(ival_x=Interval(),ival_y=Interval(),ival_z=Interval())", "" ],
        "decorators" : "staticmethod",
        "documentation" : {
          "description" : [ "Returns a unit cube Bounds (3D)." ],
          "rtype" : "Bounds",
          "rvalue" : "Unit cube Bounds.\n"
        },
        "end" : 354,
        "name" : "unit_cube",
        "start" : 345
      } ],
      "documentation" : {
        "description" : [ "A 2d rectangular or 3d cubic boundary class", "axis are oriented to world axis" ]
      },
      "end" : 354,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/core/dc_bounds.py",
      "name" : "Bounds",
      "references" : {
        "classes" : {
          "Bounds" : 10,
          "Geometry" : 1,
          "Interval" : 18,
          "PLine" : 2,
          "Point" : 18,
          "Segment" : 16
        },
        "functions" : {
          "__contains__" : 1,
          "__floordiv__" : 1,
          "__init__" : 1,
          "corners" : 1,
          "cpt" : 1,
          "dim_x" : 1,
          "dim_y" : 1,
          "dim_z" : 1,
          "edges" : 1,
          "encompass" : 1,
          "eval" : 1,
          "is_2d" : 1,
          "is_3d" : 1,
          "near_pt" : 1,
          "overlaps" : 1,
          "scaled" : 1,
          "subbounds" : 1,
          "to_pline" : 1,
          "unit_cube" : 1,
          "unit_square" : 1
        }
      },
      "start" : 6
    },
    "f7dc1d7c-0f69-4fe2-b011-eb328819827f" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "class Web(object):", "    ", "    def __init__(self,prong_a,prong_b,kfs_tup,does_span=False):", "        # a web 'spans' if it crosses over multiple prongs", "        self.does_span = does_span", "        self.knfn, self.frkn, self.spnn = kfs_tup", "        # Rays describing tangency at the endpoints of this Web", "        self.tan_a = prong_a.tangent(0,self.tan_pos) * self.tan_str", "        self.tan_b = prong_b.tangent(1,self.tan_pos) * self.tan_str", "        ", "        ", "    \"\"\"", "    Web Tangents", "    Calculates values for the endpoint locations (expressed as a t-value along adjacent prongs) and tangent strengths for this Web", "    \"\"\"", "    @property", "    def tan_pos(self):", "        t = max(0,(self.frkn/4) - (self.knfn/5) - (self.spnn/5))", "        if self.does_span: t +=  (0.2 * self.frkn)", "        else: t += (0.05 * self.knfn)", "        return t", "        ", "    @property", "    def tan_str(self):", "        # cubic remap of forkiness value to a desired interval", "        t = Interval().remap_to( self.frkn**3, Interval(1,-2) )", "        if self.does_span: t*= self.knfn + 1", "        # scale down the return value", "        return t * 0.15", "    ", "    \"\"\"", "    Web Points", "    Returns points required to construct a bezier curve", "    \"\"\"", "    @property", "    def pts(self):", "        # calculate four points for bezier construction", "        pa = self.tan_a.spt", "        pb = self.tan_b.spt", "        pa_tan = pa + self.tan_a.vec", "        pb_tan = pb + self.tan_b.vec", "        return [ pa, pa_tan, pb_tan, pb ]", "        ", "    \"\"\"", "    Web Outline", "    Draws a bezier curve through this prong's points", "    \"\"\"", "    @property", "    def outline(self): ", "        return Curve.bezier(self.pts)", "        ", "        ", "    \"\"\"", "    [noprint]", "    \"\"\"", "    @property", "    def outline_highres(self):", "        crv = Curve.bezier(self.pts(n))", "        crv.tol = 0.01", "        return crv", "" ],
          "end" : 73,
          "start" : 13
        },
        "description" : "\nWeb Class\nA class that creates a Web object between two Prongs\n",
        "end" : 13,
        "start" : 10
      } ],
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p4/Exploration/A Design Space of Flatware/4.04.L02b.py",
      "name" : "4.04.L02b.py",
      "references" : {
        "classes" : {
          "Curve" : 2,
          "Interval" : 2,
          "Web" : 1
        }
      }
    },
    "f91d51b6-77cd-4178-8d93-2cae60695499" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_2d.py",
      "definitions" : [ {
        "code" : [ "    def _base_pts(self):", "        ", "        return [ ", "            Point(1+tau**2, 0.0)," ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 236,
        "name" : "_base_pts",
        "start" : 233
      }, {
        "code" : [ "        # TileA0 has its origin CS on _base_pts[10], the XAxis points towards _base_pts[0], and the YAxis points towards _base_pts[5]", "        cs = self._cs_from_base_pts(10,0,5)", "        # Create a TileA0 on the new CS and scale it down", "        a0 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a0\")", "        ", "        # TileA1 has its origin CS on _base_pts[2], the XAxis points towards _base_pts[3], and the YAxis points towards _base_pts[7]", "        cs = self._cs_from_base_pts(2,3,7)", "        # Create a TileA1 on the new CS and scale it down", "        a1 = AmmannA3TileA(self.xf * cs.xform * self._xf_scale,self.lineage+\",a1\")", "               ", "        # TileC0 has its origin CS on _base_pts[11], the XAxis points towards _base_pts[5], and the YAxis points towards _base_pts[10]", "        cs = self._cs_from_base_pts(11,5,10)", "        # Create a TileC0 on the new CS and scale it down", "        c0 = AmmannA3TileC(self.xf * cs.xform * self._xf_scale,self.lineage+\",c0\")", "        ", "        return [a0,a1,c0]", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 268,
        "name" : "inflate",
        "start" : 252
      }, {
        "code" : [ "        pg = PGon(self.base_pts[:10])", "        pg.name = self.lineage", "        return pg", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 274,
        "name" : "to_pgon",
        "start" : 271
      }, {
        "code" : [ "        pg = [Segment(self.base_pts[0],self.base_pts[5]),Segment(self.base_pts[8],self.base_pts[3])]", "        return pg", "\"\"\"" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 278,
        "name" : "to_lines",
        "start" : 276
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 278,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_2d.py",
      "name" : "AmmannA3TileC",
      "references" : {
        "classes" : {
          "AmmannA3Tile" : 1,
          "AmmannA3TileA" : 2,
          "AmmannA3TileC" : 2,
          "PGon" : 1,
          "Point" : 12,
          "Segment" : 2
        },
        "functions" : {
          "_base_pts" : 1,
          "inflate" : 1,
          "to_lines" : 1,
          "to_pgon" : 1
        }
      },
      "start" : 231
    },
    "fa2b36f1-b7ae-44c0-a8e3-da2a9951e3ac" : {
      "documentation" : {
        "description" : [ "2.03.E01a" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p2/03-Collections/2.03.E01 - Monsters/2.03.E01a.py",
      "name" : "2.03.E01a.py"
    },
    "fc1bac18-55e3-4d2e-8c36-175bc1e0a25d" : {
      "definedIn" : "/Users/nicschumann/Work-Space/decod.es/test/decodes/extensions/tiling_danzer.py",
      "definitions" : [ {
        "code" : [ "        #lineage, tracks tile types of ancestors", "        self.lineage = kargs[\"lineage\"] if \"lineage\" in kargs else \"RT\" ", "        #recursion level, sets the scale of tiles", "        self.rlvl = kargs[\"rlvl\"] if \"rlvl\" in kargs else 0 ", "        #the spatial transformation of this tile", "        self.xf = kargs[\"xf\"] if \"xf\" in kargs else Xform() ", "        #determines if this tile is mirrored", "        self.flip = kargs[\"flip\"] if \"flip\" in kargs else False", "        " ],
        "decorators" : "constructor",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 53,
        "name" : "__init__",
        "start" : 45
      }, {
        "code" : [ "    def tile_pts(self):", "        # a scaling factor based upon this tile's recursion level", "        factor = tau_pow[self.rlvl]", "        xf_scale = Xform.scale(factor)", "        # return an world-space copy of each base_pt ", "        return map(lambda pt:(pt*xf_scale)*self.xf,self._base_pts)", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 64,
        "name" : "tile_pts",
        "start" : 58
      }, {
        "code" : [ "        # construct a world-space cs of the desired child tile", "        cs_tile = CS()*Xform.change_basis(cs_chld,cs_self)*self.xf", "        # the transformation from world origin to this cs", "        xf = cs_tile.xform", "        if flip : xf = xf * Xform.mirror()", "        # set the recursion level to one more than this tile", "        rl = self.rlvl + 1", "        # construct the lineage string", "        l = self.lineage+\",\"+name", "        f = flip", "        ", "        # return a child tile of the desired type", "        if name.startswith(\"A\"): return DzTileA(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"B\"): return DzTileB(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"C\"): return DzTileC(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"K\"): return DzTileK(xf=xf,rlvl=rl,lineage=l,flip=f)", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 85,
        "name" : "child_by_explicit",
        "start" : 69
      }, {
        "code" : [ "        return self.child_by_explicit(tile_chld,CS(),cs_self,flip)", "    " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 91,
        "name" : "child_by_base",
        "start" : 90
      }, {
        "code" : [ "        # construct the transformation of the desired child tile by mirroring", "        xf = Xform.mirror(cs_mir) * self.xf", "        # prepare other required arguments by modifying this tile's properties", "        rl = self.rlvl", "        l = self.lineage[:-2]+name", "        f = not self.flip", "        ", "        # return a child tile of the desired type", "        if name.startswith(\"A\"): return DzTileA(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"B\"): return DzTileB(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"C\"): return DzTileC(xf=xf,rlvl=rl,lineage=l,flip=f)", "        if name.startswith(\"K\"): return DzTileK(xf=xf,rlvl=rl,lineage=l,flip=f)", "        raise", "        " ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 110,
        "name" : "sibling_by_mirror",
        "start" : 97
      }, {
        "code" : [ "    def cs_by_base_pts(cls,rlvl,pt_o,pt_x,pt_y,flip=False):", "        # scale the base points to the proper size for this rlvl", "        factor = tau_pow[rlvl]", "        pts = [pt*factor for pt in cls._base_pts]", "        ", "        # to orient to flipped tiles, simply invert the apex point", "        if flip : pts[3] = Point(pts[3].x,pts[3].y,-pts[3].z)", "        # construct and return the desired coordinate system", "        return CS(pts[pt_o],pts[pt_x]-pts[pt_o],pts[pt_y]-pts[pt_o])", "" ],
        "decorators" : "classmethod",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 124,
        "name" : "cs_by_base_pts",
        "start" : 115
      }, {
        "code" : [ "        # construct and return the desired coordinate system", "        pts = self.tile_pts", "        return CS(pts[pt_o],pts[pt_x]-pts[pt_o],pts[pt_y]-pts[pt_o])", "" ],
        "decorators" : "method",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 129,
        "name" : "cs_by_tile_pts",
        "start" : 126
      }, {
        "code" : [ "    def to_mesh(self):", "        msh = Mesh()", "        for v in self.tile_pts : msh.append(v)", "        if self.flip : ", "            msh.add_face(0,1,2)", "            msh.add_face(1,3,2)", "            msh.add_face(2,3,0)", "            msh.add_face(3,1,0)", "        else :", "            msh.add_face(0,2,1)", "            msh.add_face(1,2,3)", "            msh.add_face(2,0,3)", "            msh.add_face(3,0,1)", "        return msh", "        " ],
        "decorators" : "property",
        "documentation" : {
          "description" : [ "null" ]
        },
        "end" : 148,
        "name" : "to_mesh",
        "start" : 134
      } ],
      "documentation" : {
        "description" : [ "null" ]
      },
      "end" : 148,
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/decodes/extensions/tiling_danzer.py",
      "name" : "DzTile",
      "references" : {
        "classes" : {
          "CS" : 4,
          "DzTile" : 1,
          "DzTileA" : 2,
          "DzTileB" : 2,
          "DzTileC" : 2,
          "DzTileK" : 2,
          "Mesh" : 1,
          "Point" : 1,
          "Xform" : 5
        },
        "functions" : {
          "__init__" : 1,
          "child_by_base" : 1,
          "child_by_explicit" : 1,
          "cs_by_base_pts" : 1,
          "cs_by_tile_pts" : 1,
          "sibling_by_mirror" : 1,
          "tile_pts" : 1,
          "to_mesh" : 1
        }
      },
      "start" : 43
    },
    "fcb11e42-2405-405d-94fa-c3aae4f3de2c" : {
      "blocks" : [ {
        "code" : {
          "content" : [ "theta = math.radians(angle)", "c = cos(theta)", "s = sin(theta)", "v_1 = Vec(c, s)", "v_2 = Vec(-s, c)", "" ],
          "end" : 21,
          "start" : 15
        },
        "description" : "\nOrthonormal Basis in 2D\nComputes an orthonormal basis that is a rotation of the standard basis\n",
        "end" : 15,
        "start" : 12
      }, {
        "code" : {
          "content" : [ "v = Vec(origin, pt_world)", "coord_1 = v.dot(v_1)", "coord_2 = v.dot(v_2)", "" ],
          "end" : 28,
          "start" : 25
        },
        "description" : "\nBasis Coordinates\nCalculates coordinates in the orthonormal basis\n",
        "end" : 25,
        "start" : 22
      } ],
      "documentation" : {
        "description" : [ "3.02.E02b", "todo" ]
      },
      "giturl" : "https://github.com/ksteinfe/decodes/blob/master/examples/p3/Vector/Projections/3.02.E02b.py",
      "name" : "3.02.E02b.py",
      "references" : {
        "classes" : {
          "Vec" : 3
        }
      }
    }
  },
  "names" : {
    "AmmannA3Tile" : "decodes/extensions/ammann-a3tile",
    "AmmannA3TileA" : "decodes/extensions/ammann-a3tile-a",
    "AmmannA3TileB" : "decodes/extensions/ammann-a3tile-b",
    "AmmannA3TileC" : "decodes/extensions/ammann-a3tile-c",
    "Arc" : "decodes/core/arc",
    "Basis" : "decodes/core/basis",
    "BasisError" : "decodes/core/basis-error",
    "Bin" : "decodes/extensions/bin",
    "BoolField" : "decodes/core/bool-field",
    "Bounds" : "decodes/core/bounds",
    "CA" : "decodes/extensions/ca",
    "CS" : "decodes/core/cs",
    "Circle" : "decodes/core/circle",
    "ClassicalSurface" : "decodes/extensions/classical-surface",
    "Color" : "decodes/core/color",
    "Curve" : "decodes/core/curve",
    "CylCS" : "decodes/core/cyl-cs",
    "DanzerAxiom" : "decodes/extensions/danzer-axiom",
    "DomainError" : "decodes/core/domain-error",
    "DzTile" : "decodes/extensions/dz-tile",
    "DzTileA" : "decodes/extensions/dz-tile-a",
    "DzTileB" : "decodes/extensions/dz-tile-b",
    "DzTileC" : "decodes/extensions/dz-tile-c",
    "DzTileK" : "decodes/extensions/dz-tile-k",
    "GeometricError" : "decodes/core/geometric-error",
    "Geometry" : "decodes/core/geometry",
    "Graph" : "decodes/core/graph",
    "GrayScott" : "decodes/extensions/gray-scott",
    "Grid" : "decodes/core/grid",
    "HasBasis" : "decodes/core/has-basis",
    "HasPts" : "decodes/core/has-pts",
    "Image" : "decodes/core/image",
    "Intersector" : "decodes/core/intersector",
    "Interval" : "decodes/core/interval",
    "IsParametrized" : "decodes/core/is-parametrized",
    "LEngine" : "decodes/extensions/lengine",
    "LTurtle" : "decodes/extensions/lturtle",
    "Line" : "decodes/core/line",
    "LinearEntity" : "decodes/core/linear-entity",
    "Mesh" : "decodes/core/mesh",
    "PGon" : "decodes/core/pgon",
    "PLine" : "decodes/core/pline",
    "PinwheelTile" : "decodes/extensions/pinwheel-tile",
    "Plane" : "decodes/core/plane",
    "Point" : "decodes/core/point",
    "Poisson_Sampler" : "decodes/extensions/poisson_sampler",
    "QuadTree" : "decodes/core/quad-tree",
    "RGon" : "decodes/core/rgon",
    "Raster" : "decodes/core/raster",
    "Ray" : "decodes/core/ray",
    "RotationalSurface" : "decodes/extensions/rotational-surface",
    "Segment" : "decodes/core/segment",
    "ShearedCS" : "decodes/core/sheared-cs",
    "SolarGeom" : "decodes/extensions/solar-geom",
    "SpatialGraph" : "decodes/core/spatial-graph",
    "Strip" : "decodes/extensions/strip",
    "Surface" : "decodes/core/surface",
    "Torus" : "decodes/extensions/torus",
    "TranslationalSurface" : "decodes/extensions/translational-surface",
    "Tri" : "decodes/core/tri",
    "ValueField" : "decodes/core/value-field",
    "Vec" : "decodes/core/vec",
    "VecField" : "decodes/core/vec-field",
    "VoxelField" : "decodes/extensions/voxel-field",
    "Xform" : "decodes/core/xform",
    "_parse_epw_line" : "decodes/extensions/_parse_epw_line",
    "bin_polygons" : "decodes/extensions/bin_polygons",
    "bin_strips" : "decodes/extensions/bin_strips",
    "epw_metadata" : "decodes/extensions/epw_metadata",
    "extract_polygons" : "decodes/extensions/extract_polygons",
    "extract_strips" : "decodes/extensions/extract_strips",
    "inflationA" : "decodes/extensions/inflation-a",
    "inflationB" : "decodes/extensions/inflation-b",
    "inflationC" : "decodes/extensions/inflation-c",
    "inflationK" : "decodes/extensions/inflation-k",
    "parse_epw_file" : "decodes/extensions/parse_epw_file",
    "rand_points" : "decodes/extensions/rand_points",
    "sort_polygons" : "decodes/extensions/sort_polygons"
  },
  "schema" : {
    "decodes" : {
      "core" : {
        "arc" : {
          "key" : "3a3ad470-f5a0-4f38-95fb-326b6de431e5",
          "timestamp" : 1472136379671
        },
        "basis" : {
          "key" : "9976cd54-4fe1-4c9b-925e-5240a6dff1e5",
          "timestamp" : 1472654795956
        },
        "basis-error" : {
          "key" : "649d7a37-f31c-4119-a956-65cf6b998eca",
          "timestamp" : 1472136379699
        },
        "bool-field" : {
          "key" : "aad2a907-e99c-4d06-ad78-d9f4231d3399",
          "timestamp" : 1472136379607
        },
        "bounds" : {
          "key" : "f7962d15-36e2-43f5-b81a-67a88464e2e2",
          "timestamp" : 1472136379653
        },
        "circle" : {
          "key" : "72d39dd0-9532-4804-94d6-92d9fcfd426d",
          "timestamp" : 1472136379673
        },
        "color" : {
          "key" : "3bf2bbb0-20fb-4419-b8e9-533f46edff81",
          "timestamp" : 1472136379690
        },
        "cs" : {
          "key" : "b4047e9e-4be0-4235-be87-3b664c972820",
          "timestamp" : 1472657111867
        },
        "curve" : {
          "key" : "6b68ab61-9334-4e8d-b75d-1e4d6a22e7da",
          "timestamp" : 1472136379643
        },
        "cyl-cs" : {
          "key" : "a67deb05-f041-4d2a-978d-39ee5e26e6ec",
          "timestamp" : 1472657111705
        },
        "domain-error" : {
          "key" : "72c5087e-7e0e-41ef-ac85-df10a815a8da",
          "timestamp" : 1472136379697
        },
        "geometric-error" : {
          "key" : "c88339d1-1387-4ef7-8171-3b651255b3f0",
          "timestamp" : 1472136379699
        },
        "geometry" : {
          "key" : "2b98b12f-989b-4d5a-91d8-e9915f0d7bb3",
          "timestamp" : 1472655880867
        },
        "graph" : {
          "key" : "73921ff2-c76c-4ebd-be56-9de73b868e51",
          "timestamp" : 1472136379677
        },
        "grid" : {
          "key" : "7af81b78-3d96-43f9-abe0-2b8d476f49a9",
          "timestamp" : 1472136379666
        },
        "has-basis" : {
          "key" : "0faaa90f-90c9-4ebd-8d38-af6cc17b0b00",
          "timestamp" : 1472654795911
        },
        "has-pts" : {
          "key" : "6fa59137-b953-458d-8954-9ebf32b78052",
          "timestamp" : 1472136379594
        },
        "image" : {
          "key" : "68f42b62-bc41-43a7-b632-2cc7f73a2f50",
          "timestamp" : 1472136379609
        },
        "intersector" : {
          "key" : "9153bb36-b8bf-46e8-9eb1-538dbabcf8c9",
          "timestamp" : 1472136379590
        },
        "interval" : {
          "key" : "7972c149-8f53-4e6b-a56d-8ca891da62ef",
          "timestamp" : 1472136379592
        },
        "is-parametrized" : {
          "key" : "f5094255-27a0-45f2-be6b-7ef0db4fa4b0",
          "timestamp" : 1472136379651
        },
        "line" : {
          "key" : "5143ba72-3bd1-4019-bf4d-acd38197782c",
          "timestamp" : 1472136379599
        },
        "linear-entity" : {
          "key" : "f024beb1-3890-40db-83b8-9ad6b7ab84a5",
          "timestamp" : 1472136379600
        },
        "mesh" : {
          "key" : "bd1ae758-6429-449d-b4d3-517a3c8ebc2b",
          "timestamp" : 1472136379604
        },
        "pgon" : {
          "key" : "5153aebb-c7d7-46fd-a66e-73daf79a6b82",
          "timestamp" : 1472136379603
        },
        "plane" : {
          "key" : "9a60c79a-d278-4651-805d-4c0bb0ccf68f",
          "timestamp" : 1472136379604
        },
        "pline" : {
          "key" : "c0f6a294-85e1-4f9a-b39d-67a9611621c9",
          "timestamp" : 1472136379605
        },
        "point" : {
          "key" : "56b2646b-aae4-4b61-8c2b-97808a5f3c1e",
          "timestamp" : 1472136379605
        },
        "quad-tree" : {
          "key" : "ebcbe674-9f2f-49f2-a3ca-78ae331d057c",
          "timestamp" : 1472136379652
        },
        "raster" : {
          "key" : "aa9a3e35-4476-4c4a-a60a-c8710e0f4303",
          "timestamp" : 1472136379609
        },
        "ray" : {
          "key" : "abe49815-49a3-40a5-bf35-31b964a14096",
          "timestamp" : 1472136379598
        },
        "rgon" : {
          "key" : "1c6aec26-e7ad-4151-b4cf-003924d9b256",
          "timestamp" : 1472136379601
        },
        "segment" : {
          "key" : "ef013d53-a664-4652-8633-45fdf8c22880",
          "timestamp" : 1472136379596
        },
        "sheared-cs" : {
          "key" : "99b5a289-80b8-4b6f-a87f-eb5187f404ec",
          "timestamp" : 1472657111707
        },
        "spatial-graph" : {
          "key" : "a0cc8ea4-cb92-4f7b-944a-ef9c5c129a3c",
          "timestamp" : 1472136379675
        },
        "surface" : {
          "key" : "c2560781-2f12-4af8-9656-b03a9261e157",
          "timestamp" : 1472136379603
        },
        "tri" : {
          "key" : "03afcdb9-82ab-40b4-871f-58bab72680a7",
          "timestamp" : 1472136379628
        },
        "value-field" : {
          "key" : "77e03946-f01c-4da0-9c47-56b04e38eb84",
          "timestamp" : 1472136379608
        },
        "vec" : {
          "key" : "4bb7ced7-e52a-4b93-aec9-06ea751456d1",
          "timestamp" : 1472136379611
        },
        "vec-field" : {
          "key" : "349726cd-e94d-4b1c-8779-f0fe809ad78e",
          "timestamp" : 1472136379665
        },
        "xform" : {
          "key" : "0d036d4a-464c-49c9-ba4a-0ce8332b35eb",
          "timestamp" : 1472136379616
        }
      },
      "extensions" : {
        "_parse_epw_line" : {
          "key" : "d7d3185a-e90b-4281-a764-d64fe7df1f0e",
          "timestamp" : 1472136385018
        },
        "ammann-a3tile" : {
          "key" : "668c9a36-37b4-44c1-a106-83c33862029c",
          "timestamp" : 1472136384856
        },
        "ammann-a3tile-a" : {
          "key" : "36f66172-1946-4d37-83d9-603c9377807e",
          "timestamp" : 1472136384856
        },
        "ammann-a3tile-b" : {
          "key" : "190c2ceb-9163-4984-a92f-6d273df55bf0",
          "timestamp" : 1472136384856
        },
        "ammann-a3tile-c" : {
          "key" : "f91d51b6-77cd-4178-8d93-2cae60695499",
          "timestamp" : 1472136384855
        },
        "bin" : {
          "key" : "2197b9be-5a67-4cac-b941-16f72d065671",
          "timestamp" : 1472136384962
        },
        "bin_polygons" : {
          "key" : "abe0bd3a-8f2a-429b-98e9-e138bfdeb5b1",
          "timestamp" : 1472136384960
        },
        "bin_strips" : {
          "key" : "e773874a-37a4-4b36-9f72-ba5a9774df3a",
          "timestamp" : 1472136384963
        },
        "ca" : {
          "key" : "29ba5ec5-6718-442e-8d65-60e626216c50",
          "timestamp" : 1472136385023
        },
        "classical-surface" : {
          "key" : "ac97baf8-1c35-4685-9358-84b5838018fd",
          "timestamp" : 1472136385018
        },
        "danzer-axiom" : {
          "key" : "383a67e4-0baa-4be3-873f-4e54e2273510",
          "timestamp" : 1472136384751
        },
        "dz-tile" : {
          "key" : "fc1bac18-55e3-4d2e-8c36-175bc1e0a25d",
          "timestamp" : 1472136384853
        },
        "dz-tile-a" : {
          "key" : "d6a94c19-7ba3-48cd-ae45-c01ef886da67",
          "timestamp" : 1472136384799
        },
        "dz-tile-b" : {
          "key" : "8937b4b1-6b26-44a3-af7b-f717b3d40761",
          "timestamp" : 1472136384798
        },
        "dz-tile-c" : {
          "key" : "8a8b1614-a301-4d4d-b174-6239b7d623e3",
          "timestamp" : 1472136384798
        },
        "dz-tile-k" : {
          "key" : "241514d1-37f4-4ec0-8712-0a2c0311d3a1",
          "timestamp" : 1472136384797
        },
        "epw_metadata" : {
          "key" : "f7444f5c-ed2d-4993-bf0d-fd29f2e2ccd3",
          "timestamp" : 1472136385020
        },
        "extract_polygons" : {
          "key" : "afcbc118-8bd4-41a4-b98b-620b238c328d",
          "timestamp" : 1472136384915
        },
        "extract_strips" : {
          "key" : "a3b0c795-a2b2-4d99-802c-ceab6788cdf0",
          "timestamp" : 1472136384963
        },
        "gray-scott" : {
          "key" : "32da1c12-d73e-4c63-a94d-45bcdc6f4d3c",
          "timestamp" : 1472136384913
        },
        "inflation-a" : {
          "key" : "7401387a-0037-4b0d-9bd2-720c35570643",
          "timestamp" : 1472136384749
        },
        "inflation-b" : {
          "key" : "c636a2a7-7659-4eaf-ae94-22c52eceb026",
          "timestamp" : 1472136384748
        },
        "inflation-c" : {
          "key" : "0497db93-8bc3-4430-88ac-c23eff7e550f",
          "timestamp" : 1472136384746
        },
        "inflation-k" : {
          "key" : "410136f5-6875-4957-b04d-eeae54500e44",
          "timestamp" : 1472136384745
        },
        "lengine" : {
          "key" : "dafba134-c885-44c2-81df-9a7b88b9ad94",
          "timestamp" : 1472136385021
        },
        "lturtle" : {
          "key" : "df061dec-0da7-4633-bb9a-1d8b5d9bac44",
          "timestamp" : 1472136385020
        },
        "parse_epw_file" : {
          "key" : "8818c332-72ee-4ebc-b812-4f3b4db3f0d9",
          "timestamp" : 1472136385019
        },
        "pinwheel-tile" : {
          "key" : "68662f7f-8359-4dc1-9c73-9048e802b9e0",
          "timestamp" : 1472136384907
        },
        "poisson_sampler" : {
          "key" : "657c2d72-4d9e-4188-bcb8-7d8ad9fbeca9",
          "timestamp" : 1472136384967
        },
        "rand_points" : {
          "key" : "483eaf35-f39e-40b2-877c-6c370e3d3999",
          "timestamp" : 1472136384914
        },
        "rotational-surface" : {
          "key" : "7631acbc-2f89-4a7b-91a8-72b09e48e1d5",
          "timestamp" : 1472136385016
        },
        "solar-geom" : {
          "key" : "b9383ccd-07a3-42c8-8150-9c06537f6006",
          "timestamp" : 1472136384965
        },
        "sort_polygons" : {
          "key" : "0041d2fb-bb87-4bc8-b9c8-85d54d47f418",
          "timestamp" : 1472136384961
        },
        "strip" : {
          "key" : "39926ffe-38d7-4465-9c93-98e39f66c605",
          "timestamp" : 1472136384964
        },
        "torus" : {
          "key" : "bca32d18-04f4-4213-a129-e7eb7353a39e",
          "timestamp" : 1472136384968
        },
        "translational-surface" : {
          "key" : "b63f9b18-8e18-4cf6-a030-5a1882c4d19f",
          "timestamp" : 1472136385015
        },
        "voxel-field" : {
          "key" : "b0a50aa4-188c-4047-ae70-67211032b6c2",
          "timestamp" : 1472136384910
        }
      }
    },
    "examples" : {
      "p2" : {
        "01-elements" : {
          "2-01-e00---noghx" : {
            "2-01-e00a-py" : {
              "key" : "0fffb31f-73c5-4bd8-8b18-2f6d4fd03798",
              "timestamp" : 1472136361495
            }
          },
          "2-01-e01---amuse-bouche" : {
            "2-01-e01a-py" : {
              "key" : "51d4683b-ef3b-4cad-bf1c-8bc4a6e65860",
              "timestamp" : 1472136361493
            },
            "2-01-e01b-py" : {
              "key" : "55e8acc2-c202-43cb-926b-b8d64b865f68",
              "timestamp" : 1472136361492
            },
            "2-01-e01c-py" : {
              "key" : "e1f99e2e-c7af-4651-9af2-e987b1a59a44",
              "timestamp" : 1472136361489
            },
            "2-01-e01d-py" : {
              "key" : "ba629dbb-6924-4116-9692-333759b685e8",
              "timestamp" : 1472136361448
            },
            "2-01-e01e-py" : {
              "key" : "3f2787f7-741a-47f3-8d69-0e38b22fbb18",
              "timestamp" : 1472136361446
            },
            "2-01-e01f-py" : {
              "key" : "3a3adcfe-22b9-44db-8979-800ea9993468",
              "timestamp" : 1472136361442
            },
            "2-01-e01g-py" : {
              "key" : "cd09b325-1bc2-498c-960c-78ade5f7d9ba",
              "timestamp" : 1472136361438
            },
            "2-01-e01h-py" : {
              "key" : "d1a5bb51-5100-4b3f-ab8d-f63c03c14710",
              "timestamp" : 1472136367744
            }
          },
          "2-01-e02---attractors" : {
            "2-01-e02a-py" : {
              "key" : "e8aa7b01-9c30-4876-b15f-742e84ceab61",
              "timestamp" : 1472136367743
            }
          }
        },
        "03-collections" : {
          "2-03-e00---noghx" : {
            "2-03-e00a-py" : {
              "key" : "08820db3-070f-4a3e-b21b-55602763bb28",
              "timestamp" : 1472136367741
            },
            "2-03-e00b-py" : {
              "key" : "8c03702c-9539-450d-af47-f20c64e9b167",
              "timestamp" : 1472136367742
            },
            "2-03-e00c-py" : {
              "key" : "e35e04c0-65ce-47b6-8804-0d8c236f3f4b",
              "timestamp" : 1472136367520
            }
          },
          "2-03-e01---monsters" : {
            "2-03-e01a-py" : {
              "key" : "fa2b36f1-b7ae-44c0-a8e3-da2a9951e3ac",
              "timestamp" : 1472136367517
            }
          },
          "2-03-e02---fractals" : {
            "2-03-e02a-py" : {
              "key" : "8a089c7b-766e-435e-ba6a-a60f7bb52134",
              "timestamp" : 1472136367521
            }
          }
        },
        "loose-examples" : {
          "2-xx-xx---spirograph" : {
            "2-e02a-py" : {
              "key" : "981c6345-899d-4358-a164-8f1cb78dd8f6",
              "timestamp" : 1472136367271
            },
            "2-e02b-py" : {
              "key" : "9da593db-462e-4afa-8fec-2778ae8ec3e9",
              "timestamp" : 1472136367272
            },
            "2-e02c-py" : {
              "key" : "f1335b83-ff87-4248-9834-eb7be3f53b4b",
              "timestamp" : 1472136367518
            },
            "2-e02d-py" : {
              "key" : "4279e637-f83c-41f2-b578-ac5f3282c47f",
              "timestamp" : 1472136367519
            }
          }
        }
      },
      "p3" : {
        "collection" : {
          "-manipulating-bases" : {
            "3-08-e01a-py" : {
              "key" : "28d8204f-be17-4d22-880b-001e71503ebf",
              "timestamp" : 1472136367275
            },
            "3-08-e01b-py" : {
              "key" : "179f31a0-4bbf-465d-a378-78d5357b9d5a",
              "timestamp" : 1472136367277
            }
          },
          "noghx" : {
            "3-08-e00a-py" : {
              "key" : "15a90654-5abb-44e9-a82c-beaf9111e8a1",
              "timestamp" : 1472136367276
            },
            "3-08-e00b-py" : {
              "key" : "6c125650-7cba-468b-8d30-1f561d1e488b",
              "timestamp" : 1472136366922
            },
            "3-08-e00c-py" : {
              "key" : "da0eb7f5-9bda-4573-bfc9-1f04fd936daf",
              "timestamp" : 1472136366928
            },
            "3-08-e00d-py" : {
              "key" : "6aedaea7-3736-4c37-9124-f8fb79d330ed",
              "timestamp" : 1472136366934
            }
          }
        },
        "curve" : {
          "curve-basics" : {
            "3-07-e01a-py" : {
              "key" : "4efdd3c9-ce90-4b5b-acb4-21cc6e6d6ee0",
              "timestamp" : 1472660868381
            },
            "3-07-e01c-py" : {
              "key" : "e097a83a-090f-4859-945b-20974462fd4f",
              "timestamp" : 1472660868322
            },
            "3-07-e01d-py" : {
              "key" : "89e927d8-e7ee-41fc-9715-6b1f891b4e93",
              "timestamp" : 1472660868356
            }
          },
          "geometric-properties" : {
            "3-07-e03a-py" : {
              "key" : "a2c43be3-f25d-4383-aee5-4972ba3a4902",
              "timestamp" : 1472660868436
            },
            "3-07-e03b-py" : {
              "key" : "4b80538d-4f1b-490f-9f8b-15dffec461a0",
              "timestamp" : 1472660868435
            },
            "3-07-e03c-py" : {
              "key" : "695a838b-51c7-4c8d-9ed8-e96431dbdf2e",
              "timestamp" : 1472660868434
            },
            "3-07-e03d-py" : {
              "key" : "de535338-8e8b-4f6f-b192-ba6e280f5339",
              "timestamp" : 1472660868433
            }
          },
          "parametrization" : {
            "3-07-e02a-py" : {
              "key" : "a905157b-5587-496a-a885-dd7f3c88cf82",
              "timestamp" : 1472660868377
            },
            "3-07-e02b-py" : {
              "key" : "9ff370b0-724b-4ab8-938b-0fdf26ed30c5",
              "timestamp" : 1472660868420
            },
            "3-07-e02c-py" : {
              "key" : "d684bad3-5c14-438b-b571-dce5a47e92b8",
              "timestamp" : 1472660868417
            }
          }
        },
        "line" : {
          "guilloche" : {
            "3-03-e01a-py" : {
              "key" : "9bc4e48e-eb89-48d3-be5f-e272e0434cef",
              "timestamp" : 1472136366299
            },
            "3-03-e01b-py" : {
              "key" : "a69513b0-5772-471a-88f8-eaa5483103aa",
              "timestamp" : 1472136366300
            },
            "3-03-e01c-py" : {
              "key" : "8c8f1a4d-82bc-4ef3-b95f-5fdbfe87a498",
              "timestamp" : 1472136366301
            }
          }
        },
        "plane" : {
          "noghx" : {
            "3-05-e00a-py" : {
              "key" : "c049ebbd-e4c1-47af-9ac4-ad4631e8c10c",
              "timestamp" : 1472664806417
            }
          }
        },
        "surface" : {
          "classical-surfaces" : {
            "3-09-e02a-py" : {
              "key" : "aa8b4082-d8ea-495a-bc46-3a8b50eb6c3d",
              "timestamp" : 1472136366302
            },
            "3-09-e02b-py" : {
              "key" : "906cc42d-2138-44d2-a558-45afd163bf6b",
              "timestamp" : 1472136366303
            },
            "3-09-e02c-py" : {
              "key" : "9b26c70f-db44-4bfc-b955-cbd16ef0a12c",
              "timestamp" : 1472136366304
            }
          },
          "surface-basics" : {
            "3-09-e01a-py" : {
              "key" : "c8ac1485-4427-432a-b984-2dbf80a249f8",
              "timestamp" : 1472136366017
            },
            "3-09-e01c-py" : {
              "key" : "56db18c2-638e-40ff-80aa-dabecc7bf332",
              "timestamp" : 1472136366022
            },
            "3-09-e01d-py" : {
              "key" : "78f5c5a0-df6f-4cdd-9a31-6efef1779edd",
              "timestamp" : 1472136366027
            }
          }
        },
        "vector" : {
          "cross-products" : {
            "3-02-e01a-py" : {
              "key" : "2563cc37-4c63-404f-a848-b029768407c2",
              "timestamp" : 1472136365756
            },
            "3-02-e01b-py" : {
              "key" : "92da57c6-f031-41f4-820e-bce66bbdd9db",
              "timestamp" : 1472136365763
            },
            "3-02-e01c-py" : {
              "key" : "38a66203-5624-44bf-9a47-f0b42055a7bb",
              "timestamp" : 1472136365790
            }
          },
          "noghx" : {
            "3-02-e00a-py" : {
              "key" : "1cb6a4fe-810b-402a-b67b-4b09871d637c",
              "timestamp" : 1472136366021
            }
          },
          "projections" : {
            "3-02-e02a-py" : {
              "key" : "1ce8b7e5-819f-49a0-a1a6-1a730843324f",
              "timestamp" : 1472136366021
            },
            "3-02-e02b-py" : {
              "key" : "fcb11e42-2405-405d-94fa-c3aae4f3de2c",
              "timestamp" : 1472136365517
            }
          }
        }
      },
      "p4" : {
        "aggregation" : {
          "aranda-lasch-fractal" : {
            "4-01-f01a-py" : {
              "key" : "ad9bc2de-6f12-4681-bdfd-b9256024ee70",
              "timestamp" : 1472136366024
            },
            "4-01-f01b-py" : {
              "key" : "d04411f3-a695-4d3f-a019-778149c4a4db",
              "timestamp" : 1472136365792
            },
            "4-01-f01c-py" : {
              "key" : "639c8e3f-2300-4eb9-b4be-3fb4716702b5",
              "timestamp" : 1472136365457
            },
            "4-01-f01d-py" : {
              "key" : "cc373816-4619-4c2c-928f-7c8df23ee673",
              "timestamp" : 1472136365794
            }
          },
          "danzer-tiling" : {
            "4-01-l05a-py" : {
              "key" : "222695b7-edb6-4648-89bf-5c4d397aa800",
              "timestamp" : 1472136365515
            },
            "4-01-l05b-py" : {
              "key" : "4814d02c-69fc-44b2-854a-ea44e4fb33a2",
              "timestamp" : 1472136365219
            }
          },
          "dla" : {
            "4-01-l06a-py" : {
              "key" : "36e3b3ec-071d-4086-88f1-b7a75d4b23ea",
              "timestamp" : 1472136365458
            },
            "4-01-l06b-py" : {
              "key" : "355f2ab4-2bae-485c-a1b0-f6a9ad51e576",
              "timestamp" : 1472136365517
            }
          },
          "dressed-tilings" : {
            "4-01-l02a-py" : {
              "key" : "a8f05694-b16a-488f-94b8-e86dd80241ab",
              "timestamp" : 1472136365217
            },
            "4-01-l02b-py" : {
              "key" : "3089a4b5-dbe1-47f9-aa18-de55c3f3fa22",
              "timestamp" : 1472136365218
            }
          },
          "escher-tessellation" : {
            "4-01-l03a-py" : {
              "key" : "cb62ff7a-143b-4517-b130-e543cd30005b",
              "timestamp" : 1472136365214
            },
            "4-01-l03b-py" : {
              "key" : "1ab6abcd-cd3d-417e-9daa-2fbcc28645fa",
              "timestamp" : 1472136365015
            }
          },
          "neil-katz-tiling" : {
            "4-01-f02a-py" : {
              "key" : "a4e6e4d1-fa40-4012-bc4d-4bcd77158e1c",
              "timestamp" : 1472136365216
            },
            "4-01-f02b-py" : {
              "key" : "e4464099-33e3-4b70-92e1-a3415e740798",
              "timestamp" : 1472136365017
            }
          },
          "regular-tiling" : {
            "4-01-l01a-py" : {
              "key" : "5f383857-9a57-46da-bc5e-684d607e548a",
              "timestamp" : 1472136365032
            },
            "4-01-l01b-py" : {
              "key" : "0c2aa30d-5b0b-4014-91e4-1a8214757391",
              "timestamp" : 1472136364764
            },
            "4-01-l01c-py" : {
              "key" : "33c919a2-799b-4b32-b97d-d7de1e6e9635",
              "timestamp" : 1472136364762
            }
          },
          "tiling-by-inflation" : {
            "4-01-l04a-py" : {
              "key" : "2c190cc8-7f03-4b5e-8cf4-bb2299ea1b44",
              "timestamp" : 1472136365212
            },
            "4-01-l04b-py" : {
              "key" : "8fc588d1-4af4-4175-a250-46c2d40dfb88",
              "timestamp" : 1472136364765
            },
            "4-01-l04c-py" : {
              "key" : "27fd5906-6750-49c0-bc6e-b0b63f91c529",
              "timestamp" : 1472136365033
            },
            "4-01-l04d-py" : {
              "key" : "608ea6d5-6256-4f30-a57f-075ed5fcb9b8",
              "timestamp" : 1472136364766
            }
          }
        },
        "complexity" : {
          "birds" : {
            "4-02-l05a-py" : {
              "key" : "24d91180-8179-4f24-85ab-2e3815cbf4a9",
              "timestamp" : 1472136364763
            },
            "4-02-l05b-py" : {
              "key" : "4838359c-4b4c-4458-a5cd-986c596b50bc",
              "timestamp" : 1472136364549
            },
            "4-02-l05c-py" : {
              "key" : "0f739107-63aa-47bb-aa20-628ac1124384",
              "timestamp" : 1472136364539
            },
            "4-02-l05d-py" : {
              "key" : "3818f4cf-07d5-4fea-bd24-c7c5dfe38239",
              "timestamp" : 1472136364542
            }
          },
          "cellular-automata" : {
            "4-02-l02a-py" : {
              "key" : "057b6a73-d5d4-4cce-a1f3-bb7d40650e81",
              "timestamp" : 1472136364540
            },
            "4-02-l02b-py" : {
              "key" : "8b3299bc-bd10-49ef-839c-770769bee9c9",
              "timestamp" : 1472136364543
            },
            "4-02-l02c-py" : {
              "key" : "2bea037c-4b30-4924-abc8-5f0bedd0cc39",
              "timestamp" : 1472136364541
            }
          },
          "fornes" : {
            "4-02-f02a-py" : {
              "key" : "9d41c4cb-c5f9-4276-8808-6d34e6cce6e1",
              "timestamp" : 1472136364290
            },
            "4-02-f02b-py" : {
              "key" : "691a1853-90e6-422a-8ec5-eebafba78780",
              "timestamp" : 1472136364765
            },
            "4-02-f02c-py" : {
              "key" : "d1c3af98-a546-4478-8011-e7ddc6f91cf5",
              "timestamp" : 1472136364292
            }
          },
          "lsystem" : {
            "4-02-l06a-py" : {
              "key" : "85b10f38-b62d-44e9-8f42-f44748c90626",
              "timestamp" : 1472136364541
            },
            "4-02-l06b-py" : {
              "key" : "22a8c7ee-e9db-4876-b2a1-b52815b40d9d",
              "timestamp" : 1472136364291
            },
            "4-02-l06c-py" : {
              "key" : "05e8fbaf-0823-4f7c-bdce-9e0b7769647f",
              "timestamp" : 1472136364293
            }
          },
          "reaction-diffusion" : {
            "4-02-l01a-py" : {
              "key" : "a01a7cfc-4f2a-4bf5-9f2d-c03501360aa7",
              "timestamp" : 1472136364294
            },
            "4-02-l01b-py" : {
              "key" : "499efb31-ef9b-49cb-b574-40ccd564ba7b",
              "timestamp" : 1472136364076
            },
            "4-02-l01c-py" : {
              "key" : "22d0ad95-d1ed-41b2-baa3-4639b9e6c9c2",
              "timestamp" : 1472136363984
            }
          },
          "sabin" : {
            "4-02-f01a-py" : {
              "key" : "a5d2bf6a-8743-4278-8055-d59b7c10b5c2",
              "timestamp" : 1472136363988
            },
            "4-02-f01b-py" : {
              "key" : "88c83570-7b75-4f02-9473-a1fd33fec63d",
              "timestamp" : 1472136364074
            },
            "4-02-f01c-py" : {
              "key" : "a7dfdefc-b456-403f-9c43-6a0337b08853",
              "timestamp" : 1472136364075
            },
            "4-02-f01d-py" : {
              "key" : "f200e65b-0cad-4ed8-8e09-fc89f3907aa5",
              "timestamp" : 1472136364073
            }
          },
          "walkers" : {
            "4-02-l04a-py" : {
              "key" : "83e7b3e4-4989-4700-b114-3e32dec3045d",
              "timestamp" : 1472136363798
            },
            "4-02-l04b-py" : {
              "key" : "60f2e021-3164-47a5-af4e-795567d842de",
              "timestamp" : 1472136363668
            },
            "4-02-l04c-py" : {
              "key" : "6c15050a-dca3-4d3b-8d7b-94c4a93767a7",
              "timestamp" : 1472136364072
            },
            "4-02-l04d-py" : {
              "key" : "eddadb34-dd01-43e8-a39d-1a44a426a099",
              "timestamp" : 1472136363668
            },
            "4-02-l04e-py" : {
              "key" : "a34e385e-55c2-41ca-868d-86b43e398b3f",
              "timestamp" : 1472136363669
            },
            "4-02-l04f-py" : {
              "key" : "8e6d9a8c-41ce-4fd8-8c3b-d287c1014c87",
              "timestamp" : 1472136363455
            }
          }
        },
        "decomposition" : {
          "bespoke-parameterizations" : {
            "4-03-l01a-py" : {
              "key" : "70451a57-0efb-47dc-bf50-bd297b66dbb0",
              "timestamp" : 1472136363458
            },
            "4-03-l01b-py" : {
              "key" : "b776bd57-b073-4d56-963d-aa9ee6106f0e",
              "timestamp" : 1472136363459
            }
          },
          "curve-decomposition" : {
            "4-03-l02a-py" : {
              "key" : "f1b1f8bc-1a8e-40fd-9a3a-c576d6260647",
              "timestamp" : 1472136363460
            },
            "4-03-l02b-py" : {
              "key" : "1f70538d-514a-46a4-85d9-e9197f02931b",
              "timestamp" : 1472136363632
            },
            "4-03-l02c-py" : {
              "key" : "8a4a31d3-b01b-413c-9993-306dd014d88d",
              "timestamp" : 1472136363464
            },
            "4-03-l02d-py" : {
              "key" : "16706193-3546-42fb-a5e0-5cbe5309990b",
              "timestamp" : 1472136363667
            }
          },
          "dennis-shelden" : {
            "4-03-f02a-py" : {
              "key" : "90d42640-ce7a-458b-89ac-fc7d6e81bd2d",
              "timestamp" : 1472136363457
            },
            "4-03-f02b-py" : {
              "key" : "97df14fe-b884-42aa-9603-4d4d42ef0505",
              "timestamp" : 1472136363188
            },
            "4-03-f02c-py" : {
              "key" : "01a7dd08-7efb-4205-8e75-1e2ce4429d1f",
              "timestamp" : 1472136363193
            },
            "4-03-f02d-py" : {
              "key" : "3c0ba38f-5305-4ce9-bfdb-13f57b97f71b",
              "timestamp" : 1472136363275
            },
            "4-03-f02e-py" : {
              "key" : "8fcc7ae6-0a5a-462a-ae67-0d1599dbab85",
              "timestamp" : 1472136363276
            }
          },
          "foster-pre-rational-studies" : {
            "4-03-f01a-py" : {
              "key" : "a214b26a-0777-43bb-a709-a52d0fbb0e79",
              "timestamp" : 1472136363281
            },
            "4-03-f01c-py" : {
              "key" : "f22a08f6-dbc5-4198-a806-adae47fe17d8",
              "timestamp" : 1472136363195
            },
            "4-03-f01d-py" : {
              "key" : "4daf6398-8a31-4d02-8592-b3b6ee8fe987",
              "timestamp" : 1472136363017
            },
            "4-03-f01e-py" : {
              "key" : "ba87b67a-22ac-421e-bec9-f7efc23a4ef5",
              "timestamp" : 1472136363018
            }
          },
          "martin-zahner" : {
            "4-03-f03a-py" : {
              "key" : "03b63141-6eb1-4578-84c5-f7f35b080695",
              "timestamp" : 1472136363020
            },
            "4-03-f03b-py" : {
              "key" : "eb99293a-b490-407a-85af-6c8c09a0bbbe",
              "timestamp" : 1472136363274
            }
          },
          "post-rational-panelization" : {
            "4-03-l05a-py" : {
              "key" : "49427bae-40e8-4d66-ab5d-f9caab6a48d2",
              "timestamp" : 1472136362760
            },
            "4-03-l05b-py" : {
              "key" : "1f2a6981-304d-43ba-93e6-1ab74b163073",
              "timestamp" : 1472136362794
            },
            "4-03-l05c-py" : {
              "key" : "31e5857e-39bc-43cf-827f-cf810002221b",
              "timestamp" : 1472136363021
            }
          },
          "pre-rational-torus-studies" : {
            "4-03-l04a-py" : {
              "key" : "b68e93c5-0bb8-4168-ac36-2cf404f8c7c0",
              "timestamp" : 1472136363020
            },
            "4-03-l04b-py" : {
              "key" : "cc2b4d3e-9d4c-48e3-8722-f747b64f35ee",
              "timestamp" : 1472136363022
            },
            "4-03-l04c-py" : {
              "key" : "8cb4ea57-a7c0-4931-a23c-a5abf891681d",
              "timestamp" : 1472136363019
            }
          },
          "surface-decomposition-based-on-curvature" : {
            "4-03-l03b-py" : {
              "key" : "1c04c298-e12c-4fd2-9f89-3c0ea672f135",
              "timestamp" : 1472136362568
            },
            "4-03-l03c-py" : {
              "key" : "4db788fc-dcf7-40e3-bf3c-78c83066a515",
              "timestamp" : 1472136362572
            }
          }
        },
        "exploration" : {
          "a-design-space-of-flatware" : {
            "4-04-l02b-py" : {
              "key" : "f7dc1d7c-0f69-4fe2-b011-eb328819827f",
              "timestamp" : 1472136362573
            },
            "4-04-l02c-py" : {
              "key" : "8520ba5e-f023-4220-bb31-f005d639ea65",
              "timestamp" : 1472136362577
            }
          },
          "design-space-of-blobs" : {
            "4-04-l05a-py" : {
              "key" : "899f242f-d7a3-4b12-8aea-84d0cae4de82",
              "timestamp" : 1472136362582
            },
            "4-04-l05b-py" : {
              "key" : "41dc0e68-49fe-4205-bfb1-aa4c98b8cf1f",
              "timestamp" : 1472136362380
            }
          },
          "design-space-of-colors" : {
            "4-04-l01a-py" : {
              "key" : "d4fbd02c-e935-41bf-82f1-990a79b09ded",
              "timestamp" : 1472136362795
            },
            "4-04-l01b-py" : {
              "key" : "68765563-72a2-4db3-b8a7-bb390b98769c",
              "timestamp" : 1472136362575
            }
          },
          "design-space-of-columns" : {
            "4-04-l04a-py" : {
              "key" : "beae2b23-a9dc-414a-b33f-4683dda82640",
              "timestamp" : 1472136362381
            },
            "4-04-l04b-py" : {
              "key" : "6d535c7b-783c-47aa-97d2-46751b240411",
              "timestamp" : 1472136362180
            }
          },
          "helios-house" : {
            "4-04-f01a-py" : {
              "key" : "1d97d0a3-fea6-4a0a-b451-eb8adc2fe1b2",
              "timestamp" : 1472136362378
            }
          },
          "mathematical-tweening" : {
            "4-04-l03a-py" : {
              "key" : "9ef4be95-245f-4c5c-9a7f-049c5eb69ef4",
              "timestamp" : 1472136362374
            }
          },
          "right-to-light" : {
            "4-04-f03a-py" : {
              "key" : "7ff1f3c6-4db2-46f8-9436-4f1f48c20419",
              "timestamp" : 1472136362181
            },
            "4-04-f03b-py" : {
              "key" : "42e30788-c7af-4393-8c9b-2acb61d4461a",
              "timestamp" : 1472136362182
            }
          }
        },
        "fabrication" : {
          "3d-printed-toolpathing" : {
            "4-05-l06a-py" : {
              "key" : "83f516b8-afd2-4c7e-91b2-bafeea20e7cd",
              "timestamp" : 1472136362185
            },
            "4-05-l06b-py" : {
              "key" : "b8e8ddf0-a610-4df6-bcea-896d32091687",
              "timestamp" : 1472136361919
            }
          },
          "bending-active" : {
            "4-05-f01a-py" : {
              "key" : "d662a720-730e-4fae-9233-3f0965115177",
              "timestamp" : 1472136361926
            },
            "4-05-f01b-py" : {
              "key" : "684dbcf9-673b-4e33-92e0-46596aa5dcee",
              "timestamp" : 1472136361915
            }
          },
          "encoding-material-behavior" : {
            "4-05-l05a-py" : {
              "key" : "7666a5b9-75d0-4bc3-95a1-892cc398ecf7",
              "timestamp" : 1472136362379
            },
            "4-05-l05b-py" : {
              "key" : "8f30144f-25fb-4e9e-9965-118b27e374e7",
              "timestamp" : 1472136361954
            }
          },
          "flatness" : {
            "4-05-l02a-py" : {
              "key" : "caf3bd8a-cd3c-450a-8124-535e95bccc12",
              "timestamp" : 1472136361966
            },
            "4-05-l02b-py" : {
              "key" : "d8a78ea6-a24e-47da-a957-1810a6e02f63",
              "timestamp" : 1472136361743
            },
            "4-05-l02c-py" : {
              "key" : "acf10043-136b-4fa2-acd9-4274b04b60c6",
              "timestamp" : 1472136361746
            }
          },
          "packing" : {
            "4-05-l01a-py" : {
              "key" : "8572b6e0-fb0f-4f29-b39d-85acafccb04d",
              "timestamp" : 1472136361752
            },
            "4-05-l01b-py" : {
              "key" : "24171259-01e9-4b76-b73b-7b91ded5b1ad",
              "timestamp" : 1472136361935
            },
            "4-05-l01c-py" : {
              "key" : "6230a0c6-1b57-47cf-a0d9-9dd24770038d",
              "timestamp" : 1472136361750
            },
            "4-05-l01d-py" : {
              "key" : "5fabe81b-2e67-4009-a807-e7a0518f9824",
              "timestamp" : 1472136361748
            },
            "4-05-l01e-py" : {
              "key" : "96b29541-44b3-4a97-a68d-04d507bec376",
              "timestamp" : 1472136361199
            },
            "4-05-l01f-py" : {
              "key" : "62b67a70-470a-42a0-a0d6-915f7f07a384",
              "timestamp" : 1472136361255
            }
          },
          "pwall" : {
            "4-05-f02c-py" : {
              "key" : "8a94cd94-8eb0-4f6d-8fb4-85008f0c326d",
              "timestamp" : 1472136361751
            }
          },
          "sanddollar" : {
            "4-05-f03a-py" : {
              "key" : "3394191f-99ed-4845-bdc7-07d004808ed7",
              "timestamp" : 1472136361933
            },
            "4-05-f03c-py" : {
              "key" : "940c41a6-1e57-47ad-8a61-fbbb7f91ab23",
              "timestamp" : 1472136361257
            }
          },
          "toolpathing" : {
            "4-05-l03a-py" : {
              "key" : "3b92bb27-57c0-4883-98a6-97a5828bfdf2",
              "timestamp" : 1472136361259
            },
            "4-05-l03b-py" : {
              "key" : "8d1c6ec5-b85d-49a1-bf19-3d37f30ed982",
              "timestamp" : 1472136361260
            },
            "4-05-l03c-py" : {
              "key" : "b774b160-11c2-46ff-af10-84f6980e5ed9",
              "timestamp" : 1472136361251
            }
          }
        },
        "optimization" : {
          "best-fit" : {
            "4-07-l06a-py" : {
              "key" : "96a16265-1aaa-47ab-9470-2e4c1f8b00c5",
              "timestamp" : 1472136361300
            },
            "4-07-l06b-py" : {
              "key" : "c88b5bed-778b-40ae-b6c6-72e3a69f9b46",
              "timestamp" : 1472136361308
            },
            "4-07-l06c-py" : {
              "key" : "067b7da5-b53c-4757-bc19-5ca00fdc3867",
              "timestamp" : 1472136361328
            },
            "4-07-l06d-py" : {
              "key" : "a8d545a9-0d76-4c25-a0ee-41ef2109ac68",
              "timestamp" : 1472136361362
            }
          },
          "color-optimization" : {
            "4-07-l01a-py" : {
              "key" : "1df4d1b4-8f73-4de2-b7b5-e3c775903d57",
              "timestamp" : 1472136361364
            },
            "4-07-l01b-py" : {
              "key" : "f58a95ea-334d-4709-a3b6-20c558693d90",
              "timestamp" : 1472136361365
            },
            "4-07-l01c-py" : {
              "key" : "7b9f825d-f5a4-49f7-9b08-7655ddc94854",
              "timestamp" : 1472136361375
            }
          },
          "floor-facade-area-optimization" : {
            "4-07-l02a-py" : {
              "key" : "3381f21d-a729-4bf9-8047-2a4d71e277b7",
              "timestamp" : 1472136361379
            },
            "4-07-l02b-py" : {
              "key" : "d13720e9-7414-4800-93ec-87e9d0d1afe2",
              "timestamp" : 1472136361377
            },
            "4-07-l02c-py" : {
              "key" : "969ff47a-23c5-41f9-bcf5-faa3db768efe",
              "timestamp" : 1472136361387
            },
            "4-07-l02d-py" : {
              "key" : "2e62cc75-1d82-46d1-9821-d6e099eb1516",
              "timestamp" : 1472136361412
            }
          },
          "great-court-roof-relaxation" : {
            "4-07-f01a-py" : {
              "key" : "923d555b-0c10-4f86-864f-e843730bbdfd",
              "timestamp" : 1472136361304
            }
          },
          "mesh-relaxation" : {
            "4-07-l05a-py" : {
              "key" : "5be1e51d-9df7-4d88-a4a5-34bf0d899942",
              "timestamp" : 1472136361413
            },
            "4-07-l05b-py" : {
              "key" : "b6bec15f-12a8-4def-80f6-dff1bf6bc0e8",
              "timestamp" : 1472136361422
            },
            "4-07-l05c-py" : {
              "key" : "7c2b0218-18f9-499f-9de4-815e51fd5386",
              "timestamp" : 1472136361424
            },
            "4-07-l05d-py" : {
              "key" : "4a4ea360-45cf-43e8-84ef-8ee95319641a",
              "timestamp" : 1472136361425
            }
          },
          "solar-gain" : {
            "4-07-l07a-py" : {
              "key" : "d74d8ba6-4d91-4854-829d-b92e9fcbba46",
              "timestamp" : 1472136361426
            }
          },
          "williams-biot-savart" : {
            "4-07-f02a-py" : {
              "key" : "d8f11d83-04ef-4e85-8360-f64a47861c12",
              "timestamp" : 1472136361419
            },
            "4-07-f02b-py" : {
              "key" : "6cb113ca-3987-4dad-b648-f4ec6bbefc15",
              "timestamp" : 1472136361428
            },
            "4-07-f02c-py" : {
              "key" : "7ade47ca-b05c-4cc4-8684-8282ed341309",
              "timestamp" : 1472136361435
            },
            "4-07-f02d-py" : {
              "key" : "04d11804-0821-48cf-8186-8b39ed435aea",
              "timestamp" : 1472136361432
            },
            "4-07-f02e-py" : {
              "key" : "46705747-1ac9-4979-a3fc-c5fa39955efc",
              "timestamp" : 1472136361437
            }
          }
        }
      }
    }
  }
}
